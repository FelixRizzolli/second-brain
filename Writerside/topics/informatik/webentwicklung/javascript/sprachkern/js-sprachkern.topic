<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
        SYSTEM "https://resources.jetbrains.com/writerside/1.0/xhtml-entities.dtd">
<topic id="js-sprachkern"
       title="Sprachkern"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="https://resources.jetbrains.com/writerside/1.0/topic.v2.xsd">
    <show-structure depth="2" for="chapter,procedure"/>


    <!-- TODO: migrate from Confluence -->
    <chapter id="webseite" title="JavaScript auf einer Webseite verwenden">
        <p>
            JavaScript-Code wird auf einer Website mit den <code>&lt;script&gt;&gt;/script&gt;</code>-Tags angegeben.
            Dabei kann der Code direkt innerhalb der Tags geschrieben werden oder auf ein externes File ausgelagert und
            mit dem <code>src</code>-Attribut darauf verlinkt werden. Für den <code>script</code>-Tag gibt es noch
            weitere Attribute, die dessen ladeverhalten bestimmen:
        </p>

        <table style="header-column">
            <tr>
                <td>
                    <code>defer</code>
                </td>
                <td>
                    <p>
                        Das Script soll geladen werden, nachdem die HTML-Seite geladen wurde.
                    </p>
                </td>
            </tr>
            <tr>
                <td>
                    <code>async</code>
                </td>
                <td>
                    <p>
                        Das Script soll direkt parallel zum Parsen der restlichen Seite geladen werden.
                    </p>
                    <p>
                        Greift das Script direkt auf HTML-Elemente zu, die noch nicht geladen wurde, kann es zu Fehlern
                        kommen.
                    </p>
                </td>
            </tr>
        </table>
    </chapter>

    <chapter id="kommentare" title="Kommentare">
        <tip>
            Grundlegendes zu Kommentare: <a href="swe-pk-kommentare.topic"/>
        </tip>

        <p>
            In JavaScript gibt es wie in den meisten Programmiersprachen zwei Arten von Kommentaren. Das einzeilige und
            der mehrzeilige Kommentar.
        </p>

        <code-block collapsed-title="Beispeiel" collapsible="true" lang="javascript">
            <![CDATA[
                //Ein Einzeiliges Kommentar.

                /*
                Ein Mehrzeiliges Kommentar.
                */
            ]]>
        </code-block>

        <chapter id="kommentare-notation" title="Notation (fat arrow)">
            <p>

                Möchte man ein Kommentar erstellen, welches darüber Aufschluss gibt wie das Ergebnis lauten könnte,
                verwendet man einen sogenannten <b>fat arrow <code>=&gt;</code></b>.
            </p>
            <code-block lang="javascript">
                <![CDATA[
                    console.log(3 + 4 * 2); //=> 11
                ]]>
            </code-block>
        </chapter>
    </chapter>

    <chapter id="variablen" title="Variablen, Konstanten und Typisierung">
        <tip>
            Grundlegendes zo Variablen: <a href="swe-pk-grundlagen-variablen.topic"/>
        </tip>

        <chapter id="variablen-v" title="Variablen">
            <img alt="Variablendeklaration in JavaScript" src="js-sprachkern-variable-declaration.jpg"/>

            <p>
                Mit dem Schlüsselwort <code>let</code> erstellt man eine Variable. Je nachdem welcher Wert ihr
                zugewiesen
                wird, wird der Datentyp bestimmt. Noch wichtig zu wissen ist, dass jeder Wert - egal ob String oder
                Zahl - der direkt im Code steht, als Literal bezeichnet wird. Sie haben immer einen festen Wert.
                Literale haben auch einen <b>Datentyp</b> (= <code>string</code> oder <code>number</code>) welcher
                mit dem Operator <code>typeof</code> ermittelt werden kann. Bei numerischen Werten mit Kommas wird die
                amerikanische Schreibweise verwendet (Punkt statt Komma).
            </p>

            <p>
                Syntax (<b>Lass</b> <i>(früher var)</i> die Variable username Rizz sein)
            </p>

            <code-block lang="javascript">
                <![CDATA[
                    let username = "Rizz";
                    console.log(typeof variable); //=> string
                ]]>
            </code-block>

            <p>
                Die Wertzuweisung einer Variable erfolgt von rechts nach links, das bedeutet der Wert rechts vom
                Zuweisungsoperator wird der Variable links zugewiesen und nicht umgekehrt. In eine Variable lässt sich
                ein Wert einspeichern, aber in einen Wert keine Variable.
            </p>

            <p>
                Der Datentyp <code>string</code>, englischer Begriff für Zeichenkette, kann mit zwei Möglichkeiten
                definiert werden (einfache und doppelte Anführungszeichen):
            </p>

            <code-block lang="javascript">
                <![CDATA[
                    let neueVariable = "be"; //=> be
                    let neueVariable = 'be'; //=> be
                ]]>
            </code-block>

            <p>
                Die Variable des Datentyps <code>String</code> ist ein Objekt. Von dieser Variablen kann die Eigenschaft
                <code>length</code> Abgefragt (Länge) werden. Diese Eigenschaft gibt die Anzahl der Zeichen der
                Zeichenkette zurück. Beispiel: <code>console.log(&quot;Hallo Welt!&quot;.length); //=&gt; 11</code>
            </p>

            <chapter id="variablen-namensgebung" title="Namensgebung für Variablen">
                <list type="bullet">
                    <li>
                        Aussagekräftige Bezeichner (<code>alter</code> statt <code>x</code>, <code>vorname</code> statt
                        <code>z</code>, <code>preis</code> statt <code>p</code>)
                    </li>
                    <li>
                        Keine Sonderzeichen
                    </li>
                    <li>
                        <a href="swe-pk-richtlinien.topic">lowerCamelCasing</a> (Neues Wort beginnt mit einem
                        Großbuchstaben)
                    </li>
                </list>
            </chapter>

            <chapter id="variablen-let-vs-var" title="let vs. var">
                <table style="header-column">
                    <tr>
                        <td>
                            Deklatation
                        </td>
                        <td>
                            <p>
                                Die Deklaration einer Variable mit <code>let</code> hindert uns daran, eine Variable ein
                                zweites Mal mit demselben Namen zu deklarieren. Hierbei wird ein
                                <code>SyntaxError</code> geworfen. Bei <code>var</code> ist dies hingegen ohne Fehler
                                möglich.
                            </p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            Scope
                        </td>
                        <td>
                            <p>
                                Variablen, welche mit <code>let</code> deklariert wurden, sind "block-scoped", das
                                bedeutet, ihr Sichtbarkeitsbereich liegt innerhalb eines Blocks. Variablen, welche mit
                                <code>var</code> deklariert wurden, sind "function-scoped", das bedeutet ihr
                                Sichtbarkeitsbereich liegt innerhalb einer Funktion. Wird eine variable mit
                                <code>var</code> innerhalb eines Blocks (kein Funktionsblock) deklariert, so ist diese
                                auch außerhalb davon, also innerhalb der ganzen Funktion bzw. global, sichtbar.
                            </p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            Hoisting
                        </td>
                        <td>
                            <p>
                                Hoisting wird die Technik genannt, welche alle Variablendeklarationen zum Anfang
                                verschiebt. Bei <code>let</code> werden die Deklarationen zum Anfang des Blocks
                                verschoben, und bei <code>var</code> zum Anfang der Funktion.
                            </p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            Shadowing
                        </td>
                        <td>
                            <p>
                                Wenn wir einer globalen und einer lokalen Variable denselben Namen geben, dann wird
                                dies als Variable Shadowing bezeichnet. Denn die globale Variable wird nicht von der
                                lokalen überschrieben, sondern die globale wird unsichtbar und eine neue Variable mit
                                demselben Bezeichner wird lokal erstellt. Für var bedeutet lokal <code>=</code>
                                innerhalb einer Funktion; für <code>let</code> bedeutet lokal <code>=</code> innerhalb
                                eines Blocks.
                            </p>
                        </td>
                    </tr>
                </table>
            </chapter>
        </chapter>

        <chapter id="variablen-konstanten" title="Konstanten">
            <tip>
                Grundlegendes zu Konstanten: <a href="swe-pk-grundlagen-variablen.topic#konstanten"/>
            </tip>

            <p>
                Konstanten werden in JavaScript immer mit dem Schlüsselwort <code>const</code> (für eng. constant)
                deklariert. Das Beste ist, wenn man immer versucht mit Konstanten auszukommen, anstatt eine Variable zu
                verwenden. Somit vermeidet man, dass sich der wert (natürlich durch eigenes Verschulden) ungewollt
                ändert. Zudem kann für <code>const</code> die JS Engine den Code optimieren, was Auswirkungen auf die
                Performance haben kann.
            </p>

            <code-block lang="javascript">
                <![CDATA[
                    const TAX_RATE = 1.22; //Multiplikator für Mehrwertsteuer
                ]]>
            </code-block>

            <p>
                Versucht man, eine Konstante zu überschreiben, ignorieren die meisten Laufzeitumgebungen die
                entsprechende Anweisung stillschweigend (also ohne einen Fehler zu produzieren).
            </p>

            <chapter id="variablen-konstanten-namensgebung" title="Namensgebung für Konstante">
                <list type="bullet">
                    <li>
                        Aussagekräftige Bezeichner
                    </li>
                    <li>
                        Keine Sonderzeichen
                    </li>
                    <li>
                        <a href="swe-pk-richtlinien.topic">SCREAMING_SNAKE</a> (Nur Großbuchstaben; Worttrennung durch
                        Unterstrich)
                    </li>
                </list>
            </chapter>
        </chapter>

        <chapter id="variablen-typisierung" title="Typisierung">
            <chapter id="variablen-typisierung-impliziert" title="Implizierte Typkonvertierung">
                <p>
                    Was ergibt <code>&quot;5&quot; * &quot;4&quot;</code>? Die Antwort ist <code>"20"</code> mit dem
                    Datentyp <code>number</code>. Das liegt daran, dass der Multiplikator als Operanden zwei Zahlen
                    erwartet. Ist ein Operand vom Datentyp <code>string</code> so wird von JS eine sogenannte
                    implizierte Typkonvertierung durchgeführt. Der Fachausdruck dafür lautet <b>coercion</b>. Auch die
                    Operanden <code>/</code> und <code>–</code> verwenden coercion.
                </p>
            </chapter>

            <chapter id="variablen-typisierung-explizit" title="Explizite Typkonvertierung">
                <code-block lang="javascript">
                    <![CDATA[
                        let number1 = prompt(„Gib eine Nummer ein!“);   //Eingabe 1
                        let number2 = prompt(„Gib eine Nummer ein!“);   //Eingabe 2
                        console.log(„Summe:“ + (number1 + number2));    //=> Summe: 12
                    ]]>
                </code-block>

                <p>
                    Das Problem hier ist, dass die Funktion <code>prompt()</code> immer einen Wert des Datentyps
                    <code>string</code> zurückgibt. Um das zu lösen, muss man den Datentyp mit der Funktion
                    <code>Number()</code> konvertieren <code>=</code> explizite Typkonvertierung. Handelt es sich
                    jedoch bei dem übergebenen an die Funktion <code>Number()</code> um keine Zahl oder eine Mischung
                    aus Zahl und Text, so lautet der Rückgabewert <code>NaN</code> (Not a Number).
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        typeof(NaN); //=> number
                    ]]>
                </code-block>
            </chapter>
        </chapter>
    </chapter>

    <chapter id="datentypen" title="Datentypen">

        <chapter id="datentypen-konstruktor-methoden" title="Konstruktor-Methoden">

        </chapter>

        <chapter id="datentypen-autoboxing" title="Autoboxing">

        </chapter>
    </chapter>

    <chapter id="operatoren" title="Operatoren">

        <chapter id="operatoren-prio" title="Prioritätsliste">

        </chapter>

        <chapter id="operatoren-unaer" title="Unäre Operatoren + und -">

        </chapter>

        <chapter id="operatoren-logische-zuweisung" title="Logische Zuweisungsoperatoren &amp;&amp;= und ||=">

        </chapter>

        <chapter id="operatoren-logisch" title="Logische Operatoren und nicht boolsche Werte">

        </chapter>

        <chapter id="operatoren-typof" title="Typbestimmung – Der typeof- und der instanceof-Operator">

        </chapter>

        <chapter id="operatoren-nach-kategorie" title="Operatoren nach Kategorie">

        </chapter>
    </chapter>

    <chapter id="kontrollstrukturen" title="Krontrollstrukturen">

        <chapter id="kontrollstrukturen-auswahlstrukturen" title="Auswahlstrukturen">

            <chapter id="kontrollstrukturen-auswahlstrukturen-if" title="if-elseif-else-Statement">

                <chapter id="kontrollstrukturen-auswahlstrukturen-if-syntax" title="Syntax">

                </chapter>

                <chapter id="kontrollstrukturen-auswahlstrukturen-if-beispiel" title="Beispiel">

                </chapter>

                <chapter id="kontrollstrukturen-auswahlstrukturen-if-kurzschreibweise" title="Kurzschreibweise">

                </chapter>
            </chapter>

            <chapter id="kontrollstrukturen-auswahlstrukturen-tertiaerer-operator" title="Der tertiäre Operator">

            </chapter>

            <chapter id="kontrollstrukturen-auswahlstrukturen-switch" title="Mehrfachverzweigungen: switch-Statement">

            </chapter>
        </chapter>

        <chapter id="kontrollstrukturen-schleifen" title="Schleifen">

            <chapter id="kontrollstrukturen-schleifen-for" title="Zählschleife – die for-Schleife">

            </chapter>

            <chapter id="kontrollstrukturen-schleifen-for-of-in" title="Die for-of-Schleife und for-in-Schleife">

            </chapter>

            <chapter id="kontrollstrukturen-schleifen-while" title="Kopfgesteuerte Schleife – die while-Schleife">

            </chapter>

            <chapter id="kontrollstrukturen-schleifen-do-while" title="Fußgesteuerte Schleife – die do-while-Schleife">

            </chapter>

            <chapter id="kontrollstrukturen-schleifen-abbrechen" title="Schleifen vorzeitig abbrechen">

                <chapter id="kontrollstrukturen-schleifen-break" title="Die break-Anweisung">

                </chapter>

                <chapter id="kontrollstrukturen-schleifen-continue" title="Die continue-Anweisung">

                </chapter>
            </chapter>

            <chapter id="kontrollstrukturen-schleifen-goto" title="Sprungmarken">

            </chapter>
        </chapter>
    </chapter>

    <chapter id="funktionen" title="Funktionen">

        <chapter id="funktionen-basis" title="Basis Funktionsdeklaration und Funktionsausdruck">

        </chapter>

        <chapter id="funktionen-parameter" title="Parameter">

            <chapter id="funktionen-parameter-weniger-argumente-als-parameter"
                     title="Funktionen mit weniger Argumenten als angegebenen Parametern aufrufen">

            </chapter>

            <chapter id="funktionen-parameter-mehr-arugmente-als-parameter"
                     title="Funktionen mit mehr Argumenten als angegebenen Parametern aufrufen">

            </chapter>

            <chapter id="funktionen-parameter-variable-anzahl-an-argumenten"
                     title="Funktionen mit einer variablen Anzahl an Argumenten – variadische Funktionen">

            </chapter>

            <chapter id="funktionen-parameter-spread-operator"
                     title="Der Spread-Operator – Elemente aus einem Array als Argumente verwenden">

            </chapter>

            <chapter id="funktionen-parameter-standardwerte" title="Standardwerte für Parameter">

            </chapter>

            <chapter id="funktionen-parameter-funktionen" title="Funktion als Parameter">

            </chapter>
        </chapter>

        <chapter id="funktionen-return" title="Rückgabewerte">

        </chapter>

        <chapter id="funktionen-arrow-functions" title="Arrow Functions bzw. Fat Arrow Functions">

            <chapter id="funktionen-arrow-functions-return" title="Objekt als Rückgabewert">

            </chapter>

            <chapter id="funktionen-arrow-functions-eigenschaften" title="Weitere Eigenschaften von Arrow Functions">

            </chapter>
        </chapter>

        <chapter id="funktionen-ausfuehrungskontext" title="Ausführungskontexte">

            <chapter id="funktionen-gueltigkeitsbereich" title="Gültigkeitsbereiche">

            </chapter>

            <chapter id="funktionen-kontextobjekt" title="Kontextobjekt">

            </chapter>
        </chapter>

        <chapter id="funktionen-funktionsaufruf-durch-nutzerinteraktion"
                 title="Funktionsaufruf durch Nutzerinteraktion">

        </chapter>
    </chapter>

    <chapter id="vordefiniert" title="Vordefinierte Funktionen und Objekte">

        <chapter id="vordefiniert-console" title="Konsolenausgabe">

        </chapter>

        <chapter id="vordefiniert-warnungsfenster" title="Warnungsfenster">

        </chapter>

        <chapter id="vordefiniert-eingabefenster" title="Eingabefenster">

        </chapter>

        <chapter id="vordefiniert-use-strict" title="Der &quot;use strict&quot; Modus">

        </chapter>

        <chapter id="vordefiniert-konstante" title="Konstante">

        </chapter>

        <chapter id="vordefiniert-parameter" title="Parameter">

        </chapter>

        <chapter id="vordefiniert-globale-variablen" title="Globale Variablen">

        </chapter>

        <chapter id="vordefiniert-abgeschottete-bloecke" title="Abgeschottete Blöcke">

        </chapter>

        <chapter id="vordefiniert-strikter-modus-in-funktionen" title="Strikter Modus in Funktionen">

        </chapter>
    </chapter>

    <chapter id="sichtbarkeit" title="Sichtbarkeit">

        <chapter id="sichtbarkeit-funktionen-in-funktionen"
                 title="Funktionen innerhalb von Funktionen definieren">

        </chapter>
    </chapter>

    <chapter id="fehlerbehandlung" title="Fehlerbehandlung">

        <chapter id="fehlerbehandlung-fehlerarten" title="Fehlerarten">

        </chapter>

        <chapter id="fehlerbehandlung-laufzeitfehler" title="Fehlerbehandlung von Laufzeitfehlern in JavaScript">

        </chapter>

        <chapter id="fehlerbehandlung-try-catch-finally" title="Fehler mit try-catch-finally fangen">

            <chapter id="fehlerbehandlung-error" title="Das Fehlerobjekt error">

            </chapter>
        </chapter>

        <chapter id="fehlerbehandlung-throw" title="Fehler mit throw auslösen">

        </chapter>

        <chapter id="fehlerbehandlung-fehlertypen" title="Fehlertypen">

        </chapter>
    </chapter>

    <chapter id="quellen" title="Quellen">
        <tip>
            <b>(BUCH)</b>
            978-3836256971, "JavaScript", Philip Ackermann, 2019
        </tip>
        <tip>
            <b>(WEBSEITE)</b>
            <a href="https://www.w3schools.com/js/js_whereto.asp"/>, 2023-11-06 08:00
        </tip>
        <tip>
            <b>(WEBSEITE)</b>
            <a href="https://edube.org/learn/jse1-1-0-1/precedence-continued-1"/>, 2023-11-07 07:00
        </tip>
    </chapter>
</topic>