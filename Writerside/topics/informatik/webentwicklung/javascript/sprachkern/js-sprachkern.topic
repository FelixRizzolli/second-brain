<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
        SYSTEM "https://resources.jetbrains.com/writerside/1.0/xhtml-entities.dtd">
<topic id="js-sprachkern"
       title="Sprachkern"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="https://resources.jetbrains.com/writerside/1.0/topic.v2.xsd">
    <show-structure depth="2" for="chapter,procedure"/>


    <!-- TODO: migrate from Confluence -->
    <chapter id="webseite" title="JavaScript auf einer Webseite verwenden">
        <p>
            JavaScript-Code wird auf einer Website mit den <code>&lt;script&gt;&gt;/script&gt;</code>-Tags angegeben.
            Dabei kann der Code direkt innerhalb der Tags geschrieben werden oder auf ein externes File ausgelagert und
            mit dem <code>src</code>-Attribut darauf verlinkt werden. Für den <code>script</code>-Tag gibt es noch
            weitere Attribute, die dessen ladeverhalten bestimmen:
        </p>

        <table style="header-column">
            <tr>
                <td>
                    <code>defer</code>
                </td>
                <td>
                    <p>
                        Das Script soll geladen werden, nachdem die HTML-Seite geladen wurde.
                    </p>
                </td>
            </tr>
            <tr>
                <td>
                    <code>async</code>
                </td>
                <td>
                    <p>
                        Das Script soll direkt parallel zum Parsen der restlichen Seite geladen werden.
                    </p>
                    <p>
                        Greift das Script direkt auf HTML-Elemente zu, die noch nicht geladen wurde, kann es zu Fehlern
                        kommen.
                    </p>
                </td>
            </tr>
        </table>
    </chapter>

    <chapter id="kommentare" title="Kommentare">
        <tip>
            Grundlegendes zu Kommentare: <a href="swe-pk-kommentare.topic"/>
        </tip>

        <p>
            In JavaScript gibt es wie in den meisten Programmiersprachen zwei Arten von Kommentaren. Das einzeilige und
            der mehrzeilige Kommentar.
        </p>

        <code-block collapsed-title="Beispeiel" collapsible="true" lang="javascript">
            <![CDATA[
                //Ein Einzeiliges Kommentar.

                /*
                Ein Mehrzeiliges Kommentar.
                */
            ]]>
        </code-block>

        <chapter id="kommentare-notation" title="Notation (fat arrow)">
            <p>

                Möchte man ein Kommentar erstellen, welches darüber Aufschluss gibt wie das Ergebnis lauten könnte,
                verwendet man einen sogenannten <b>fat arrow <code>=&gt;</code></b>.
            </p>
            <code-block lang="javascript">
                <![CDATA[
                    console.log(3 + 4 * 2); //=> 11
                ]]>
            </code-block>
        </chapter>
    </chapter>

    <chapter id="variablen" title="Variablen, Konstanten und Typisierung">
        <tip>
            Grundlegendes zo Variablen: <a href="swe-pk-grundlagen-variablen.topic"/>
        </tip>

        <chapter id="variablen-v" title="Variablen">
            <img alt="Variablendeklaration in JavaScript" src="js-sprachkern-variable-declaration.jpg"/>

            <p>
                Mit dem Schlüsselwort <code>let</code> erstellt man eine Variable. Je nachdem welcher Wert ihr
                zugewiesen
                wird, wird der Datentyp bestimmt. Noch wichtig zu wissen ist, dass jeder Wert - egal ob String oder
                Zahl - der direkt im Code steht, als Literal bezeichnet wird. Sie haben immer einen festen Wert.
                Literale haben auch einen <b>Datentyp</b> (= <code>string</code> oder <code>number</code>) welcher
                mit dem Operator <code>typeof</code> ermittelt werden kann. Bei numerischen Werten mit Kommas wird die
                amerikanische Schreibweise verwendet (Punkt statt Komma).
            </p>

            <p>
                Syntax (<b>Lass</b> <i>(früher var)</i> die Variable username Rizz sein)
            </p>

            <code-block lang="javascript">
                <![CDATA[
                    let username = "Rizz";
                    console.log(typeof variable); //=> string
                ]]>
            </code-block>

            <p>
                Die Wertzuweisung einer Variable erfolgt von rechts nach links, das bedeutet der Wert rechts vom
                Zuweisungsoperator wird der Variable links zugewiesen und nicht umgekehrt. In eine Variable lässt sich
                ein Wert einspeichern, aber in einen Wert keine Variable.
            </p>

            <p>
                Der Datentyp <code>string</code>, englischer Begriff für Zeichenkette, kann mit zwei Möglichkeiten
                definiert werden (einfache und doppelte Anführungszeichen):
            </p>

            <code-block lang="javascript">
                <![CDATA[
                    let neueVariable = "be"; //=> be
                    let neueVariable = 'be'; //=> be
                ]]>
            </code-block>

            <p>
                Die Variable des Datentyps <code>String</code> ist ein Objekt. Von dieser Variablen kann die Eigenschaft
                <code>length</code> Abgefragt (Länge) werden. Diese Eigenschaft gibt die Anzahl der Zeichen der
                Zeichenkette zurück. Beispiel: <code>console.log(&quot;Hallo Welt!&quot;.length); //=&gt; 11</code>
            </p>

            <chapter id="variablen-namensgebung" title="Namensgebung für Variablen">
                <list type="bullet">
                    <li>
                        Aussagekräftige Bezeichner (<code>alter</code> statt <code>x</code>, <code>vorname</code> statt
                        <code>z</code>, <code>preis</code> statt <code>p</code>)
                    </li>
                    <li>
                        Keine Sonderzeichen
                    </li>
                    <li>
                        <a href="swe-pk-richtlinien.topic">lowerCamelCasing</a> (Neues Wort beginnt mit einem
                        Großbuchstaben)
                    </li>
                </list>
            </chapter>

            <chapter id="variablen-let-vs-var" title="let vs. var">
                <table style="header-column">
                    <tr>
                        <td>
                            Deklatation
                        </td>
                        <td>
                            <p>
                                Die Deklaration einer Variable mit <code>let</code> hindert uns daran, eine Variable ein
                                zweites Mal mit demselben Namen zu deklarieren. Hierbei wird ein
                                <code>SyntaxError</code> geworfen. Bei <code>var</code> ist dies hingegen ohne Fehler
                                möglich.
                            </p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            Scope
                        </td>
                        <td>
                            <p>
                                Variablen, welche mit <code>let</code> deklariert wurden, sind "block-scoped", das
                                bedeutet, ihr Sichtbarkeitsbereich liegt innerhalb eines Blocks. Variablen, welche mit
                                <code>var</code> deklariert wurden, sind "function-scoped", das bedeutet ihr
                                Sichtbarkeitsbereich liegt innerhalb einer Funktion. Wird eine variable mit
                                <code>var</code> innerhalb eines Blocks (kein Funktionsblock) deklariert, so ist diese
                                auch außerhalb davon, also innerhalb der ganzen Funktion bzw. global, sichtbar.
                            </p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            Hoisting
                        </td>
                        <td>
                            <p>
                                Hoisting wird die Technik genannt, welche alle Variablendeklarationen zum Anfang
                                verschiebt. Bei <code>let</code> werden die Deklarationen zum Anfang des Blocks
                                verschoben, und bei <code>var</code> zum Anfang der Funktion.
                            </p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            Shadowing
                        </td>
                        <td>
                            <p>
                                Wenn wir einer globalen und einer lokalen Variable denselben Namen geben, dann wird
                                dies als Variable Shadowing bezeichnet. Denn die globale Variable wird nicht von der
                                lokalen überschrieben, sondern die globale wird unsichtbar und eine neue Variable mit
                                demselben Bezeichner wird lokal erstellt. Für var bedeutet lokal <code>=</code>
                                innerhalb einer Funktion; für <code>let</code> bedeutet lokal <code>=</code> innerhalb
                                eines Blocks.
                            </p>
                        </td>
                    </tr>
                </table>
            </chapter>
        </chapter>

        <chapter id="variablen-konstanten" title="Konstanten">
            <tip>
                Grundlegendes zu Konstanten: <a href="swe-pk-grundlagen-variablen.topic#konstanten"/>
            </tip>

            <p>
                Konstanten werden in JavaScript immer mit dem Schlüsselwort <code>const</code> (für eng. constant)
                deklariert. Das Beste ist, wenn man immer versucht mit Konstanten auszukommen, anstatt eine Variable zu
                verwenden. Somit vermeidet man, dass sich der wert (natürlich durch eigenes Verschulden) ungewollt
                ändert. Zudem kann für <code>const</code> die JS Engine den Code optimieren, was Auswirkungen auf die
                Performance haben kann.
            </p>

            <code-block lang="javascript">
                <![CDATA[
                    const TAX_RATE = 1.22; //Multiplikator für Mehrwertsteuer
                ]]>
            </code-block>

            <p>
                Versucht man, eine Konstante zu überschreiben, ignorieren die meisten Laufzeitumgebungen die
                entsprechende Anweisung stillschweigend (also ohne einen Fehler zu produzieren).
            </p>

            <chapter id="variablen-konstanten-namensgebung" title="Namensgebung für Konstante">
                <list type="bullet">
                    <li>
                        Aussagekräftige Bezeichner
                    </li>
                    <li>
                        Keine Sonderzeichen
                    </li>
                    <li>
                        <a href="swe-pk-richtlinien.topic">SCREAMING_SNAKE</a> (Nur Großbuchstaben; Worttrennung durch
                        Unterstrich)
                    </li>
                </list>
            </chapter>
        </chapter>

        <chapter id="variablen-typisierung" title="Typisierung">
            <chapter id="variablen-typisierung-impliziert" title="Implizierte Typkonvertierung">
                <p>
                    Was ergibt <code>&quot;5&quot; * &quot;4&quot;</code>? Die Antwort ist <code>"20"</code> mit dem
                    Datentyp <code>number</code>. Das liegt daran, dass der Multiplikator als Operanden zwei Zahlen
                    erwartet. Ist ein Operand vom Datentyp <code>string</code> so wird von JS eine sogenannte
                    implizierte Typkonvertierung durchgeführt. Der Fachausdruck dafür lautet <b>coercion</b>. Auch die
                    Operanden <code>/</code> und <code>–</code> verwenden coercion.
                </p>
            </chapter>

            <chapter id="variablen-typisierung-explizit" title="Explizite Typkonvertierung">
                <code-block lang="javascript">
                    <![CDATA[
                        let number1 = prompt(„Gib eine Nummer ein!“);   //Eingabe 1
                        let number2 = prompt(„Gib eine Nummer ein!“);   //Eingabe 2
                        console.log(„Summe:“ + (number1 + number2));    //=> Summe: 12
                    ]]>
                </code-block>

                <p>
                    Das Problem hier ist, dass die Funktion <code>prompt()</code> immer einen Wert des Datentyps
                    <code>string</code> zurückgibt. Um das zu lösen, muss man den Datentyp mit der Funktion
                    <code>Number()</code> konvertieren <code>=</code> explizite Typkonvertierung. Handelt es sich
                    jedoch bei dem übergebenen an die Funktion <code>Number()</code> um keine Zahl oder eine Mischung
                    aus Zahl und Text, so lautet der Rückgabewert <code>NaN</code> (Not a Number).
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        typeof(NaN); //=> number
                    ]]>
                </code-block>
            </chapter>
        </chapter>
    </chapter>

    <chapter id="datentypen" title="Datentypen">
        <p>
            Insgesamt wird in JavaScript zwischen sechs verschiedenen Datentypen unterschieden: Zum einen gibt es die
            drei sogenannten primitiven Datentypen für die Repräsentation von Zahlen, Zeichenketten und booleschen
            Wahrheitswerten, zum anderen die speziellen Datentypen <code>null</code> und <code>undefined</code> (auch
            eine Form von primitiven Datentypen) sowie den Typ <code>object</code>, welcher als Basis für das Erstellen
            einiger (komplexer) Objekte dient. Arrays gelten in JavaScript streng genommen nicht als eigener Datentyp.
        </p>

        <p>
            In JavaScript wird bei der Variablendeklaration der Datentyp nicht explizit festgelegt, deshalb spricht man
            hierbei auch von dem sogenannten <a href="swe-pk-grundlagen-variablen.topic#typisierung">Weak Typing</a>.
        </p>

        <table style="both">
            <tr>
                <td>
                    Datentyp
                </td>
                <td>
                    Beschreibung
                </td>
            </tr>
            <tr>
                <td>
                    Zahlen
                </td>
                <td>
                    <list type="bullet">
                        <li>
                            Ein numerischer Wert repräsentiert eine Zahl: Der Wert <code>4711</code> steht für
                            Viertausendsiebenhundertelf
                        </li>
                        <li>
                            Kommas werden mit einem Punkt notiert: <code>0.5</code>
                        </li>
                        <li>
                            Für negative Werte wird der Zahl ein Minuszeichen vorangestellt: <code>-5</code> oder
                            <code>-0.9</code>
                        </li>
                        <li>
                            Für Binärzahlen wird das Präfix <code>0b</code> verwendet: <code>0b01010101</code> steht für
                            den Dezimalwert <code>85</code>
                        </li>
                        <li>
                            Für Oktalzahlen wird das Präfix <code>0</code> oder <code>0o</code> verwendet:
                            <code>050</code> steht für den Dezimalwert <code>40</code>
                        </li>
                        <li>
                            Für Hexadezimalzahlen wird das Präfix <code>0x</code> verwendet: <code>0xF</code> steht für
                            den Dezimalwert <code>15</code>
                        </li>
                        <li>
                            Der Wertebereich liegt zwischen <code>Number.MIN_VALUE</code> (= <code>5e-324</code>) und
                            <code>Number.MAX_VALUE</code> (= <code>1.7976931348623157e+308</code>)
                        </li>
                        <li>
                            Werte außerhalb des Wertebereiches werden mit <code>-Infinity</code> und
                            <code>Infinity</code> dargestellt.
                        </li>
                        <li>
                            Berechnungen, die keinen gültigen Zahlenwert ergeben liefern den Wert <code>NaN</code> (eng.
                            <i>not a number</i>)
                        </li>
                        <li>
                            Exponentialzahlen können mit <code>e</code> dargestellt werden: <code>9e3 = 9000</code>,
                            <code>123e-5 = 0,00123</code>.
                        </li>
                    </list>
                </td>
            </tr>
            <tr>
                <td>
                    BigInt
                </td>
                <td>
                    <list type="bullet">
                        <li>
                            Größere Integer werden als BigInt erstellt. Die Literal Schreibweise, ist am Ende ein
                            <code>n</code> hinzuzufügen: <code>100n</code>.
                        </li>
                        <li>
                            typeof <code>10n</code> ergibt <code>'bigint'</code>
                        </li>
                        <li>
                            Zwischen <code>BigInt</code> und <code>Number</code> werten können keine Berechnungen
                            stattfinden: <code>1000n + 20</code> schmeißt einen <code>TypeError</code>
                        </li>
                        <li>
                            <code>BigInt</code> hat keinen eigenen äquivalent für Infinity: <code>1000n / 0n</code>
                            schmeißt einen <code>RangeError</code>
                        </li>
                    </list>
                </td>
            </tr>
            <tr>
                <td>
                    Zeichenketten
                </td>
                <td>
                    <list type="bullet">
                        <li>
                            Zeichenketten bzw. Strings repräsentieren eine Folge von Zeichen, also beispielsweise
                            Buchstaben, Ziffern, Sonderzeichen und Steuerzeichen.
                        </li>
                        <li>
                            Anfang und Ende einer Zeichenkette wird mittels Anführungszeichen definiert. Dabei können
                            einfache als auch doppelte Anführungszeichen verwendet werden. Eine Mischform ist nicht
                            erlaubt.
                        </li>
                        <li>
                            Mit dem Backslash-Zeichen (eng. <i>escape character</i>) kann maskiert (eng.
                            <i>escaping</i>) werden, sodass Anführungszeichen oder Steuerzeichen auch innerhalb eines
                            Strings verwendet werden können.
                        </li>
                    </list>
                </td>
            </tr>
            <tr>
                <td>
                    Boolesche Wahrheitswerte
                </td>
                <td>
                    <list type="bullet">
                        <li>
                            Können nur die Werte <code>true</code> (für wahr) und <code>false</code> (für falsch)
                            annehmen.
                        </li>
                        <li>
                            Spielen eine zentrale Rolle, wenn es darum geht, innerhalb eines Programms Verzweigungen zu
                            definieren.
                        </li>
                        <li>
                            folgende Werte werden von JS als <code>false</code> interpretiert: <code>false</code>,
                            <code>-0</code>, <code>0</code>, <code>0n</code>, <code>-0n</code>, <code>NaN</code> (=
                            <i>Not a Number</i>), <code>undefined</code>, <code>""</code> (= <i>empty string</i>),
                            <code>null</code>. Alle anderen werte gelten als <code>true</code>.
                        </li>
                    </list>
                </td>
            </tr>
            <tr>
                <td>
                    Objekte
                </td>
                <td>
                    <list type="bullet">
                        <li>
                            Zusammengehörige Variablen (= Eigenschaften bzw. Objekteigenschaften oder Attribute) und
                            Funktionen (= Methoden bzw. Objektmethoden) werden in Objekten zusammengefasst.
                        </li>
                        <li>
                            Bei der Objekt-Literal-Schreibweise werden Objekte über geschweifte Klammern definiert und
                            innerhalb derer die Objekteigenschaften und Objektmethoden kommasepariert aufgelistet werden
                            können.
                        </li>
                        <li>
                            Objekte sind in JavaScript eigentlich nichts anderes als Schlüssel-Wert-Paare. Schlüssel und
                            Wert werden jeweils durch einen Doppelpunkt getrennt.
                        </li>
                        <li>
                            Über dem Schlüsselwort <code>this</code> wird das aktuelle Objekt angesprochen.
                        </li>
                        <li>
                            Es gibt noch die Konstruktorfunktion, die <code>Object.create()</code>-Methode und die
                            Instanziierung einer ES2015-Klasse um in JavaScript Objekte zu erzeugen.
                        </li>
                    </list>

                    <p>
                        <b>Arrays</b>
                    </p>

                    <list type="bullet">
                        <li>
                            Ein Array gehört strenggenommen zum Datentyp Objekt und sind nichts anderes als Listen. Sie
                            können nicht nur einen, sondern mehrere Werte enthalten.
                        </li>
                        <li>
                            Die gängigste, weil einfachste Möglichkeit, in JavaScript ein Array zu erzeugen ist die
                            Array-Literal-Schreibweise. Dabei werden eckige Klammern (<code>[]</code>) verwendet, um den
                            Anfang und das Ende des Arrays zu definieren. Die einzelnen Einträge (bzw. Werte bzw.
                            Elemente), die in dem Array enthalten sein sollen, schreibt man kommasepariert zwischen den
                            Klammern.
                        </li>
                        <li>
                            Arrays können – im Unterschied zu anderen Programmiersprachen wie beispielsweise Java – auch
                            Einträge unterschiedlichen Typs enthalten. Mit anderen Worten: Ein einzelnes Array kann
                            beispielsweise Zahlen sowie Zeichenketten oder boolesche Werte, Objekte oder sogar andere
                            Arrays enthalten.
                        </li>
                    </list>
                </td>
            </tr>
            <tr>
                <td>
                    <code>undefined</code>
                </td>
                <td>
                    <list type="bullet">
                        <li>
                            Wird eine Variable deklariert, aber kein Wert zugewiesen, so hat sie den Wert
                            <code>undefined</code>.
                        </li>
                        <li>
                            Der Wert <code>undefined</code> ist nicht dazu gedacht, dass man ihn manuell einer Variable
                            zuweist.
                        </li>
                        <li>
                            Der Wert <code>undefined</code> drückt aus, dass eine Variable noch nicht initialisiert
                            wurde.
                        </li>
                    </list>
                </td>
            </tr>
            <tr>
                <td>
                    <code>null</code>
                </td>
                <td>
                    <list type="bullet">
                        <li>
                            Der Datentyp <code>null</code> definiert ein leeres Objekt.
                        </li>
                        <li>
                            Der Wert <code>null</code> kann auch einer Variable zugewiesen werden.
                        </li>
                        <li>
                            Der Wert <code>null</code> repräsentiert einen leeren Objektzeiger.
                        </li>
                    </list>
                </td>
            </tr>
            <tr>
                <td>
                    Symbol
                </td>
                <td>
                    <list type="bullet">
                        <li>
                            Symbol ist ein neuer primitiver Datentyp in JavaScript, der mit ES2015 eingeführt wurde.
                        </li>
                    </list>
                </td>
            </tr>
        </table>

        <chapter id="datentypen-konstruktor-methoden" title="Konstruktor-Methoden">
            <code-block lang="javascript">
                <![CDATA[
                    const str = new String();     // =>
                    const num = new Number();     // => 0
                    const bool = new Boolean();   // => false
                    const bigInt = new BigInt();  // => TypeError
                ]]>
            </code-block>

            <p>
                Da hierbei Objekte des jeweiligen Typs in die Variablen gespeichert werden, sollte man lieber immer
                literale anstatt die Konstruktor-Methoden verwenden.
            </p>
        </chapter>

        <chapter id="datentypen-autoboxing" title="Autoboxing">
            <p>
                Wird nach einem Literal eines primitiven Datentyps ein punkt verwendet oder nach einer Variable, welche
                einen primitiven Datentyp enthält, dann konvertiert der JS Interpreter den Wert in das Objekt des
                jeweiligen Datentyps und wir können auf dessen Methoden und Eigenschaften zugreifen. Diese Technik wird
                Autoboxing genannt.
            </p>
        </chapter>
    </chapter>

    <chapter id="operatoren" title="Operatoren">
        <tip>
            Grundlegendes zu Operatoren: <a href="swe-pk-grundlagen-ausdruecke.topic"/>
        </tip>

        <chapter id="operatoren-prio" title="Prioritätsliste">
            <table style="both">
                <tr>
                    <td>
                        Priorität
                    </td>
                    <td>
                        Gruppe
                    </td>
                    <td>
                        Assoziativität
                    </td>
                    <td>
                        Symbol
                    </td>
                </tr>
                <tr>
                    <td>
                        14
                    </td>
                    <td>
                        Gruppierung
                    </td>
                    <td></td>
                    <td>
                        <code>(</code> &#8230; <code>)</code>
                    </td>
                </tr>
                <tr>
                    <td>
                        13
                    </td>
                    <td>
                        Feldzugriff
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>.</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        12
                    </td>
                    <td>
                        Funktionsaufruf
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>(</code> &#8230; <code>)</code>
                    </td>
                </tr>
                <tr>
                    <td>
                        11
                    </td>
                    <td>
                        Postifx inkrementieren
                    </td>
                    <td></td>
                    <td>
                        &#8230; <code>++</code>
                    </td>
                </tr>
                <tr>
                    <td>
                        11
                    </td>
                    <td>
                        Postfix dekrementieren
                    </td>
                    <td></td>
                    <td>
                        &#8230; <code>--</code>
                    </td>
                </tr>
                <tr>
                    <td>
                        10
                    </td>
                    <td>
                        Logisches NOT
                    </td>
                    <td>
                        &#8592;
                    </td>
                    <td>
                        <code>!</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        10
                    </td>
                    <td>
                        Unäres Plus
                    </td>
                    <td>
                        &#8592;
                    </td>
                    <td>
                        <code>+</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        10
                    </td>
                    <td>
                        Unäre negation
                    </td>
                    <td>
                        &#8592;
                    </td>
                    <td>
                        <code>-</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        10
                    </td>
                    <td>
                        Prefix inkrementierung
                    </td>
                    <td>
                        &#8592;
                    </td>
                    <td>
                        <code>++</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        10
                    </td>
                    <td>
                        Prefix dekrementierung
                    </td>
                    <td>
                        &#8592;
                    </td>
                    <td>
                        <code>--</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        10
                    </td>
                    <td>
                        typeof
                    </td>
                    <td>
                        &#8592;
                    </td>
                    <td>
                        <code>typeof</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        10
                    </td>
                    <td>
                        delete
                    </td>
                    <td>
                        &#8592;
                    </td>
                    <td>
                        <code>delete</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        09
                    </td>
                    <td>
                        Exponentialoperator
                    </td>
                    <td>
                        &#8592;
                    </td>
                    <td>
                        &#8230; <code>**</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        08
                    </td>
                    <td>
                        Multiplikation
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>*</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        08
                    </td>
                    <td>
                        Division
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>/</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        08
                    </td>
                    <td>
                        Modulo
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>%</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        07
                    </td>
                    <td>
                        Addition
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>+</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        07
                    </td>
                    <td>
                        Subtraktion
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>-</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        06
                    </td>
                    <td>
                        Kleiner als
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>&lt;</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        06
                    </td>
                    <td>
                        Kleiner gleich als
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>&lt;=</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        06
                    </td>
                    <td>
                        Größer als
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>&gt;</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        06
                    </td>
                    <td>
                        Größer gleich als
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>&gt;=</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        06
                    </td>
                    <td>
                        instanceof
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>instanceof</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        05
                    </td>
                    <td>
                        Gleichheit
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>==</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        05
                    </td>
                    <td>
                        Ungleichheit
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>!=</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        05
                    </td>
                    <td>
                        Strikte Gleichheit
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>===</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        05
                    </td>
                    <td>
                        Strikte Ungleichheit
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>!==</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        04
                    </td>
                    <td>
                        Logisches UND
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>&amp;&amp;</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        03
                    </td>
                    <td>
                        Logisches ODER
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>||</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        02
                    </td>
                    <td>
                        Ternärer Auswahloperator
                    </td>
                    <td>
                        &#8592;
                    </td>
                    <td>
                        &#8230; <code>?</code> &#8230; <code>:</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        01
                    </td>
                    <td>
                        Zuweisungsoperaoren
                    </td>
                    <td>
                        &#8592;
                    </td>
                    <td>
                        <p>&#8230; <code>=</code> &#8230;</p>
                        <p>&#8230; <code>+=</code> &#8230;</p>
                        <p>&#8230; <code>*=</code> &#8230;</p>
                        <p>&#8230; und andere Zuweisungsoperatoren</p>
                    </td>
                </tr>
            </table>

            <p>
                Wie bei in der Mathematik gilt Punkt vor Strich. Oben in der Tabelle ist die Rangliste der Priorität der
                einzelnen Operatoren aufgelistet. Um den Code übersichtlicher zu gestalten, sollte man auch bei
                Einhalten der Regeln Runde Klammern zu setzen, solange es noch übersichtlich aussieht.
            </p>
        </chapter>

        <chapter id="operatoren-unaer" title="Unäre Operatoren + und -">
            <p>
                Diese Operatoren werden für die Nummer Konvertierung verwendet.
            </p>

            <code-block lang="javascript">
                <![CDATA[
                    let str = "123";     // => "123"   (string)
                    let n1 = +str;       // => 123     (number)
                    let n2 = -str;       // => -123    (number)
                    let n3 = -n2;        // => 123     (number)
                    let n4 = +"abc";     // => NaN     (number)
                ]]>
            </code-block>
        </chapter>

        <chapter id="operatoren-logische-zuweisung" title="Logische Zuweisungsoperatoren &amp;&amp;= und ||=">
            <code-block lang="javascript">
                <![CDATA[
                    a &&= false;     // => wie a = (a && false)
                    b ||= true;      // => wie b = (b || true)
                ]]>
            </code-block>
        </chapter>

        <chapter id="operatoren-logisch" title="Logische Operatoren und nicht boolsche Werte">
            <code-block lang="javascript">
                <![CDATA[
                    console.log(true && 1991);       // => 1991
                    console.log(false && 1991);      // => false
                    console.log(2 && 5);             // => 5
                    console.log(0 && 5);             // => 0
                    console.log("Alice" && "Bob");   // => "Bob"
                    console.log("" && "Bob");        // => ""
                ]]>
            </code-block>

            <p>
                Beim Und-Operator müssen alle Operanden <code>true</code> sein. Wenn nicht, wird der erste Operand
                ausgegeben der <code>false</code> ist, sonst der letzte der true ist.
            </p>

            <code-block lang="javascript">
                <![CDATA[
                    console.log(true || 1991);       // => true
                    console.log(false || 1991);      // => 1991
                    console.log(2 || 5);             // => 2
                    console.log(0 || 5);             // => 5
                    console.log("Alice" || "Bob");   // => "Alice"
                    console.log("" || "Bob");        // => "Bob"
                ]]>
            </code-block>

            <p>
                Beim Oder-Operator muss nur ein Operand <code>true</code> sein. Hier wird der erste Operand ausgegeben,
                der <code>true</code> ist, sonst der letzte der <code>false</code> ist.
            </p>
        </chapter>

        <chapter id="operatoren-typof" title="Typbestimmung – Der typeof- und der instanceof-Operator">
            <p>
                Bei dem <code>typeof</code>-Operator handelt es sich um einen unären Operator, welcher als Operanden
                einen Wert bzw. eine Variable erwartet, für die der Typ ermittelt werden soll. Der Operator liefert
                dabei als Rückgabewert eine Zeichenkette.
            </p>

            <table style="header-row">
                <tr>
                    <td>
                        Rückgabewert des <code>typeof</code>-Operators
                    </td>
                    <td>
                        Wird zurückgegeben für &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>boolean</code>
                    </td>
                    <td>
                        boolesche Werte
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>number</code>
                    </td>
                    <td>
                        Zahlenwerte
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>string</code>
                    </td>
                    <td>
                        Zeichenketten
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>symbol</code>
                    </td>
                    <td>
                        Symbole, ein in ES6 neu eingeführter Datentyp
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>function</code>
                    </td>
                    <td>
                        Funktionen (die in JavaScript übrigens selbst Objekte sind)
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>object</code>
                    </td>
                    <td>
                        alle (anderen) Arten von Objekten sowie den Wert <code>null</code>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>undefined</code>
                    </td>
                    <td>
                        nicht definierte Variablen
                    </td>
                </tr>
            </table>

            <p>
                Der <code>typeof</code>-Operator kann verwendet werden, um:
            </p>
            <list>
                <li>
                    primitive Datentypen von Referenztypen zu unterscheiden
                </li>
                <li>
                    die einzelnen primitiven Datentypen untereinander zu unterscheiden
                </li>
                <li>
                    herauszufinden, ob es sich bei einem Wert um eine Funktion handelt
                </li>
            </list>

            <p>
                Neben dem <code>typeof</code>-Operator gibt es noch einen weiteren Operator, der etwas mit der
                Typbestimmung von Variablen zu tun hat, und zwar den Operator <code>instanceof</code>. Vereinfacht
                gesagt, bestimmt dieser Operator, ob eine Variable von einem bestimmten Referenztyp ist. Als
                Rückgabewert liefert der Operator dabei einen booleschen Wert. <code>Object</code> ist der Typ, von dem
                alle anderen Referenztypen ableiten. Der <code>instanceof</code>-Operator liefert daher für alle
                Variablen beliebigen Referenztyps den Wert <code>true</code> zurück. Im Gegensatz zum
                <code>typeof</code>-Operator funktioniert der <code>instanceof</code>-Operator nur für Werte, die einen
                Referenztyp enthalten. Für Werte primitiven Datentyps dagegen liefert der Operator immer
                <code>false</code> zurück. Mehr zum <code>instanceof</code>-Operator hier:
                <a href="js-oop.topic#grundlagen-instanceof"/>
            </p>
        </chapter>

        <chapter id="operatoren-nach-kategorie" title="Operatoren nach Kategorie">
            <table style="both">
                <tr>
                    <td>
                        Kategorie
                    </td>
                    <td>
                        Beschreiubung
                    </td>
                </tr>
                <tr>
                    <td>
                        Zuweisungsoperatoren
                    </td>
                    <td>
                        <p>
                            Der Operator <code>+=</code> gehört zur Gruppe der zusammengesetzten Zuweisungsoperatoren.
                            Der Trick des Zusammensetzens funktioniert auch mit allen übrigen arithmetischen Operatoren
                            wie <code>+</code>, <code>-</code>, <code>/</code>und <code>%</code>. Auf der linken Seite
                            einer Zuweisung muss immer einer Variablen stehen. Preis um <code>10%</code> erhöhen:
                            <code>price *= 1.10; //=&gt; price = price * 1.10</code>
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        Relationale Operatoren
                    </td>
                    <td>
                        <p>
                            Relationale Operatoren sind <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>,
                            <code>&gt;=</code>, <code>==</code>, <code>!=</code>, <code>===</code>, <code>!===</code>
                            und ermöglichen den Vergleich zweier Werte. Das Ergebnis eines solchen Vergleiches ist
                            entweder <code>true</code> oder <code>false</code>. Die Wahrheitswerte <code>true</code> und
                            <code>false</code> haben einen eigenen Datentyp: boolean. Somit ergibt
                            <code>typeof(3 &lt; 7)</code> -&gt; <code>boolean</code>. Die Operatoren <code>==</code>,
                            <code>!=</code> und <code>===</code>, <code>!==</code> unterscheiden sich darin, dass
                            <code>===</code> und <code>!==</code> zusätzlich auch den Datentyp Vergleichen. Somit ist
                            <code>(&quot;5&quot; === 5)</code> gleich <code>false</code> und
                            <code>(&quot;5&quot; == 5)</code> gleich <code>true</code>.
                        </p>

                        <p>
                            Mit der Funktion <code>isNaN()</code> kann abgefragt werden, ob es sich beim übergebenen
                            Argument um einen Wert des Datentyps number handelt oder nicht. Der Rückgabewert ist ein
                            <code>boolean</code>.
                        </p>

                        <code-block lang="javascript">
                            <![CDATA[
                                isNaN(3);       //=> false
                                isNaN(NaN);     //=> true
                                isNaN("3");     //=> false Es enthält explizite Typkonvertierung
                                isNaN("drei");  //=> true
                            ]]>
                        </code-block>

                        <p>
                            Rationale Operatoren wie kleiner, kleiner-gleich oder größer, größer-gleich können auch
                            an Strings angewendet werden. Hierbei führt JS einen <b>lexikographischen</b> (eng.
                            <b>lexicographic</b>) Vergleich durch. Somit ergibt der Vergleich
                            <code>&quot;Hallo&quot; > &quot;Hello&quot;</code> den Wert <code>false</code> zurück, da
                            der Buchstabe <code>a</code> vor dem Buchstaben <code>e</code> im Alphabet vorkommt.
                        </p>

                        <tip>
                            In JavaScript sollte man stets für den Vergleich zweier Variablen stets die strikten
                            Vergleichsoperatoren verwenden. Damit wird vermieden, dass die automatische Typkonvertierung
                            in Kraft tritt, was oft auch zu schwer zu finden Fehlern im Programm führen kann.
                        </tip>
                    </td>
                </tr>
                <tr>
                    <td>
                        Logische Operatoren
                    </td>
                    <td>
                        <p>
                            In JavaScript wird <code>&amp;&amp;</code> als Und-Operator und <code>||</code> als
                            Oder-Operator verwendet. Für logische Operatoren gibt es in JavaScript folgende
                            Besonderheiten:
                        </p>

                        <!-- TODO: missing content!! -->
                    </td>
                </tr>
                <tr>
                    <td>
                        Bitweise Operationen
                    </td>
                    <td>
                        <list type="bullet">
                            <li>
                                <code>&amp;</code> bitweises UND
                            </li>
                            <li>
                                <code>|</code> bitweises ODER
                            </li>
                            <li>
                                <code>^</code> bitweises exklusives ODER
                            </li>
                            <li>
                                <code>~</code> bitweises NICHT, wobei das Ergebnis für eine Zahl <code>x</code> dann
                                <code>-(x+1)</code> lautet, also für die Zahl <code>65</code> bitweise das Ergebnis
                                <code>-66</code>.
                            </li>
                            <li>
                                <code>&lt;&lt;</code> bitweise Linksverschiebung
                            </li>
                            <li>
                                <code>&gt;&gt;</code> bitweise Rechtsverschiebung
                            </li>
                            <li>
                                <code>&gt;&gt;&gt;</code> bitweise vorzeichenignorierende Rechtsverschiebung
                            </li>
                        </list>
                    </td>
                </tr>
                <tr>
                    <td>
                        Konditionaler Operator
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                <Bedingung> ? <Wert1> : <Wert2>
                            ]]>
                        </code-block>

                        <p>
                            Der konditionale Operator ist ein tenärer Operator, der abhängig von einer Bedingung (erster
                            Operand) einen von zwei Werten zurückgibt (welche durch den zweiten und dritten Operanden
                            definiert werden).
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        Löschung von Objekteigenschaften oder Elementen innerhalb eines Arrays
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                delete
                            ]]>
                        </code-block>

                        <p>
                            Erlaubt es, Elemente aus Arrays zu löschen sowie Objekteigenschaften aus Objekten.
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        Existenz einer Eigenschaft in einem Objekt
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                <Eigenschaft> in <Objekt>
                            ]]>
                        </code-block>

                        <p>
                            Überprüft, ob ein Objekt über eine Eigenschaft verfügt.
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        Typüberprüfung
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                <Objekt> instanceof <Typ>
                            ]]>
                        </code-block>

                        <p>
                            Hierbei handelt es sich um einen binären Operator, der überprüft, ob ein Objekt von einem
                            Typ ist.
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        Typbestimmung
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                typeof <Operand>
                            ]]>
                        </code-block>

                        <p>
                            Ermittelt den Datentyp des Operanden. Der Operand kann dabei ein Objekt, ein String, eine
                            Variable oder ein Schlüsselwort wie <code>true</code> oder <code>false</code> sein. Optional
                            kann der Operand in Klammern angegeben werden.
                        </p>
                    </td>
                </tr>
            </table>
        </chapter>
    </chapter>

    <chapter id="kontrollstrukturen" title="Krontrollstrukturen">

        <chapter id="kontrollstrukturen-auswahlstrukturen" title="Auswahlstrukturen">

            <chapter id="kontrollstrukturen-auswahlstrukturen-if" title="if-elseif-else-Statement">

                <chapter id="kontrollstrukturen-auswahlstrukturen-if-syntax" title="Syntax">

                </chapter>

                <chapter id="kontrollstrukturen-auswahlstrukturen-if-beispiel" title="Beispiel">

                </chapter>

                <chapter id="kontrollstrukturen-auswahlstrukturen-if-kurzschreibweise" title="Kurzschreibweise">

                </chapter>
            </chapter>

            <chapter id="kontrollstrukturen-auswahlstrukturen-tertiaerer-operator" title="Der tertiäre Operator">

            </chapter>

            <chapter id="kontrollstrukturen-auswahlstrukturen-switch" title="Mehrfachverzweigungen: switch-Statement">

            </chapter>
        </chapter>

        <chapter id="kontrollstrukturen-schleifen" title="Schleifen">

            <chapter id="kontrollstrukturen-schleifen-for" title="Zählschleife – die for-Schleife">

            </chapter>

            <chapter id="kontrollstrukturen-schleifen-for-of-in" title="Die for-of-Schleife und for-in-Schleife">

            </chapter>

            <chapter id="kontrollstrukturen-schleifen-while" title="Kopfgesteuerte Schleife – die while-Schleife">

            </chapter>

            <chapter id="kontrollstrukturen-schleifen-do-while" title="Fußgesteuerte Schleife – die do-while-Schleife">

            </chapter>

            <chapter id="kontrollstrukturen-schleifen-abbrechen" title="Schleifen vorzeitig abbrechen">

                <chapter id="kontrollstrukturen-schleifen-break" title="Die break-Anweisung">

                </chapter>

                <chapter id="kontrollstrukturen-schleifen-continue" title="Die continue-Anweisung">

                </chapter>
            </chapter>

            <chapter id="kontrollstrukturen-schleifen-goto" title="Sprungmarken">

            </chapter>
        </chapter>
    </chapter>

    <chapter id="funktionen" title="Funktionen">

        <chapter id="funktionen-basis" title="Basis Funktionsdeklaration und Funktionsausdruck">

        </chapter>

        <chapter id="funktionen-parameter" title="Parameter">

            <chapter id="funktionen-parameter-weniger-argumente-als-parameter"
                     title="Funktionen mit weniger Argumenten als angegebenen Parametern aufrufen">

            </chapter>

            <chapter id="funktionen-parameter-mehr-arugmente-als-parameter"
                     title="Funktionen mit mehr Argumenten als angegebenen Parametern aufrufen">

            </chapter>

            <chapter id="funktionen-parameter-variable-anzahl-an-argumenten"
                     title="Funktionen mit einer variablen Anzahl an Argumenten – variadische Funktionen">

            </chapter>

            <chapter id="funktionen-parameter-spread-operator"
                     title="Der Spread-Operator – Elemente aus einem Array als Argumente verwenden">

            </chapter>

            <chapter id="funktionen-parameter-standardwerte" title="Standardwerte für Parameter">

            </chapter>

            <chapter id="funktionen-parameter-funktionen" title="Funktion als Parameter">

            </chapter>
        </chapter>

        <chapter id="funktionen-return" title="Rückgabewerte">

        </chapter>

        <chapter id="funktionen-arrow-functions" title="Arrow Functions bzw. Fat Arrow Functions">

            <chapter id="funktionen-arrow-functions-return" title="Objekt als Rückgabewert">

            </chapter>

            <chapter id="funktionen-arrow-functions-eigenschaften" title="Weitere Eigenschaften von Arrow Functions">

            </chapter>
        </chapter>

        <chapter id="funktionen-ausfuehrungskontext" title="Ausführungskontexte">

            <chapter id="funktionen-gueltigkeitsbereich" title="Gültigkeitsbereiche">

            </chapter>

            <chapter id="funktionen-kontextobjekt" title="Kontextobjekt">

            </chapter>
        </chapter>

        <chapter id="funktionen-funktionsaufruf-durch-nutzerinteraktion"
                 title="Funktionsaufruf durch Nutzerinteraktion">

        </chapter>
    </chapter>

    <chapter id="vordefiniert" title="Vordefinierte Funktionen und Objekte">

        <chapter id="vordefiniert-console" title="Konsolenausgabe">

        </chapter>

        <chapter id="vordefiniert-warnungsfenster" title="Warnungsfenster">

        </chapter>

        <chapter id="vordefiniert-eingabefenster" title="Eingabefenster">

        </chapter>

        <chapter id="vordefiniert-use-strict" title="Der &quot;use strict&quot; Modus">

        </chapter>

        <chapter id="vordefiniert-konstante" title="Konstante">

        </chapter>

        <chapter id="vordefiniert-parameter" title="Parameter">

        </chapter>

        <chapter id="vordefiniert-globale-variablen" title="Globale Variablen">

        </chapter>

        <chapter id="vordefiniert-abgeschottete-bloecke" title="Abgeschottete Blöcke">

        </chapter>

        <chapter id="vordefiniert-strikter-modus-in-funktionen" title="Strikter Modus in Funktionen">

        </chapter>
    </chapter>

    <chapter id="sichtbarkeit" title="Sichtbarkeit">

        <chapter id="sichtbarkeit-funktionen-in-funktionen"
                 title="Funktionen innerhalb von Funktionen definieren">

        </chapter>
    </chapter>

    <chapter id="fehlerbehandlung" title="Fehlerbehandlung">

        <chapter id="fehlerbehandlung-fehlerarten" title="Fehlerarten">

        </chapter>

        <chapter id="fehlerbehandlung-laufzeitfehler" title="Fehlerbehandlung von Laufzeitfehlern in JavaScript">

        </chapter>

        <chapter id="fehlerbehandlung-try-catch-finally" title="Fehler mit try-catch-finally fangen">

            <chapter id="fehlerbehandlung-error" title="Das Fehlerobjekt error">

            </chapter>
        </chapter>

        <chapter id="fehlerbehandlung-throw" title="Fehler mit throw auslösen">

        </chapter>

        <chapter id="fehlerbehandlung-fehlertypen" title="Fehlertypen">

        </chapter>
    </chapter>

    <chapter id="quellen" title="Quellen">
        <tip>
            <b>(BUCH)</b>
            978-3836256971, "JavaScript", Philip Ackermann, 2019
        </tip>
        <tip>
            <b>(WEBSEITE)</b>
            <a href="https://www.w3schools.com/js/js_whereto.asp"/>, 2023-11-06 08:00
        </tip>
        <tip>
            <b>(WEBSEITE)</b>
            <a href="https://edube.org/learn/jse1-1-0-1/precedence-continued-1"/>, 2023-11-07 07:00
        </tip>
    </chapter>
</topic>