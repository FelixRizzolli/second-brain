<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
        SYSTEM "https://resources.jetbrains.com/writerside/1.0/xhtml-entities.dtd">
<topic id="js-sprachkern"
       title="Sprachkern"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="https://resources.jetbrains.com/writerside/1.0/topic.v2.xsd">
    <show-structure depth="2" for="chapter,procedure"/>

    <chapter id="webseite" title="JavaScript auf einer Webseite verwenden">
        <p>
            JavaScript-Code wird auf einer Website mit den <code>&lt;script&gt;&gt;/script&gt;</code>-Tags angegeben.
            Dabei kann der Code direkt innerhalb der Tags geschrieben werden oder auf ein externes File ausgelagert und
            mit dem <code>src</code>-Attribut darauf verlinkt werden. Für den <code>script</code>-Tag gibt es noch
            weitere Attribute, die dessen ladeverhalten bestimmen:
        </p>

        <table style="header-column">
            <tr>
                <td>
                    <code>defer</code>
                </td>
                <td>
                    <p>
                        Das Script soll geladen werden, nachdem die HTML-Seite geladen wurde.
                    </p>
                </td>
            </tr>
            <tr>
                <td>
                    <code>async</code>
                </td>
                <td>
                    <p>
                        Das Script soll direkt parallel zum Parsen der restlichen Seite geladen werden.
                    </p>
                    <p>
                        Greift das Script direkt auf HTML-Elemente zu, die noch nicht geladen wurde, kann es zu Fehlern
                        kommen.
                    </p>
                </td>
            </tr>
        </table>
    </chapter>

    <chapter id="kommentare" title="Kommentare">
        <tip>
            Grundlegendes zu Kommentare: <a href="swe-pk-kommentare.topic"/>
        </tip>

        <p>
            In JavaScript gibt es wie in den meisten Programmiersprachen zwei Arten von Kommentaren. Das einzeilige und
            der mehrzeilige Kommentar.
        </p>

        <code-block collapsed-title="Beispeiel" collapsible="true" lang="javascript">
            <![CDATA[
                //Ein Einzeiliges Kommentar.

                /*
                Ein Mehrzeiliges Kommentar.
                */
            ]]>
        </code-block>

        <chapter id="kommentare-notation" title="Notation (fat arrow)">
            <p>

                Möchte man ein Kommentar erstellen, welches darüber Aufschluss gibt wie das Ergebnis lauten könnte,
                verwendet man einen sogenannten <b>fat arrow <code>=&gt;</code></b>.
            </p>
            <code-block lang="javascript">
                <![CDATA[
                    console.log(3 + 4 * 2); //=> 11
                ]]>
            </code-block>
        </chapter>
    </chapter>

    <chapter id="variablen" title="Variablen, Konstanten und Typisierung">
        <tip>
            Grundlegendes zo Variablen: <a href="swe-pk-grundlagen-variablen.topic"/>
        </tip>

        <chapter id="variablen-v" title="Variablen">
            <img alt="Variablendeklaration in JavaScript" src="js-sprachkern-variable-declaration.jpg"/>

            <p>
                Mit dem Schlüsselwort <code>let</code> erstellt man eine Variable. Je nachdem welcher Wert ihr
                zugewiesen
                wird, wird der Datentyp bestimmt. Noch wichtig zu wissen ist, dass jeder Wert - egal ob String oder
                Zahl - der direkt im Code steht, als Literal bezeichnet wird. Sie haben immer einen festen Wert.
                Literale haben auch einen <b>Datentyp</b> (= <code>string</code> oder <code>number</code>) welcher
                mit dem Operator <code>typeof</code> ermittelt werden kann. Bei numerischen Werten mit Kommas wird die
                amerikanische Schreibweise verwendet (Punkt statt Komma).
            </p>

            <p>
                Syntax (<b>Lass</b> <i>(früher var)</i> die Variable username Rizz sein)
            </p>

            <code-block lang="javascript">
                <![CDATA[
                    let username = "Rizz";
                    console.log(typeof variable); //=> string
                ]]>
            </code-block>

            <p>
                Die Wertzuweisung einer Variable erfolgt von rechts nach links, das bedeutet der Wert rechts vom
                Zuweisungsoperator wird der Variable links zugewiesen und nicht umgekehrt. In eine Variable lässt sich
                ein Wert einspeichern, aber in einen Wert keine Variable.
            </p>

            <p>
                Der Datentyp <code>string</code>, englischer Begriff für Zeichenkette, kann mit zwei Möglichkeiten
                definiert werden (einfache und doppelte Anführungszeichen):
            </p>

            <code-block lang="javascript">
                <![CDATA[
                    let neueVariable = "be"; //=> be
                    let neueVariable = 'be'; //=> be
                ]]>
            </code-block>

            <p>
                Die Variable des Datentyps <code>String</code> ist ein Objekt. Von dieser Variablen kann die Eigenschaft
                <code>length</code> Abgefragt (Länge) werden. Diese Eigenschaft gibt die Anzahl der Zeichen der
                Zeichenkette zurück. Beispiel: <code>console.log(&quot;Hallo Welt!&quot;.length); //=&gt; 11</code>
            </p>

            <chapter id="variablen-namensgebung" title="Namensgebung für Variablen">
                <list type="bullet">
                    <li>
                        Aussagekräftige Bezeichner (<code>alter</code> statt <code>x</code>, <code>vorname</code> statt
                        <code>z</code>, <code>preis</code> statt <code>p</code>)
                    </li>
                    <li>
                        Keine Sonderzeichen
                    </li>
                    <li>
                        <a href="swe-pk-richtlinien.topic">lowerCamelCasing</a> (Neues Wort beginnt mit einem
                        Großbuchstaben)
                    </li>
                </list>
            </chapter>

            <chapter id="variablen-let-vs-var" title="let vs. var">
                <table style="header-column">
                    <tr>
                        <td>
                            Deklatation
                        </td>
                        <td>
                            <p>
                                Die Deklaration einer Variable mit <code>let</code> hindert uns daran, eine Variable ein
                                zweites Mal mit demselben Namen zu deklarieren. Hierbei wird ein
                                <code>SyntaxError</code> geworfen. Bei <code>var</code> ist dies hingegen ohne Fehler
                                möglich.
                            </p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            Scope
                        </td>
                        <td>
                            <p>
                                Variablen, welche mit <code>let</code> deklariert wurden, sind "block-scoped", das
                                bedeutet, ihr Sichtbarkeitsbereich liegt innerhalb eines Blocks. Variablen, welche mit
                                <code>var</code> deklariert wurden, sind "function-scoped", das bedeutet ihr
                                Sichtbarkeitsbereich liegt innerhalb einer Funktion. Wird eine variable mit
                                <code>var</code> innerhalb eines Blocks (kein Funktionsblock) deklariert, so ist diese
                                auch außerhalb davon, also innerhalb der ganzen Funktion bzw. global, sichtbar.
                            </p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            Hoisting
                        </td>
                        <td>
                            <p>
                                Hoisting wird die Technik genannt, welche alle Variablendeklarationen zum Anfang
                                verschiebt. Bei <code>let</code> werden die Deklarationen zum Anfang des Blocks
                                verschoben, und bei <code>var</code> zum Anfang der Funktion.
                            </p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            Shadowing
                        </td>
                        <td>
                            <p>
                                Wenn wir einer globalen und einer lokalen Variable denselben Namen geben, dann wird
                                dies als Variable Shadowing bezeichnet. Denn die globale Variable wird nicht von der
                                lokalen überschrieben, sondern die globale wird unsichtbar und eine neue Variable mit
                                demselben Bezeichner wird lokal erstellt. Für var bedeutet lokal <code>=</code>
                                innerhalb einer Funktion; für <code>let</code> bedeutet lokal <code>=</code> innerhalb
                                eines Blocks.
                            </p>
                        </td>
                    </tr>
                </table>
            </chapter>
        </chapter>

        <chapter id="variablen-konstanten" title="Konstanten">
            <tip>
                Grundlegendes zu Konstanten: <a href="swe-pk-grundlagen-variablen.topic#konstanten"/>
            </tip>

            <p>
                Konstanten werden in JavaScript immer mit dem Schlüsselwort <code>const</code> (für eng. constant)
                deklariert. Das Beste ist, wenn man immer versucht mit Konstanten auszukommen, anstatt eine Variable zu
                verwenden. Somit vermeidet man, dass sich der wert (natürlich durch eigenes Verschulden) ungewollt
                ändert. Zudem kann für <code>const</code> die JS Engine den Code optimieren, was Auswirkungen auf die
                Performance haben kann.
            </p>

            <code-block lang="javascript">
                <![CDATA[
                    const TAX_RATE = 1.22; //Multiplikator für Mehrwertsteuer
                ]]>
            </code-block>

            <p>
                Versucht man, eine Konstante zu überschreiben, ignorieren die meisten Laufzeitumgebungen die
                entsprechende Anweisung stillschweigend (also ohne einen Fehler zu produzieren).
            </p>

            <chapter id="variablen-konstanten-namensgebung" title="Namensgebung für Konstante">
                <list type="bullet">
                    <li>
                        Aussagekräftige Bezeichner
                    </li>
                    <li>
                        Keine Sonderzeichen
                    </li>
                    <li>
                        <a href="swe-pk-richtlinien.topic">SCREAMING_SNAKE</a> (Nur Großbuchstaben; Worttrennung durch
                        Unterstrich)
                    </li>
                </list>
            </chapter>
        </chapter>

        <chapter id="variablen-typisierung" title="Typisierung">
            <chapter id="variablen-typisierung-impliziert" title="Implizierte Typkonvertierung">
                <p>
                    Was ergibt <code>&quot;5&quot; * &quot;4&quot;</code>? Die Antwort ist <code>"20"</code> mit dem
                    Datentyp <code>number</code>. Das liegt daran, dass der Multiplikator als Operanden zwei Zahlen
                    erwartet. Ist ein Operand vom Datentyp <code>string</code> so wird von JS eine sogenannte
                    implizierte Typkonvertierung durchgeführt. Der Fachausdruck dafür lautet <b>coercion</b>. Auch die
                    Operanden <code>/</code> und <code>–</code> verwenden coercion.
                </p>
            </chapter>

            <chapter id="variablen-typisierung-explizit" title="Explizite Typkonvertierung">
                <code-block lang="javascript">
                    <![CDATA[
                        let number1 = prompt(„Gib eine Nummer ein!“);   //Eingabe 1
                        let number2 = prompt(„Gib eine Nummer ein!“);   //Eingabe 2
                        console.log(„Summe:“ + (number1 + number2));    //=> Summe: 12
                    ]]>
                </code-block>

                <p>
                    Das Problem hier ist, dass die Funktion <code>prompt()</code> immer einen Wert des Datentyps
                    <code>string</code> zurückgibt. Um das zu lösen, muss man den Datentyp mit der Funktion
                    <code>Number()</code> konvertieren <code>=</code> explizite Typkonvertierung. Handelt es sich
                    jedoch bei dem übergebenen an die Funktion <code>Number()</code> um keine Zahl oder eine Mischung
                    aus Zahl und Text, so lautet der Rückgabewert <code>NaN</code> (Not a Number).
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        typeof(NaN); //=> number
                    ]]>
                </code-block>
            </chapter>
        </chapter>
    </chapter>

    <chapter id="datentypen" title="Datentypen">
        <p>
            Insgesamt wird in JavaScript zwischen sechs verschiedenen Datentypen unterschieden: Zum einen gibt es die
            drei sogenannten primitiven Datentypen für die Repräsentation von Zahlen, Zeichenketten und booleschen
            Wahrheitswerten, zum anderen die speziellen Datentypen <code>null</code> und <code>undefined</code> (auch
            eine Form von primitiven Datentypen) sowie den Typ <code>object</code>, welcher als Basis für das Erstellen
            einiger (komplexer) Objekte dient. Arrays gelten in JavaScript streng genommen nicht als eigener Datentyp.
        </p>

        <p>
            In JavaScript wird bei der Variablendeklaration der Datentyp nicht explizit festgelegt, deshalb spricht man
            hierbei auch von dem sogenannten <a href="swe-pk-grundlagen-variablen.topic#typisierung">Weak Typing</a>.
        </p>

        <table style="both">
            <tr>
                <td>
                    Datentyp
                </td>
                <td>
                    Beschreibung
                </td>
            </tr>
            <tr>
                <td>
                    Zahlen
                </td>
                <td>
                    <list type="bullet">
                        <li>
                            Ein numerischer Wert repräsentiert eine Zahl: Der Wert <code>4711</code> steht für
                            Viertausendsiebenhundertelf
                        </li>
                        <li>
                            Kommas werden mit einem Punkt notiert: <code>0.5</code>
                        </li>
                        <li>
                            Für negative Werte wird der Zahl ein Minuszeichen vorangestellt: <code>-5</code> oder
                            <code>-0.9</code>
                        </li>
                        <li>
                            Für Binärzahlen wird das Präfix <code>0b</code> verwendet: <code>0b01010101</code> steht für
                            den Dezimalwert <code>85</code>
                        </li>
                        <li>
                            Für Oktalzahlen wird das Präfix <code>0</code> oder <code>0o</code> verwendet:
                            <code>050</code> steht für den Dezimalwert <code>40</code>
                        </li>
                        <li>
                            Für Hexadezimalzahlen wird das Präfix <code>0x</code> verwendet: <code>0xF</code> steht für
                            den Dezimalwert <code>15</code>
                        </li>
                        <li>
                            Der Wertebereich liegt zwischen <code>Number.MIN_VALUE</code> (= <code>5e-324</code>) und
                            <code>Number.MAX_VALUE</code> (= <code>1.7976931348623157e+308</code>)
                        </li>
                        <li>
                            Werte außerhalb des Wertebereiches werden mit <code>-Infinity</code> und
                            <code>Infinity</code> dargestellt.
                        </li>
                        <li>
                            Berechnungen, die keinen gültigen Zahlenwert ergeben liefern den Wert <code>NaN</code> (eng.
                            <i>not a number</i>)
                        </li>
                        <li>
                            Exponentialzahlen können mit <code>e</code> dargestellt werden: <code>9e3 = 9000</code>,
                            <code>123e-5 = 0,00123</code>.
                        </li>
                    </list>
                </td>
            </tr>
            <tr>
                <td>
                    BigInt
                </td>
                <td>
                    <list type="bullet">
                        <li>
                            Größere Integer werden als BigInt erstellt. Die Literal Schreibweise, ist am Ende ein
                            <code>n</code> hinzuzufügen: <code>100n</code>.
                        </li>
                        <li>
                            typeof <code>10n</code> ergibt <code>'bigint'</code>
                        </li>
                        <li>
                            Zwischen <code>BigInt</code> und <code>Number</code> werten können keine Berechnungen
                            stattfinden: <code>1000n + 20</code> schmeißt einen <code>TypeError</code>
                        </li>
                        <li>
                            <code>BigInt</code> hat keinen eigenen äquivalent für Infinity: <code>1000n / 0n</code>
                            schmeißt einen <code>RangeError</code>
                        </li>
                    </list>
                </td>
            </tr>
            <tr>
                <td>
                    Zeichenketten
                </td>
                <td>
                    <list type="bullet">
                        <li>
                            Zeichenketten bzw. Strings repräsentieren eine Folge von Zeichen, also beispielsweise
                            Buchstaben, Ziffern, Sonderzeichen und Steuerzeichen.
                        </li>
                        <li>
                            Anfang und Ende einer Zeichenkette wird mittels Anführungszeichen definiert. Dabei können
                            einfache als auch doppelte Anführungszeichen verwendet werden. Eine Mischform ist nicht
                            erlaubt.
                        </li>
                        <li>
                            Mit dem Backslash-Zeichen (eng. <i>escape character</i>) kann maskiert (eng.
                            <i>escaping</i>) werden, sodass Anführungszeichen oder Steuerzeichen auch innerhalb eines
                            Strings verwendet werden können.
                        </li>
                    </list>
                </td>
            </tr>
            <tr>
                <td>
                    Boolesche Wahrheitswerte
                </td>
                <td>
                    <list type="bullet">
                        <li>
                            Können nur die Werte <code>true</code> (für wahr) und <code>false</code> (für falsch)
                            annehmen.
                        </li>
                        <li>
                            Spielen eine zentrale Rolle, wenn es darum geht, innerhalb eines Programms Verzweigungen zu
                            definieren.
                        </li>
                        <li>
                            folgende Werte werden von JS als <code>false</code> interpretiert: <code>false</code>,
                            <code>-0</code>, <code>0</code>, <code>0n</code>, <code>-0n</code>, <code>NaN</code> (=
                            <i>Not a Number</i>), <code>undefined</code>, <code>""</code> (= <i>empty string</i>),
                            <code>null</code>. Alle anderen werte gelten als <code>true</code>.
                        </li>
                    </list>
                </td>
            </tr>
            <tr>
                <td>
                    Objekte
                </td>
                <td>
                    <list type="bullet">
                        <li>
                            Zusammengehörige Variablen (= Eigenschaften bzw. Objekteigenschaften oder Attribute) und
                            Funktionen (= Methoden bzw. Objektmethoden) werden in Objekten zusammengefasst.
                        </li>
                        <li>
                            Bei der Objekt-Literal-Schreibweise werden Objekte über geschweifte Klammern definiert und
                            innerhalb derer die Objekteigenschaften und Objektmethoden kommasepariert aufgelistet werden
                            können.
                        </li>
                        <li>
                            Objekte sind in JavaScript eigentlich nichts anderes als Schlüssel-Wert-Paare. Schlüssel und
                            Wert werden jeweils durch einen Doppelpunkt getrennt.
                        </li>
                        <li>
                            Über dem Schlüsselwort <code>this</code> wird das aktuelle Objekt angesprochen.
                        </li>
                        <li>
                            Es gibt noch die Konstruktorfunktion, die <code>Object.create()</code>-Methode und die
                            Instanziierung einer ES2015-Klasse um in JavaScript Objekte zu erzeugen.
                        </li>
                    </list>

                    <p>
                        <b>Arrays</b>
                    </p>

                    <list type="bullet">
                        <li>
                            Ein Array gehört strenggenommen zum Datentyp Objekt und sind nichts anderes als Listen. Sie
                            können nicht nur einen, sondern mehrere Werte enthalten.
                        </li>
                        <li>
                            Die gängigste, weil einfachste Möglichkeit, in JavaScript ein Array zu erzeugen ist die
                            Array-Literal-Schreibweise. Dabei werden eckige Klammern (<code>[]</code>) verwendet, um den
                            Anfang und das Ende des Arrays zu definieren. Die einzelnen Einträge (bzw. Werte bzw.
                            Elemente), die in dem Array enthalten sein sollen, schreibt man kommasepariert zwischen den
                            Klammern.
                        </li>
                        <li>
                            Arrays können – im Unterschied zu anderen Programmiersprachen wie beispielsweise Java – auch
                            Einträge unterschiedlichen Typs enthalten. Mit anderen Worten: Ein einzelnes Array kann
                            beispielsweise Zahlen sowie Zeichenketten oder boolesche Werte, Objekte oder sogar andere
                            Arrays enthalten.
                        </li>
                    </list>
                </td>
            </tr>
            <tr>
                <td>
                    <code>undefined</code>
                </td>
                <td>
                    <list type="bullet">
                        <li>
                            Wird eine Variable deklariert, aber kein Wert zugewiesen, so hat sie den Wert
                            <code>undefined</code>.
                        </li>
                        <li>
                            Der Wert <code>undefined</code> ist nicht dazu gedacht, dass man ihn manuell einer Variable
                            zuweist.
                        </li>
                        <li>
                            Der Wert <code>undefined</code> drückt aus, dass eine Variable noch nicht initialisiert
                            wurde.
                        </li>
                    </list>
                </td>
            </tr>
            <tr>
                <td>
                    <code>null</code>
                </td>
                <td>
                    <list type="bullet">
                        <li>
                            Der Datentyp <code>null</code> definiert ein leeres Objekt.
                        </li>
                        <li>
                            Der Wert <code>null</code> kann auch einer Variable zugewiesen werden.
                        </li>
                        <li>
                            Der Wert <code>null</code> repräsentiert einen leeren Objektzeiger.
                        </li>
                    </list>
                </td>
            </tr>
            <tr>
                <td>
                    Symbol
                </td>
                <td>
                    <list type="bullet">
                        <li>
                            Symbol ist ein neuer primitiver Datentyp in JavaScript, der mit ES2015 eingeführt wurde.
                        </li>
                    </list>
                </td>
            </tr>
        </table>

        <chapter id="datentypen-konstruktor-methoden" title="Konstruktor-Methoden">
            <code-block lang="javascript">
                <![CDATA[
                    const str = new String();     // =>
                    const num = new Number();     // => 0
                    const bool = new Boolean();   // => false
                    const bigInt = new BigInt();  // => TypeError
                ]]>
            </code-block>

            <p>
                Da hierbei Objekte des jeweiligen Typs in die Variablen gespeichert werden, sollte man lieber immer
                literale anstatt die Konstruktor-Methoden verwenden.
            </p>
        </chapter>

        <chapter id="datentypen-autoboxing" title="Autoboxing">
            <p>
                Wird nach einem Literal eines primitiven Datentyps ein punkt verwendet oder nach einer Variable, welche
                einen primitiven Datentyp enthält, dann konvertiert der JS Interpreter den Wert in das Objekt des
                jeweiligen Datentyps und wir können auf dessen Methoden und Eigenschaften zugreifen. Diese Technik wird
                Autoboxing genannt.
            </p>
        </chapter>
    </chapter>

    <chapter id="operatoren" title="Operatoren">
        <tip>
            Grundlegendes zu Operatoren: <a href="swe-pk-grundlagen-ausdruecke.topic"/>
        </tip>

        <chapter id="operatoren-prio" title="Prioritätsliste">
            <table style="both">
                <tr>
                    <td>
                        Priorität
                    </td>
                    <td>
                        Gruppe
                    </td>
                    <td>
                        Assoziativität
                    </td>
                    <td>
                        Symbol
                    </td>
                </tr>
                <tr>
                    <td>
                        14
                    </td>
                    <td>
                        Gruppierung
                    </td>
                    <td></td>
                    <td>
                        <code>(</code> &#8230; <code>)</code>
                    </td>
                </tr>
                <tr>
                    <td>
                        13
                    </td>
                    <td>
                        Feldzugriff
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>.</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        12
                    </td>
                    <td>
                        Funktionsaufruf
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>(</code> &#8230; <code>)</code>
                    </td>
                </tr>
                <tr>
                    <td>
                        11
                    </td>
                    <td>
                        Postifx inkrementieren
                    </td>
                    <td></td>
                    <td>
                        &#8230; <code>++</code>
                    </td>
                </tr>
                <tr>
                    <td>
                        11
                    </td>
                    <td>
                        Postfix dekrementieren
                    </td>
                    <td></td>
                    <td>
                        &#8230; <code>--</code>
                    </td>
                </tr>
                <tr>
                    <td>
                        10
                    </td>
                    <td>
                        Logisches NOT
                    </td>
                    <td>
                        &#8592;
                    </td>
                    <td>
                        <code>!</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        10
                    </td>
                    <td>
                        Unäres Plus
                    </td>
                    <td>
                        &#8592;
                    </td>
                    <td>
                        <code>+</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        10
                    </td>
                    <td>
                        Unäre negation
                    </td>
                    <td>
                        &#8592;
                    </td>
                    <td>
                        <code>-</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        10
                    </td>
                    <td>
                        Prefix inkrementierung
                    </td>
                    <td>
                        &#8592;
                    </td>
                    <td>
                        <code>++</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        10
                    </td>
                    <td>
                        Prefix dekrementierung
                    </td>
                    <td>
                        &#8592;
                    </td>
                    <td>
                        <code>--</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        10
                    </td>
                    <td>
                        typeof
                    </td>
                    <td>
                        &#8592;
                    </td>
                    <td>
                        <code>typeof</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        10
                    </td>
                    <td>
                        delete
                    </td>
                    <td>
                        &#8592;
                    </td>
                    <td>
                        <code>delete</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        09
                    </td>
                    <td>
                        Exponentialoperator
                    </td>
                    <td>
                        &#8592;
                    </td>
                    <td>
                        &#8230; <code>**</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        08
                    </td>
                    <td>
                        Multiplikation
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>*</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        08
                    </td>
                    <td>
                        Division
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>/</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        08
                    </td>
                    <td>
                        Modulo
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>%</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        07
                    </td>
                    <td>
                        Addition
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>+</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        07
                    </td>
                    <td>
                        Subtraktion
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>-</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        06
                    </td>
                    <td>
                        Kleiner als
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>&lt;</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        06
                    </td>
                    <td>
                        Kleiner gleich als
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>&lt;=</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        06
                    </td>
                    <td>
                        Größer als
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>&gt;</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        06
                    </td>
                    <td>
                        Größer gleich als
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>&gt;=</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        06
                    </td>
                    <td>
                        instanceof
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>instanceof</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        05
                    </td>
                    <td>
                        Gleichheit
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>==</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        05
                    </td>
                    <td>
                        Ungleichheit
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>!=</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        05
                    </td>
                    <td>
                        Strikte Gleichheit
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>===</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        05
                    </td>
                    <td>
                        Strikte Ungleichheit
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>!==</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        04
                    </td>
                    <td>
                        Logisches UND
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>&amp;&amp;</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        03
                    </td>
                    <td>
                        Logisches ODER
                    </td>
                    <td>
                        &#8594;
                    </td>
                    <td>
                        &#8230; <code>||</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        02
                    </td>
                    <td>
                        Ternärer Auswahloperator
                    </td>
                    <td>
                        &#8592;
                    </td>
                    <td>
                        &#8230; <code>?</code> &#8230; <code>:</code> &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        01
                    </td>
                    <td>
                        Zuweisungsoperaoren
                    </td>
                    <td>
                        &#8592;
                    </td>
                    <td>
                        <p>&#8230; <code>=</code> &#8230;</p>
                        <p>&#8230; <code>+=</code> &#8230;</p>
                        <p>&#8230; <code>*=</code> &#8230;</p>
                        <p>&#8230; und andere Zuweisungsoperatoren</p>
                    </td>
                </tr>
            </table>

            <p>
                Wie bei in der Mathematik gilt Punkt vor Strich. Oben in der Tabelle ist die Rangliste der Priorität der
                einzelnen Operatoren aufgelistet. Um den Code übersichtlicher zu gestalten, sollte man auch bei
                Einhalten der Regeln Runde Klammern zu setzen, solange es noch übersichtlich aussieht.
            </p>
        </chapter>

        <chapter id="operatoren-unaer" title="Unäre Operatoren + und -">
            <p>
                Diese Operatoren werden für die Nummer Konvertierung verwendet.
            </p>

            <code-block lang="javascript">
                <![CDATA[
                    let str = "123";     // => "123"   (string)
                    let n1 = +str;       // => 123     (number)
                    let n2 = -str;       // => -123    (number)
                    let n3 = -n2;        // => 123     (number)
                    let n4 = +"abc";     // => NaN     (number)
                ]]>
            </code-block>
        </chapter>

        <chapter id="operatoren-logische-zuweisung" title="Logische Zuweisungsoperatoren &amp;&amp;= und ||=">
            <code-block lang="javascript">
                <![CDATA[
                    a &&= false;     // => wie a = (a && false)
                    b ||= true;      // => wie b = (b || true)
                ]]>
            </code-block>
        </chapter>

        <chapter id="operatoren-logisch" title="Logische Operatoren und nicht boolsche Werte">
            <code-block lang="javascript">
                <![CDATA[
                    console.log(true && 1991);       // => 1991
                    console.log(false && 1991);      // => false
                    console.log(2 && 5);             // => 5
                    console.log(0 && 5);             // => 0
                    console.log("Alice" && "Bob");   // => "Bob"
                    console.log("" && "Bob");        // => ""
                ]]>
            </code-block>

            <p>
                Beim Und-Operator müssen alle Operanden <code>true</code> sein. Wenn nicht, wird der erste Operand
                ausgegeben der <code>false</code> ist, sonst der letzte der true ist.
            </p>

            <code-block lang="javascript">
                <![CDATA[
                    console.log(true || 1991);       // => true
                    console.log(false || 1991);      // => 1991
                    console.log(2 || 5);             // => 2
                    console.log(0 || 5);             // => 5
                    console.log("Alice" || "Bob");   // => "Alice"
                    console.log("" || "Bob");        // => "Bob"
                ]]>
            </code-block>

            <p>
                Beim Oder-Operator muss nur ein Operand <code>true</code> sein. Hier wird der erste Operand ausgegeben,
                der <code>true</code> ist, sonst der letzte der <code>false</code> ist.
            </p>
        </chapter>

        <chapter id="operatoren-typof" title="Typbestimmung – Der typeof- und der instanceof-Operator">
            <p>
                Bei dem <code>typeof</code>-Operator handelt es sich um einen unären Operator, welcher als Operanden
                einen Wert bzw. eine Variable erwartet, für die der Typ ermittelt werden soll. Der Operator liefert
                dabei als Rückgabewert eine Zeichenkette.
            </p>

            <table style="header-row">
                <tr>
                    <td>
                        Rückgabewert des <code>typeof</code>-Operators
                    </td>
                    <td>
                        Wird zurückgegeben für &#8230;
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>boolean</code>
                    </td>
                    <td>
                        boolesche Werte
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>number</code>
                    </td>
                    <td>
                        Zahlenwerte
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>string</code>
                    </td>
                    <td>
                        Zeichenketten
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>symbol</code>
                    </td>
                    <td>
                        Symbole, ein in ES6 neu eingeführter Datentyp
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>function</code>
                    </td>
                    <td>
                        Funktionen (die in JavaScript übrigens selbst Objekte sind)
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>object</code>
                    </td>
                    <td>
                        alle (anderen) Arten von Objekten sowie den Wert <code>null</code>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>undefined</code>
                    </td>
                    <td>
                        nicht definierte Variablen
                    </td>
                </tr>
            </table>

            <p>
                Der <code>typeof</code>-Operator kann verwendet werden, um:
            </p>
            <list>
                <li>
                    primitive Datentypen von Referenztypen zu unterscheiden
                </li>
                <li>
                    die einzelnen primitiven Datentypen untereinander zu unterscheiden
                </li>
                <li>
                    herauszufinden, ob es sich bei einem Wert um eine Funktion handelt
                </li>
            </list>

            <p>
                Neben dem <code>typeof</code>-Operator gibt es noch einen weiteren Operator, der etwas mit der
                Typbestimmung von Variablen zu tun hat, und zwar den Operator <code>instanceof</code>. Vereinfacht
                gesagt, bestimmt dieser Operator, ob eine Variable von einem bestimmten Referenztyp ist. Als
                Rückgabewert liefert der Operator dabei einen booleschen Wert. <code>Object</code> ist der Typ, von dem
                alle anderen Referenztypen ableiten. Der <code>instanceof</code>-Operator liefert daher für alle
                Variablen beliebigen Referenztyps den Wert <code>true</code> zurück. Im Gegensatz zum
                <code>typeof</code>-Operator funktioniert der <code>instanceof</code>-Operator nur für Werte, die einen
                Referenztyp enthalten. Für Werte primitiven Datentyps dagegen liefert der Operator immer
                <code>false</code> zurück. Mehr zum <code>instanceof</code>-Operator hier:
                <a href="js-oop.topic#grundlagen-instanceof"/>
            </p>
        </chapter>

        <chapter id="operatoren-nach-kategorie" title="Operatoren nach Kategorie">
            <table style="both">
                <tr>
                    <td>
                        Kategorie
                    </td>
                    <td>
                        Beschreiubung
                    </td>
                </tr>
                <tr>
                    <td>
                        Zuweisungsoperatoren
                    </td>
                    <td>
                        <p>
                            Der Operator <code>+=</code> gehört zur Gruppe der zusammengesetzten Zuweisungsoperatoren.
                            Der Trick des Zusammensetzens funktioniert auch mit allen übrigen arithmetischen Operatoren
                            wie <code>+</code>, <code>-</code>, <code>/</code>und <code>%</code>. Auf der linken Seite
                            einer Zuweisung muss immer einer Variablen stehen. Preis um <code>10%</code> erhöhen:
                            <code>price *= 1.10; //=&gt; price = price * 1.10</code>
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        Relationale Operatoren
                    </td>
                    <td>
                        <p>
                            Relationale Operatoren sind <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>,
                            <code>&gt;=</code>, <code>==</code>, <code>!=</code>, <code>===</code>, <code>!===</code>
                            und ermöglichen den Vergleich zweier Werte. Das Ergebnis eines solchen Vergleiches ist
                            entweder <code>true</code> oder <code>false</code>. Die Wahrheitswerte <code>true</code> und
                            <code>false</code> haben einen eigenen Datentyp: boolean. Somit ergibt
                            <code>typeof(3 &lt; 7)</code> -&gt; <code>boolean</code>. Die Operatoren <code>==</code>,
                            <code>!=</code> und <code>===</code>, <code>!==</code> unterscheiden sich darin, dass
                            <code>===</code> und <code>!==</code> zusätzlich auch den Datentyp Vergleichen. Somit ist
                            <code>(&quot;5&quot; === 5)</code> gleich <code>false</code> und
                            <code>(&quot;5&quot; == 5)</code> gleich <code>true</code>.
                        </p>

                        <p>
                            Mit der Funktion <code>isNaN()</code> kann abgefragt werden, ob es sich beim übergebenen
                            Argument um einen Wert des Datentyps number handelt oder nicht. Der Rückgabewert ist ein
                            <code>boolean</code>.
                        </p>

                        <code-block lang="javascript">
                            <![CDATA[
                                isNaN(3);       //=> false
                                isNaN(NaN);     //=> true
                                isNaN("3");     //=> false Es enthält explizite Typkonvertierung
                                isNaN("drei");  //=> true
                            ]]>
                        </code-block>

                        <p>
                            Rationale Operatoren wie kleiner, kleiner-gleich oder größer, größer-gleich können auch
                            an Strings angewendet werden. Hierbei führt JS einen <b>lexikographischen</b> (eng.
                            <b>lexicographic</b>) Vergleich durch. Somit ergibt der Vergleich
                            <code>&quot;Hallo&quot; > &quot;Hello&quot;</code> den Wert <code>false</code> zurück, da
                            der Buchstabe <code>a</code> vor dem Buchstaben <code>e</code> im Alphabet vorkommt.
                        </p>

                        <note>
                            In JavaScript sollte man stets für den Vergleich zweier Variablen stets die strikten
                            Vergleichsoperatoren verwenden. Damit wird vermieden, dass die automatische Typkonvertierung
                            in Kraft tritt, was oft auch zu schwer zu finden Fehlern im Programm führen kann.
                        </note>
                    </td>
                </tr>
                <tr>
                    <td>
                        Logische Operatoren
                    </td>
                    <td>
                        <p>
                            In JavaScript wird <code>&amp;&amp;</code> als Und-Operator und <code>||</code> als
                            Oder-Operator verwendet. Für logische Operatoren gibt es in JavaScript folgende
                            Besonderheiten:
                        </p>

                        <!-- TODO: missing content!! -->
                    </td>
                </tr>
                <tr>
                    <td>
                        Bitweise Operationen
                    </td>
                    <td>
                        <list type="bullet">
                            <li>
                                <code>&amp;</code> bitweises UND
                            </li>
                            <li>
                                <code>|</code> bitweises ODER
                            </li>
                            <li>
                                <code>^</code> bitweises exklusives ODER
                            </li>
                            <li>
                                <code>~</code> bitweises NICHT, wobei das Ergebnis für eine Zahl <code>x</code> dann
                                <code>-(x+1)</code> lautet, also für die Zahl <code>65</code> bitweise das Ergebnis
                                <code>-66</code>.
                            </li>
                            <li>
                                <code>&lt;&lt;</code> bitweise Linksverschiebung
                            </li>
                            <li>
                                <code>&gt;&gt;</code> bitweise Rechtsverschiebung
                            </li>
                            <li>
                                <code>&gt;&gt;&gt;</code> bitweise vorzeichenignorierende Rechtsverschiebung
                            </li>
                        </list>
                    </td>
                </tr>
                <tr>
                    <td>
                        Konditionaler Operator
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                <Bedingung> ? <Wert1> : <Wert2>
                            ]]>
                        </code-block>

                        <p>
                            Der konditionale Operator ist ein tenärer Operator, der abhängig von einer Bedingung (erster
                            Operand) einen von zwei Werten zurückgibt (welche durch den zweiten und dritten Operanden
                            definiert werden).
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        Löschung von Objekteigenschaften oder Elementen innerhalb eines Arrays
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                delete
                            ]]>
                        </code-block>

                        <p>
                            Erlaubt es, Elemente aus Arrays zu löschen sowie Objekteigenschaften aus Objekten.
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        Existenz einer Eigenschaft in einem Objekt
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                <Eigenschaft> in <Objekt>
                            ]]>
                        </code-block>

                        <p>
                            Überprüft, ob ein Objekt über eine Eigenschaft verfügt.
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        Typüberprüfung
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                <Objekt> instanceof <Typ>
                            ]]>
                        </code-block>

                        <p>
                            Hierbei handelt es sich um einen binären Operator, der überprüft, ob ein Objekt von einem
                            Typ ist.
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        Typbestimmung
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                typeof <Operand>
                            ]]>
                        </code-block>

                        <p>
                            Ermittelt den Datentyp des Operanden. Der Operand kann dabei ein Objekt, ein String, eine
                            Variable oder ein Schlüsselwort wie <code>true</code> oder <code>false</code> sein. Optional
                            kann der Operand in Klammern angegeben werden.
                        </p>
                    </td>
                </tr>
            </table>
        </chapter>
    </chapter>

    <chapter id="kontrollstrukturen" title="Krontrollstrukturen">
        <tip>
            Grundlegendes zu Kontrollstrukturen: <a href="swe-pk-grundlagen-kontrollstrukturen.topic"/>
        </tip>

        <chapter id="kontrollstrukturen-auswahlstrukturen" title="Auswahlstrukturen">

            <chapter id="kontrollstrukturen-auswahlstrukturen-if" title="if-elseif-else-Statement">

                <chapter id="kontrollstrukturen-auswahlstrukturen-if-syntax" title="Syntax">
                    <code-block lang="javascript">
                        <![CDATA[
                            if (Bedingung) {
                              Anweisung1;
                            } if else (Bedingung) {
                              Anweisung2;
                            } else {
                              Anweisung3;
                            }
                        ]]>
                    </code-block>
                </chapter>

                <chapter id="kontrollstrukturen-auswahlstrukturen-if-beispiel" title="Beispiel">
                    <code-block lang="javascript">
                        <![CDATA[
                            const SOLUTION = 42;
                            let answer = Number(prompt("6 * 7"));

                            if (answer === SOLUTION){
                              console.log("Congratulation, u’re genius!");
                            }
                            if else (answer === 36){
                              console.log("This is the answer of 6 * 6!");
                            }
                            else {
                              console.log("Wrong answer!");
                            }
                        ]]>
                    </code-block>
                </chapter>

                <chapter id="kontrollstrukturen-auswahlstrukturen-if-kurzschreibweise" title="Kurzschreibweise">
                    <p>
                        Ist für die Abfrage nur eine Anweisung vorgesehen, so kann man die Kurzschreibweise verwenden:
                    </p>

                    <code-block lang="javascript">
                        <![CDATA[
                            if (answer === SOLUTION) console.log("Congratulation, u’re genius!");
                        ]]>
                    </code-block>
                </chapter>
            </chapter>

            <chapter id="kontrollstrukturen-auswahlstrukturen-tertiaerer-operator" title="Der tertiäre Operator">
                <p>
                    Eine weitere Möglichkeit den Code zu kürzen und übersichtlicher zu gestalten ist der tertiäre
                    Operator. Der tertiäre Operator hat drei Operanden (deswegen tertiär) und trennt diese mit den
                    Zeichen <code>?</code> und <code>:</code>. Beispiel:
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        if (productCategory === "books"){
                          taxRate = 1.07;
                        } else {
                          taxRate = 1.19;
                        }

                        taxRate = (productCategory === "books") ? 1.07 : 1.19;
                    ]]>
                </code-block>
            </chapter>

            <chapter id="kontrollstrukturen-auswahlstrukturen-switch" title="Mehrfachverzweigungen: switch-Statement">
                <code-block lang="javascript">
                    <![CDATA[
                        switch (expression) {
                          case value1:
                            // Anweisung
                            break;
                          case value2:
                            // Anweisung
                            break;
                          default:
                            // Anweisung
                            break;
                        }
                    ]]>
                </code-block>
            </chapter>
        </chapter>

        <chapter id="kontrollstrukturen-schleifen" title="Schleifen">
            <chapter id="kontrollstrukturen-schleifen-for" title="Zählschleife – die for-Schleife">
                <p>
                    Mit folgendem Beispiel werden alle Zahlen von 0 bis 9 ausgegeben:
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        for (let i = 0; i < 10; i+=1) {
                          console.log(i);
                        }
                    ]]>
                </code-block>

                <p>
                    Enthält der auszuführende Codeblock nur eine Anweisung, so ist in JavaScript auch folgende Kurzform
                    möglich:
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        for (let i = 0; i < 10; i+=1) console.log(i);
                    ]]>
                </code-block>
            </chapter>

            <chapter id="kontrollstrukturen-schleifen-for-of-in" title="Die for-of-Schleife und for-in-Schleife">
                <table style="none">
                    <tr>
                        <td>
                            <code>
                                for-of
                            </code>
                        </td>
                        <td>
                            Zum Iterieren von Objekten wie Array, Maps und Sets
                        </td>
                        <td>
                            <a href="js-ecmascript.topic#iteratoren-for-of"/>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                for-in
                            </code>
                        </td>
                        <td>
                            Zum iterieren von Keys von Objekten
                        </td>
                        <td>
                            <a href="js-oop.topic#grundlagen-eigenschaften-methoden-ausgeben-for-in"/>
                        </td>
                    </tr>
                </table>
            </chapter>

            <chapter id="kontrollstrukturen-schleifen-while" title="Kopfgesteuerte Schleife – die while-Schleife">
                <p>
                    Eine einfache <code>while</code>-Schleife, die die Zahlen von 1 bis 10 ausgibt:
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        let i = 1;
                        while (i < 11) {
                          console.log(i);
                          i++;
                        }
                    ]]>
                </code-block>

                <p>
                    Auch die <code>while</code>-Schleife bietet eine Kurzform, falls der auszuführende Codeblock aus nur
                    einer Anweisung besteht.
                </p>
            </chapter>

            <chapter id="kontrollstrukturen-schleifen-do-while" title="Fußgesteuerte Schleife – die do-while-Schleife">
                <p>
                    Eine einfache <code>do</code>-<code>while</code>-Schleife, die die Zahlen von 1 bis 10 ausgibt:
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        let i = 1;
                        do {
                          console.log(i);
                          i++;
                        } while (i < 11)
                    ]]>
                </code-block>
            </chapter>

            <chapter id="kontrollstrukturen-schleifen-abbrechen" title="Schleifen vorzeitig abbrechen">
                <chapter id="kontrollstrukturen-schleifen-break" title="Die break-Anweisung">
                    <p>
                        Die <code>break</code>-Anweisung wird verwendet um eine Schleife oder eine
                        <code>switch</code>-Anweisung zu terminieren. Es springt zum Ende der Schleife bzw. der
                        <code>switch</code>-Anweisung.
                    </p>

                    <code-block lang="javascript">
                        <![CDATA[
                            let numbers = [2, 4, 56, 22, 65, 2, 54, 88, 29];
                            console.log('Vor der Schleife.');
                            for (let i = 0; i < numbers.length; i++) {  // Iteriere über ...
                              let number = numbers[i];                  // ...  das Zahlenarray.
                              if (number % 2 === 1) {                   // Wenn eine Zahl ungerade ist ...
                                console.log('Ungerade Zahl gefunden.'); // ... gib Meldung aus ...
                                break;                                  // ... und brich die Schleife ab.
                              }                                         // Ansonsten ...
                              console.log(number);                      // ... gib die Zahl aus.
                            }
                            console.log('Nach der Schleife.');
                        ]]>
                    </code-block>

                    <code-block lang="javascript">
                        <![CDATA[
                            Vor der Schleife.
                            2
                            4
                            56
                            22
                            Ungerade Zahl gefunden.
                            Nach der Schleife.
                        ]]>
                    </code-block>
                </chapter>

                <chapter id="kontrollstrukturen-schleifen-continue" title="Die continue-Anweisung">
                    <p>
                        Die <code>continue</code>-Anweisung bricht nur die aktuelle Schleifeniteration ab.
                    </p>

                    <code-block lang="javascript">
                        <![CDATA[
                            let numbers = [2, 4, 56, 22, 65, 2, 54, 88, 29];
                            console.log('Vor der Schleife.');
                            for (let i = 0; i < numbers.length; i++) {  // Iteriere über ...
                              let number = numbers[i];                  // ...  das Zahlenarray.
                              if (number % 2 === 1) {                   // Wenn eine Zahl ungerade ist ...
                                console.log('Ungerade Zahl gefunden.'); // ... gib Meldung aus ...
                                continue;                               // ... und brich die Schleifeniteration ab.
                              }                                         // Ansonsten ...
                              console.log(number);                      // ... gib die Zahl aus.
                            }
                            console.log('Nach der Schleife.');
                        ]]>
                    </code-block>

                    <code-block lang="javascript">
                        <![CDATA[
                            Vor der Schleife.
                            2
                            4
                            56
                            22
                            Ungerade Zahl gefunden.
                            2
                            54
                            88
                            Ungerade Zahl gefunden.
                            Nach der Schleife.
                        ]]>
                    </code-block>
                </chapter>
            </chapter>

            <chapter id="kontrollstrukturen-schleifen-sprungmarken" title="Sprungmarken">
                <code-block lang="javascript">
                    <![CDATA[
                        let numbers = [2, 4, 56, 22, 65, 2, 54, 88, 29];
                        outerLoop:
                          for (let i = 0; i < numbers.length; i++) {
                            let number = numbers[i];
                            innerLoop:
                              for (let j = i + 1; j < numbers.length; j++) {
                                let number2 = numbers[j];
                                console.log('Vergleiche ' + number + ' mit ' + number2);
                                if (number === number2) {
                                  console.log('Gleiche Zahlen gefunden');
                                  continue outerLoop;
                                }
                              }
                          }
                    ]]>
                </code-block>

                <code-block lang="javascript">
                    <![CDATA[
                        Vergleiche 2 mit 4
                        Vergleiche 2 mit 56
                        Vergleiche 2 mit 22
                        Vergleiche 2 mit 65
                        Vergleiche 2 mit 2
                        Gleiche Zahlen gefunden
                        Vergleiche 4 mit 56
                        Vergleiche 4 mit 22
                        Vergleiche 4 mit 65
                        Vergleiche 4 mit 2
                        Vergleiche 4 mit 54...
                    ]]>
                </code-block>
            </chapter>
        </chapter>
    </chapter>

    <chapter id="funktionen" title="Funktionen">
        <tip>
            Grundlegendes zu Funktionen: <a href="swe-pk-grundlagen-funktionen.topic"/>
        </tip>

        <chapter id="funktionen-basis" title="Basis Funktionsdeklaration und Funktionsausdruck">
            <code-block collapsed-title="Funktionsdeklaration" collapsible="true" lang="javascript">
                <![CDATA[
                    function showMessage() {
                      console.log('Herzlich willkommen');
                    }
                ]]>
            </code-block>

            <code-block collapsed-title="Funktionsausdruck" collapsible="true" lang="javascript">
                <![CDATA[
                    let showMessage = function() {
                      console.log('Herzlich willkommen');
                    }
                ]]>
            </code-block>

            <p>
                Funktionen können in JavaScript nicht nur über Funktionsdeklarationen, sondern auch über sogenannte
                Funktionsausdrücke (bzw. Function Expressions) erstellt werden. Solche Funktionsausdrücke können überall
                dort verwendet werden, wo auch normale Ausdrücke verwendet werden dürfen, sprich der Interpreter einen
                Ausdruck erwartet. Üblicherweise verzichtet man dabei auf die Angabe eines Funktionsnamens, was die
                Funktion zu einer sogenannten anonymen Funktion macht.
            </p>

            <p>
                Funktionsdeklaration und Funktionsausdruck unterscheiden sich dabei in folgenden Punkten voneinander:
            </p>

            <list type="bullet">
                <li>
                    <p>
                        Bei Funktionsdeklarationen muss der Funktion ein Name gegeben werden, bei Funktionsausdrücken
                        ist der Name optional. Lässt man ihn weg, handelt es sich bei der Funktion um eine anonyme
                        Funktion.
                    </p>
                </li>
                <li>
                    <p>
                        Bei Funktionsdeklarationen werden Funktionen über Funktionsnamen aufgerufen, bei
                        Funktionsausdrücken über die Variable, der die Funktion zugewiesen wurde.
                    </p>
                </li>
                <li>
                    <p>
                        Funktionsausdrücke werden vom Interpreter erst dann verarbeitet, wenn dieser auf die
                        entsprechende Anweisung trifft. Das wiederum heißt aber auch, dass solche Funktionen erst in den
                        Anweisungen danach verwendet werden können. Bei Funktionsdeklarationen dagegen sorgt der
                        Interpreter dafür, dass die entsprechenden Funktionen auch vor der Deklaration zur Verfügung
                        stehen und somit auch in Anweisungen davor aufgerufen werden können.
                    </p>

                    <code-block collapsed-title="Beispiel" collapsible="true" lang="javascript">
                        <![CDATA[
                            // Funktionen, die per Funktionsausdruck erzeugt werden, können nicht vor diesem Ausdruck
                            // verwendet werden.
                            showMessage();  // Aufruf nicht möglich, diese Anweisung produziert einen Fehler
                            let  showMessage = function() {
                              console.log('Herzlich willkommen');
                            }

                            // Funktionen, die per Funktionsdeklaration erzeugt werden, können vor dieser Deklaration
                            // bereits verwendet werden.
                            showMessage();  // Aufruf möglich
                            function showMessage() {
                              console.log('Herzlich willkommen');
                            }
                        ]]>
                    </code-block>
                </li>
            </list>
        </chapter>

        <chapter id="funktionen-parameter" title="Parameter">
            <code-block collapsed-title="Funktionsaufruf mit Argument in JavaScript" collapsible="true"
                        lang="javascript">
                <![CDATA[
                    function printPersonInformation(firstName, lastName, age) {
                      console.log('Vorname: ' + firstName);
                      console.log('Nachname: ' + lastName);
                      console.log('Alter: ' + age);
                    }

                    printPersonInformation('Max', 'Mustermann', 44);
                    printPersonInformation('Moritz', 'Mustermann', 55);
                ]]>
            </code-block>

            <code-block collapsed-title="Ausgabe" collapsible="true" lang="javascript">
                <![CDATA[
                    Vorname: Max
                    Nachname: Mustermann
                    Alter: 44
                    Vorname: Moritz
                    Nachname: Mustermann
                    Alter: 55
                ]]>
            </code-block>

            <p>
                JavaScript ist eine schwach typisierte Programme. In JavaScript müssen für die Parameter keine
                Datentypen angegeben werden.
            </p>

            <chapter id="funktionen-parameter-weniger-argumente-als-parameter"
                     title="Funktionen mit weniger Argumenten als angegebenen Parametern aufrufen">
                <p>
                    Eine weitere Besonderheit bei der Verwendung von Funktionen, die JavaScript von anderen Sprachen wie
                    beispielsweise Java unterscheidet, ist, dass eine Funktion auch mit weniger Argumenten aufgerufen
                    werden kann, als Parameter in der Funktionsdeklaration definiert sind. Die Parameter, zu denen beim
                    Funktionsaufruf keine Argumente übergeben werden, verhalten sich innerhalb der Funktion wie
                    Variablen, die nicht initialisiert worden sind. Mit anderen Worten: Sie haben den Wert
                    <code>undefined</code>. Innerhalb der Funktion kann man nun prüfen, ob für den jeweiligen Parameter
                    ein Argument übergeben wurde, indem man testet, ob dieser den Wert <code>undefined</code> enthält:
                </p>

                <code-block collapsed-title="Funktionsaufruf mit Argument in JavaScript" collapsible="true"
                            lang="javascript">
                    <![CDATA[
                        function printPersonInformation(firstName, lastName, age) {
                          if(firstName !== undefined) console.log('Vorname: ' + firstName);
                          if(lastName !== undefined) console.log('Nachname: ' + lastName);
                          if(age !== undefined) console.log('Alter: ' + age);
                        }
                    ]]>
                </code-block>
            </chapter>

            <chapter id="funktionen-parameter-mehr-arugmente-als-parameter"
                     title="Funktionen mit mehr Argumenten als angegebenen Parametern aufrufen">
                <p>
                    Umgekehrt ist es auch möglich eine Funktion mit mehr Argumenten als angegebenen Parametern
                    aufzurufen. In einem solchen fall stehen den zu viel übergebenen Werten nicht direkte Parameter zur
                    Verfügung. Es gibt allerdings dennoch einen Weg, innerhalb einer Funktion auf alle übergebenen
                    Argumente zuzugreifen, und zwar dank der Variable <code>arguments</code>, welche implizit innerhalb
                    einer Funktion zur Verfügung steht. Dabei handelt es sich um ein Objekt, welches alle übergebenen
                    Argumente enthält und diese, wie bei einem Array, über Indizes bereitstellt. Über
                    <code>arguments[0]</code> gelangt man an das erste Argument, über <code>arguments[1]</code> an das
                    zweite usw. Über die Eigenschaft length kann zudem ermittelt werden, wie viele Argumente insgesamt
                    übergeben wurden.
                </p>

                <p>
                    Beim <code>arguments</code>-Objekt handelt es sich um kein Array, sondern um ein sogenanntes
                    <code>array</code>-ähnliches Objekt. Zwar funktioniert der Zugriff auf die einzelnen Elemente im
                    <code>arguments</code>-Objekt wie bei einem Array über den entsprechenden Index, und auch eine
                    Eigenschaft length steht zur Verfügung, über die sich die Anzahl der Elemente ermitteln lässt.
                    Allerdings verfügt das <code>arguments</code>-Objekt nicht über die Methoden, über die echte Arrays
                    verfügen.
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        function printPersonInformation(firstName, lastName, age) {
                          console.log('Vorname: ' + firstName);
                          console.log('Nachname: ' + lastName);
                          console.log('Alter: ' + age);
                          if(arguments.length > 3) console.log('Größe: ' + arguments[3]);
                          if(arguments.length > 4) console.log('Gewicht: ' + arguments[4]);
                        }
                    ]]>
                </code-block>
            </chapter>

            <chapter id="funktionen-parameter-variable-anzahl-an-argumenten"
                     title="Funktionen mit einer variablen Anzahl an Argumenten – variadische Funktionen">
                <p>
                    Seit ES2015 gibt es eine Alternative, wenn nicht sogar einen wirklichen Ersatz für das
                    <code>arguments</code>-Objekt, der dessen Verwendung quasi überflüssig macht. die Rede ist von
                    sogenannten Rest-Parametern. Rest-Parameter fassen all die Argumente bei einem Funktionsaufruf
                    zusammen, für die kein Parameter in der Funktionsdeklaration vorgesehen ist. Rest-Parameter werden
                    über drei aufeinanderfolgende Punkte und einen unmittelbar darauf folgenden beliebigen
                    Parameternamen definiert. Bei dem Rest-Parametern-Objekt handelt es sich um ein echtes Array. Es
                    beinhaltet aber nicht wie das <code>arguments</code>-Objekt alle Argumente des Funktionsaufrufs,
                    sondern nur die Argumente, zu denen es keinen passenden Parameter gibt. Besonders sinnvoll sind
                    Rest-Parameter bei solchen Funktionen, die eine variable Anzahl von Argumenten erlauben, sogenannte
                    variadischen Funktionen.
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        function printPersonInformation(firstName, lastName, age) {
                          console.log('Vorname: ' + firstName);
                          console.log('Nachname: ' + lastName);
                          console.log('Alter: ' + age);
                          if(arguments.length > 3) console.log('Größe: ' + arguments[3]);
                          if(arguments.length > 4) console.log('Gewicht: ' + arguments[4]);
                        }
                    ]]>
                </code-block>
            </chapter>

            <chapter id="funktionen-parameter-spread-operator"
                     title="Der Spread-Operator – Elemente aus einem Array als Argumente verwenden">
                <p>
                    In ES2015 wurde der Spread-Operator eingeführt. Dieser ermöglicht es, die Elemente eines Arrays auf
                    die Parameter einer Funktion zu verteilen (daher der Name <i>spread</i>) und somit die Elemente
                    direkt als Argumente zu verwenden. Um den Spread-Operator für ein Array zu verwenden, schreibt man
                    einfach drei Punkte vor den Namen des entsprechenden Arrays.
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        let userData1 = ['Max Mustermann', 'max.mustermann@example.com', 'secret'];
                        let userData2 = ['Moritz Mustermann', 'moritz.mustermann@example.com', 'password'];
                        let max = createUser(
                          ...userData1
                        );
                        let moritz = createUser(
                          ...userData2
                        );

                        function createUser(username, email, password = 'StAnDaRdPaSsWoRt') {
                          let user = {
                            username: username,
                            email: email,
                            password: password
                          }
                          return user;
                        }
                    ]]>
                </code-block>
            </chapter>

            <chapter id="funktionen-parameter-standardwerte" title="Standardwerte für Parameter">
                <p>
                    Seit ES2015 gibt es mit den sogenannten Default Parameters eine einfache Schreibweise um einen
                    Standardwert eines Parameters zu definieren. Ein definierter Standardwert, wird immer dann von der
                    jeweiligen Funktion verendet, wenn beim Funktionsaufruf in der Argumentenliste für den jeweiligen
                    Parameter kein Wert übergeben wurde. Eine Alternative, welche bereits vor ES2015 unterstützt wird,
                    wäre innerhalb der Funktion den jeweiligen Parameter auf <code>undefined</code> zu checken und falls
                    dies zutrifft einen Standardwert setzen:
                    <code>password = (password !== undefined) ? password : 'StAnDaRdPaSsWoRt';</code>
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        function createUser(username, email, password = 'StAnDaRdPaSsWoRt') {
                          let user = {
                            username: username,
                            email: email,
                            password: password
                          }
                          return user;
                        }

                        let max = createUser('Max Mustermann', 'max.mustermann@example.com', 'secret');
                        console.log(max.username);     // Max Mustermann
                        console.log(max.email);        // max.mustermann@example.com
                        console.log(max.password);     // secret

                        let moritz = createUser('Moritz Mustermann', 'moritz.mustermann@example.com');
                        console.log(moritz.username);  // Moritz Mustermann
                        console.log(moritz.email);     // moritz.mustermann@example.com
                        console.log(moritz.password);  // StAnDaRdPaSsWoRt
                    ]]>
                </code-block>
            </chapter>

            <chapter id="funktionen-parameter-funktionen" title="Funktion als Parameter">
                <p>
                    Von funktionalen Vorbildern (z.B. der Programmiersprache Scheme) hat JS die Besonderheit geerbt,
                    dass Funktionen einfache Werte sind. Genauso, wie eine Zahl einer Variable zugeordnet wird, kann
                    auch eine Funktion einer Variable zugeordnet werden.
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        let price = 3;
                        let add = (a, b) => a + b;

                        typeOf(price);     // => number
                        typeOf(add);       // => function
                    ]]>
                </code-block>

                <p>
                    Die funktionale Programmierung spricht von sogenannten <b>first-class citizens</b> (Bürger erster
                    Klasse) oder <b>first class functions</b>. Damit ist gemeint, dass die Sprache Funktionen genauso
                    behandelt wie andere Werte. Funktionen können mit Variablen referenziert werden und sogar als
                    Argumente übergeben werden.
                </p>

                <p>
                    Als Beispiel die <code>sort()</code>-Funktion für Arrays. Möchte man ein Zahlen-Array mit dieser
                    Funktion Sortieren, so kommt womöglich nicht das gewünschte Ergebnis, da diese Funktion
                    standardmäßig eine sogenannte lexikographische Sortierung durchführt. Das bedeutet, die 10 kommt
                    nach der 1 aber die 2 kommt nach der 10.
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        [ 16, 10, 2, 12, 1].sort();                 //=> [1, 10, 12, 16, 2]
                    ]]>
                </code-block>

                <p>
                    Das Verhalten der Funktion <code>sort()</code> lässt sich beeinflussen, somit kann der Funktion
                    mitgeteilt werden welche Werte sie als kleiner und welche als größer erachten soll. Dazu wird eine
                    Funktion benötigt, welche zwei Parameter entgegennimmt und diese miteinander vergleicht.
                </p>

                <p>
                    <code>sort()</code> erwartet von der Vergleichsfunktion, dass sie:
                </p>

                <list type="none">
                    <li>
                        0 zurückgibt, falls a und b gleich sind
                    </li>
                    <li>
                        eine positive Zahl zurückgibt, falls a größer als b ist
                    </li>
                    <li>
                        eine negative Zahl zurückgibt, falls a kleiner als b ist
                    </li>
                </list>

                <code-block lang="javascript">
                    <![CDATA[
                        let compareNumerical = (a, b) => a – b;
                        [ 16, 10, 2, 12, 1].sort(compareNumerical);  // => [1, 2, 10, 12, 16]
                        [ 16, 10, 2, 12, 1].sort((a, b) => a – b);   // => [1, 2, 10, 12, 16]
                    ]]>
                </code-block>

                <p>
                    Funktionen wie <code>sort()</code>, deren Parameter selbst wider Funktionen sind (oder sein können),
                    heißen <b>Higher-Order-Funktionen</b> – Funktionen höherer Ordnung
                </p>
            </chapter>
        </chapter>

        <chapter id="funktionen-return" title="Rückgabewerte">
            <p>
                In JavaScript wird der Rückgabewert innerhalb der Funktion nach dem Schlüsselwort <code>return</code>
                angegeben. Rückgabewerte können Zahlenwerte, Zeichenketten, boolesche Werte, Objekte, Arrays und sogar
                Funktionen selbst sein. Es ist aber immer nur möglich einen Rückgabewert anzugeben. Um dennoch aus einer
                Funktion mehrere Ergebnisse zurückzugeben, bedient man sich in der Praxis oft des Tricks, diese
                Ergebnisse in ein Array oder ein Objekt zusammenzufassen und dieses Array bzw. Objekt zurückzugeben.
            </p>

            <code-block lang="javascript">
                <![CDATA[
                    function cubeVolume(length, width, height) {
                      let volume = Math.PI * radius * height;
                      return volume;
                    }
                ]]>
            </code-block>
        </chapter>

        <chapter id="funktionen-arrow-functions" title="Arrow Functions bzw. Fat Arrow Functions">
            <p>
                Mit ES2015 wurde eine Kurzschreibweise für eine Funktionsdefinition eingeführt. Genauer gesagt, handelt
                es sich dabei um eine alternative Schreibweise für Funktionsausdrücke. Diese Funktionen nennt man
                aufgrund der verwendeten Syntax auch Arrow Functions oder Fat Arrow Functions. Arrow Functions werden
                seit ES2015 in der Praxis vor allem dann gerne verwendet, wenn es darum geht, Funktionen als Argumente
                anderer Funktionen zu verwenden.
            </p>

            <p>
                <code>
                    (Parameter) => {Funktionskörper}
                </code>
            </p>

            <p>
                Die Syntax für die Parameter und für den Funktionskörper unterscheidet sich bei Arrow Functions je
                nachdem, wie viele Parameter die Funktion erwartet und was man durch sie ausdrücken möchte. In der Regel
                werden Parameter wie bei »normalen« Funktionen in runde Klammern geschrieben, der Funktionskörper analog
                in geschweifte Klammern. Hier die verschiedenen Schreibweisen für Arrow-Funktionen:
            </p>

            <table style="header-row">
                <tr>
                    <td>
                        Schreibweise
                    </td>
                    <td>
                        Bedeutung
                    </td>
                    <td>
                        Beispiel
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            () =&gt; { &lt;Funktionskörper&gt; }
                        </code>
                    </td>
                    <td>
                        Funktion ohne Parameter
                    </td>
                    <td>
                        <code>
                            () =&gt; console.log('Hallo Welt')
                        </code>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            x =&gt; { &lt;Funktionskörper&gt; }
                        </code>
                    </td>
                    <td>
                        Funktion mit einem Parameter
                    </td>
                    <td>
                        <code>
                            message =&gt; console.log(message)
                        </code>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            (x, y) =&gt; { &lt;Funktionskörper&gt; }
                        </code>
                    </td>
                    <td>
                        Funktion mit mehreren Parametern
                    </td>
                    <td>
                        <code>
                            (x, y) =&gt; {return x + y;}
                        </code>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            &lt;Funktionsparameter&gt; =&gt; { return x*x }
                        </code>
                    </td>
                    <td>
                        Funktionskörper als Block
                    </td>
                    <td>
                        <code>
                            (x, y) =&gt; {return x + y;}
                        </code>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            &lt;Funktionsparameter&gt; =&gt; x*x
                        </code>
                    </td>
                    <td>
                        Funktionskörper als Anweisung
                    </td>
                    <td>
                        <code>
                            (x, y) =&gt; return x + y
                        </code>
                    </td>
                </tr>
            </table>

            <code-block lang="javascript">
                <![CDATA[
                    let sum = (x, y) => {return x + y;}
                    // ... ist das Gleiche wie ...
                    let sum = function (x, y) {
                      return x + y;
                    }
                ]]>
            </code-block>

            <chapter id="funktionen-arrow-functions-return" title="Objekt als Rückgabewert">
                <p>
                    Möchte man bei einer Arrow Function auf die Angabe der geschweiften Klammern verzichten, aber ein
                    Objekt zurückgeben, muss das Objekt in runde Klammern geschrieben werden, um zu verhindern, dass die
                    geschweiften Klammern des Objekts fälschlicherweise als Funktionskörper interpretiert werden.
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        let createUser => (username, email, password) =>  ({ username: username, email: email, password: password });
                    ]]>
                </code-block>
            </chapter>

            <chapter id="funktionen-arrow-functions-eigenschaften" title="Weitere Eigenschaften von Arrow Functions">
                <p>
                    Zusätzlich zu der syntaktischen Vereinfachung gegenüber Funktionen, die über das Schlüsselwort
                    <code>function</code> definiert werden, bieten Arrow Functions noch einige weitere Eigenschaften,
                    die vieles in der JavaScript-Entwicklung vereinfachen. Um diese jedoch zu verstehen, sind tiefere
                    Kenntnisse in JavaScript vonnöten:
                </p>

                <list type="bullet">
                    <li>
                        Der Wert, der durch <code>this</code> referenziert wird, ergibt sich aus dem Kontext, in dem die
                        Funktion definiert wird, nicht aus dem Kontext, in dem sie ausgeführt wird.
                    </li>
                    <li>
                        Arrow-Funktionen können nicht mit einem <code>new</code> aufgerufen werden, können also nicht
                        als Konstruktorfunktionen herhalten.
                    </li>
                    <li>
                        Die Variable <code>this</code> kann nicht geändert werden.
                    </li>
                </list>
            </chapter>
        </chapter>

        <chapter id="funktionen-ausfuehrungskontext" title="Ausführungskontexte">
            <p>
                Insgesamt gibt es in JavaScript folgende drei verschiedene Arten von Ausführungskontexten:
            </p>

            <list>
                <li>
                    <p>
                        <b>Ausführungskontext des globalen Codes:</b> Code, der sich nicht innerhalb einer Funktion
                        befindet, wird auch als globaler Code (sprich von überall erreichbarer Code) bezeichnet. Der
                        Kontext, in dem dieser Code ausgeführt wird, wird folglich auch als globaler Ausführungskontext
                        bezeichnet. Innerhalb eines Programms kann es nur einen einzigen globalen Ausfürhungskontext
                        geben.
                    </p>
                </li>
                <li>
                    <p>
                        <b>Ausführungskontext eines Funktionsaufrufs:</b> Code innerhalb einer Funktion nennt man auch
                        Funktionscode. Dieser Code ist nur innerhalb der jeweiligen Funktion erreichbar. Der
                        Ausführungskontext von Funktionen bestimmt, welche Variablen, welche anderen Funktionen
                        (innerhalb der Funktion), welche Parameter (laut Funktionssignatur) und welche konkreten
                        Argumente zur Verfügung stehen. Folglich wird für jeden Funktionsaufruf ein eigener, neuer
                        Ausführungskontext erstellt.
                    </p>
                </li>
                <li>
                    <p>
                        <b>Ausführungskontext eines Aufrufs der Funktion <code>eval()</code>:</b> Die Methode
                        <code>eval()</code> dient dazu, Quelltext, der in Form einer Zeichenkette übergeben wird, zu
                        interpretieren und auszuführen. Wird die Funktion aufgerufen, wird für den (als Zeichenkette)
                        übergebenen Code eine eigene Form von Ausführungskontext erstellt. Da die Methode
                        <code>eval()</code> aber mit Vorsicht zu genießen ist und die Verwendung dieser Methode eher als
                        Bad Practice angesehen wird sollte diese vermieden werden.
                    </p>
                </li>
            </list>

            <chapter id="funktionen-gueltigkeitsbereich" title="Gültigkeitsbereiche">
                <p>
                    In JavaScript werden die Gültigkeitsbereiche lexikalisch ermittelt, das bedeutet, dass sich der
                    Gültigkeitsbereich aus dem umgebenen Quelltext ergibt. Globale Variablen und Funktionen sind überall
                    in einem Programm sichtbar. Variablen und Funktionen, die innerhalb einer Funktion definiert wurden,
                    sind nur in dieser Funktion und in allen anderen Funktionen, die innerhalb dieser Funktion definiert
                    wurden, sichtbar.
                </p>
            </chapter>

            <chapter id="funktionen-kontextobjekt" title="Kontextobjekt">
                <p>
                    Das Kontextobjekt <code>this</code> hat je nachdem ob eine Funktion als globale Funktion oder als
                    Methode eines Objekts aufgerufen wird, einen anderen Wert.
                </p>

                <p>
                    <code>this</code> im Kontext eines Objekts bezieht sich auf das Objekt.
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        let person = {
                          name: 'Max',               // Objekteigenschaft
                          getName: function() {
                            return this.name;
                          }
                        }

                        console.log(person.getName()); // Ausgabe: Max
                    ]]>
                </code-block>

                <p>
                    Eine einfache globale Funktion, in der <code>this</code> verwendet wird
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        function getNameGlobal() {
                          return this.name;
                        }

                        console.log(getNameGlobal()); // undefined
                    ]]>
                </code-block>

                <p>
                    <code>this</code> im globalen Kontext bezieht sich auf das globale Objekt.
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        let name = "globaler Name";
                        function getNameGlobal() {
                          return this.name;
                        }

                        console.log(getNameGlobal()); // Ausgabe: globaler Name
                    ]]>
                </code-block>

                <p>
                    <code>this</code> bezieht sich auf den Kontext der Funktion.
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        let person = {
                          name : 'Moritz',
                          getName : getNameGlobal
                        }
                        let artist = {
                          name : 'Kyuss',
                          getName : getNameGlobal
                        }

                        console.log(person.getName()); // Ausgabe: Moritz
                        console.log(artist.getName()); // Ausgabe: Kyuss
                    ]]>
                </code-block>
            </chapter>
        </chapter>

        <chapter id="funktionen-funktionsaufruf-durch-nutzerinteraktion"
                 title="Funktionsaufruf durch Nutzerinteraktion">
            <p>
                In JavaScript lassen sich durch sogenannte Event-Listener bei Auftreten eines Ereignisses bestimmte
                Funktionen aufrufen. Um nun auf das Bestätigen einer Schaltfläche zu reagieren und eine Funktion
                aufzurufen fügt man einfach einen Event-Listener für das <code>click</code>-Event an die entsprechende
                Schaltfläche hinzu.
            </p>

            <code-block lang="javascript">
                <![CDATA[
                    <!DOCTYPE html>
                    <html>
                    <head lang="en">
                      <meta charset="UTF-8">
                      <title>Beispiel</title>
                      <link rel="stylesheet" href="styles/main.css" type="text/css">
                    </head>
                    <body>
                      <div class="container">
                        <div class="row">
                          <label for="field1">X</label>
                          <input id="field1" type="text" value="5">
                        </div>
                        <div class="row">
                          <label for="field2">Y</label>
                          <input id="field2" type="text" value="5">
                        </div>
                        <div class="row">
                          <label for="result">Ergebnis: </label>
                          <input id="result" type="text">
                          <button id="button-calculate-sum">Summe berechnen</button>
                        </div>
                      </div>
                      <script src="scripts/main.js"></script>
                    </body>
                    </html>
                ]]>
            </code-block>

            <code-block lang="javascript">
                <![CDATA[
                    document.addEventListener('DOMContentLoaded', function() {
                      let button = document.getElementById('button-calculate-sum');
                      button.addEventListener('click', calculateSum);
                    });

                    function calculateSum() {
                      let x = parseInt(document.getElementById('field1').value);
                      let y = parseInt(document.getElementById('field2').value);
                      let result = x + y;  showResult(result);
                    }
                    function showResult(result) {
                      let resultField = document.getElementById('result');
                      resultField.value = result;
                    }
                ]]>
            </code-block>

            <p>
                In dem JavaScript-Code wird zunächst über die <code>addEventListener()</code>-Methode ein Event-Listener
                für das Event <code>DOMContentLoaded</code> registriert. Die anonyme Funktion, die hierbei als
                Event-Listener übergeben wird, wird erst ausgeführt, wenn alle Elemente auf der Webseite geladen sind.
                Damit wird sichergestellt, dass die Eingabefelder und die Schaltfläche vorhanden sind, wenn im Folgenden
                darauf zugegriffen wird.
            </p>

            <p>
                Innerhalb dieses Event-Listeners wird ein weiterer Event-Listener registriert, der ausgeführt wird, wenn
                das <code>click</code>-Event ausgelöst wird: die Funktion <code>calculateSum()</code>. Diese wiederum
                greift auf die beiden Eingabefelder zu, liest deren Werte aus, addiert diese und zeigt das Ergebnis
                mithilfe der Funktion <code>showResult()</code> in dem dritten Eingabefeld an.
            </p>
        </chapter>
    </chapter>

    <chapter id="vordefiniert" title="Vordefinierte Funktionen und Objekte">

        <chapter id="vordefiniert-console" title="Konsolenausgabe">
            <code-block lang="javascript">
                <![CDATA[
                    console.log(“Hallo”);
                ]]>
            </code-block>

            <p>
                Die Funktion <code>log</code> des Objektesconsolegibt in der Browserkonsole die übergebenenParameter
                aus. Im Beispeil: <code>Hallo</code>.
            </p>
        </chapter>

        <chapter id="vordefiniert-warnungsfenster" title="Warnungsfenster">
            <code-block lang="javascript">
                <![CDATA[
                    window.alert("Hallo");
                ]]>
            </code-block>

            <p>
                Bei Funktionen des vordefinierten Objektes window kann auch das <code>window</code> weggelassen und
                direkt die Funktion bsp. <code>alert</code> angegeben werden. Die wahrscheinlich von allem am meisten
                gehasste Funktion des Browsers. Die <code>alert</code>-Funktion. Bei der <code>alert</code>-Funktion
                wird im Browser ein Warnungsfenster geöffnet und die Interaktion mit der Seite gesperrt. Dadurch, da sie
                von nervtötenden Werbewebseiten größtenteils missbraucht wird, hasst sie jeder.
            </p>
        </chapter>

        <chapter id="vordefiniert-eingabefenster" title="Eingabefenster">
            <code-block lang="javascript">
                <![CDATA[
                    let username = window.prompt("Gib deinen Namen ein");
                ]]>
            </code-block>

            <p>
                Mit dieser Codezeile öffnet sich ein Fenster mit der Meldung <code>Gib deinen Namen ein</code> worunter
                sich eine Eingabezeile befindet. Die Eingabe des Benutzers wird bei <code>bestätigen</code> mit
                <code>Ok</code> in die Variable <code>username</code> gespeichert.
            </p>
        </chapter>

        <chapter id="vordefiniert-use-strict" title="Der &quot;use strict&quot; Modus">
            <p>
                Ein <b>Scope</b> ist ein Bereich, innerhalb dessen eine Variable Gültigkeit besitzt. Typischerweise
                werden Variablen mit <code>let</code> definiert. Dadurch besitzt eine Variable <i>local scope</i> – d.h.
                sie ist in genau dem lokalen Bereich gültig, indem sie definiert ist. Ein Bereich ist dabei ein
                Code-Block, der durch die geschweiften Klammern abgegrenzt ist. Außerdem ist die Variable erst ab ihrer
                Deklaration gültig und nicht vorher.
            </p>

            <code-block lang="javascript">
                <![CDATA[
                    if (true) {
                      let a = 1;
                      console.log(a);   //=> 1
                    }
                    console.log(a);     //=> Reference Error: a is not defined

                    let x = () => {
                      console.log(a);   //=> Reference Error:  can’t access lexical declaration “a” before initialization
                      let a = 1;
                    }
                ]]>
            </code-block>

            <note>
                <p>
                    <b>
                        Altes JavaScript
                    </b>
                </p>

                <p>
                    Das ältere Schlüsselwort <code>var</code> hingegen zieht Variablendeklarationen immer an den Anfang
                    einer Funktion (sogenanntes <i>Hosting</i>) und macht die Variable in der kompletten Funktion
                    verfügbar - <i>function scope</i>.
                </p>
            </note>
        </chapter>

        <chapter id="vordefiniert-konstante" title="Konstante">
            <p>
                Konstante <code>const</code> verwenden dasselbe Prinzip wie <code>let</code>, mit dem einzigen
                Unterschied, dass Konstante konstant sind.
            </p>
        </chapter>

        <chapter id="vordefiniert-parameter" title="Parameter">
            <p>
                Funktionsparameter verhalten sich wie Variablen. Sie werden zu Beginn der Funktion deklariert und stehen
                somit innerhalb des ganzen Funktionscode-Blocks zur Verfügung.
            </p>
        </chapter>

        <chapter id="vordefiniert-globale-variablen" title="Globale Variablen">
            <p>
                Globale Variablen sind Variablen die außerhalb von Funktionen, auf oberster (globaler) Ebene definiert
                werden. Sie sind überall gültig. Globale Variablen sollten man vermeiden, da sie oft der Grund für
                Fehler sind. Es kann auch passieren, dass man eine globale Variable aus Versehen anlegt, indem man das
                let vergisst.
            </p>

            <code-block lang="javascript">
                <![CDATA[
                    let x = () => {
                      a = 3;
                    }
                    let y = () => {
                      console.log(a); //=> 3
                    }
                    x();
                    y();
                    console.log(a); //=> 3
                ]]>
            </code-block>

            <p>
                Netscape legte anfangs großen Wert darauf, dass JS einsteigfreundlich ist. Das führte leider zu einigen
                sehr fragwürdigen Designentscheidungen. JS akzeptiert viele Fehler und Probleme, was es Anfängern
                erleichtert erst einmal den Code zum Laufen zu bringen. Das Problem davon ist, dass es dazu führen kann,
                dass man Stunden oder Tage damit verbringt einen Fehler zu suchen, dessen Ursache sich an einer ganz
                anderen Stelle im Code befindet. Seit der JS-Sprachversion ES5.1 gibt es ein Gegenmittel: den strict
                mode. Im strict mode erkennt JS viele potenzielle Probleme und kennzeichnet sie als Fehler. Es ermahnt
                einen den Code sozusagen „sauber“ zu schreiben. Der Befehl <code>„use strict“;</code> wird von älteren
                Browsern als nur ein String-Literal gelesen, welches nicht mal einer Variablen zugewiesen wird. Neuere
                Browser hingegen verstehen diesen Befehl und schalten den Modus um.
            </p>


            <code-block lang="javascript">
                <![CDATA[
                    "use strict";
                    price = 10;    //=> ReferenceError: assignment to undeclared variable price
                ]]>
            </code-block>
        </chapter>

        <chapter id="vordefiniert-abgeschottete-bloecke" title="Abgeschottete Blöcke">
            <p>
                Erstellt man in einer JS-Datei eine Variable außerhalb jeder Funktion, so ist diese auch in den anderen
                JS-Dateien sichtbar, da sie global erstellt wurde. Dies kann zu Konflikten im Code führen. Um dem
                entgegenzuwirken, erstellt man immer einen Block mit <code>{ }</code> Klammern.
            </p>

            <code-block lang="javascript">
                <![CDATA[
                    {
                      let a = 10;
                      console.log(a);
                    }
                    console.log(a); // => Variable a existiert nicht!
                ]]>
            </code-block>
        </chapter>

        <chapter id="vordefiniert-strikter-modus-in-funktionen" title="Strikter Modus in Funktionen">
            <p>
                Es besteht auch die Möglichkeit, den strikten Modus gezielt für einzelne Funktionen zu verwenden. Um
                dies zu tun, muss die Anweisung <code>'use strict';</code> als erste Anweisung an den Anfang der
                Funktion hinzugefügt werden.
            </p>

            <code-block lang="javascript">
                <![CDATA[
                    function showMessage() {
                      'use strict';
                      let message = 'Herzlich willkommen';
                      console.log(message);
                    }
                ]]>
            </code-block>
        </chapter>
    </chapter>

    <chapter id="sichtbarkeit" title="Sichtbarkeit">
        <chapter id="sichtbarkeit-funktionen-in-funktionen"
                 title="Funktionen innerhalb von Funktionen definieren">
            <p>
                In JavaScript ist es (im Gegensatz zu anderen Sprachen wie beispielsweise Java) möglich, Funktionen
                innerhalb von anderen Funktionen zu definieren. Solche Funktionen sind dann nur innerhalb der Funktion
                sichtbar bzw. gültig, in der sie definiert wurden.
            </p>
        </chapter>
    </chapter>

    <chapter id="fehlerbehandlung" title="Fehlerbehandlung">
        <tip>
            Grundlegendes zur Fehlerbehandlung: <a href="swe-pk-errorhandling.topic"/>
        </tip>

        <chapter id="errorhandling-fehlerarten" title="Fehlerarten">
            <list type="bullet">
                <li>
                    <p>
                        <b>Syntaxfehler</b> - wie werden in JavaScript erst zur Laufzeit erkannt, weil es sich ja um
                        eine interpretierte und keine kompilierte Programmiersprache handelt.
                    </p>
                </li>
                <li>
                    <p>
                        <b>Laufzeitfehler</b> - sind eigentlich Fehler die selbst bei kompilierten Programmen erst zur
                        Laufzeit auftreten würden. Syntaxfehler treten immer auf, wenn das fehlerhafte Stück Code
                        interpretiert wird, Laufzeitfehler dagegen treten nur auf, wenn das fehlerhafte Stück Code auch
                        ausgeführt wird. Beispielsweise, wenn innerhalb des Programms auf Variablen zugegriffen wird,
                        die nicht deklariert wurden.
                    </p>
                </li>
                <li>
                    <p>
                        <b>Logische Fehler</b> - werden durch falsche Logik des Programms verursacht.
                    </p>
                </li>
            </list>
        </chapter>

        <chapter id="errorhandling-laufzeitfehler" title="Fehlerbehandlung von Laufzeitfehlern in JavaScript">
            <p>
                Auf Laufzeitfehler kann man mit sogenannter Fehlerbehandlung reagieren. Tritt ein Laufzeitfehler auf
                (man sagt auch: »wird ein Fehler geworfen«), gibt es in JavaScript (zumindest innerhalb von Browsern)
                zwei Möglichkeiten, auf den jeweiligen Fehler zu reagieren (bzw. »den Fehler zu fangen«) und diesen zu
                behandeln.
            </p>

            <p>
                Zunächst hat man über sogenannte <code>try</code>-<code>catch</code>-Codeblöcke die Möglichkeit, Fehler
                abzufangen. Wird der Fehler nicht von einem solchen <code>try</code>-<code>catch</code>-Codeblock
                abfangen, hat man zusätzlich die Möglichkeit, über den Event-Handler <code>window.onerror</code> auf den
                Fehler zu reagieren. Dies kann man allerdings nur innerhalb von Browsern machen, da nur hier das
                <code>window</code>-Objekt zur Verfügung steht. Wird auch hier nicht auf den Fehler reagiert, landet
                dieser schließlich beim Nutzer, was in der Regel bedeutet, dass der Fehler auf der Konsole ausgegeben
                wird.
            </p>

            <note>
                Fehler tritt auf → Fehlerbehandlung über <code>try</code>-<code>catch</code> → Fehlerbehandlung über
                <code>window.onerror</code> (nur Browser) → Fehler landet beim Nutzer
            </note>
        </chapter>

        <chapter id="errorhandling-try-catch-finally" title="Fehler mit try-catch-finally fangen">
            <code-block lang="javascript">
                <![CDATA[
                    try {
                      // Code ausführen, der potenziell Fehler produziert
                    } catch (error) {
                      // Behandeln des Fehlers
                      if (error instanceof RangeError) { // -> conditional exception handling
                        // Spezielle Behandlung eines Fehlers des Typs RangeError.
                      } else if (error instanceof TypeError) {
                        // Spezielle Behandlung eines Fehlers des Typs TypeError.
                      }
                    } finally {
                      // Alles, was hier steht, wird immer ausgeführt, unabhängig davon,
                      // ob ein Fehler aufgetreten ist oder nicht.
                    }
                ]]>
            </code-block>

            <chapter id="errorhandling-error" title="Das Fehlerobjekt error">
                <p>
                    Das Fehlerobjekt, welches innerhalb des <code>catch</code>-Blocks über die in der Regel
                    <code>error</code> benannte Variable zur Verfügung steht, stellt in JavaScript zwei Eigenschaften
                    zur Verfügung, über die man an genauere Informationen über den Grund des Fehlers gelangt:
                </p>

                <table style="header-row">
                    <tr>
                        <td>
                            Eigenschaft
                        </td>
                        <td>
                            Beschreibung
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                name
                            </code>
                        </td>
                        <td>
                            Typ des Fehlers
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                message
                            </code>
                        </td>
                        <td>
                            Beschreibung, was fehlgeschlagen ist.
                        </td>
                    </tr>
                </table>

                <p>
                    Je nach Laufzeitumgebung verfügt das Fehlerobjekt noch über weitere Eigenschaften, wie
                    beispielsweise in Firefox die Eigenschaft <code>fileName</code>, <code>lineNumber</code> und
                    <code>columnName</code>. Da diese Eigenschaften aber nicht standardisiert sind, sollten sie nicht
                    (bzw. zumindest nicht in Produktivsystemen) verwendet werden.
                </p>
            </chapter>
        </chapter>

        <chapter id="errorhandling-throw" title="Fehler mit throw auslösen">
            <p>
                Mit dem Schlüsselwort <code>throw</code> kann ein Fehler ausgelöst werden. Für den Fehler wird mit dem
                <code>new</code>-Schlüsselwort ein neues Fehlerobjekt instanziiert. Dieses Fehlerobjekt kann ein
                Standardfehlerobjekt oder ein eigenes Fehlerobjekt sein.
            </p>

            <code-block lang="javascript">
                <![CDATA[
                    function accessDatabase() {
                      openDatabaseConnection();    // 'Datenbankverbindung geöffnet'

                      try {
                        getUsersByName(22);
                      } catch(error) {
                        console.log(error);        // TypeError: Zeichenkette erwartet
                        throw new DBError('Fehler bei der Kommunikation mit der Datenbank');
                      } finally {
                        closeDatabaseConnection(); // 'Datenbankverbindung geschlossen'
                      }
                    }

                    function showUsers() {
                      try {
                        accessDatabase();
                      } catch(error) {
                        document.getElementById('message').textContent = error.message;
                      }
                    }

                    function getUsersByName(name) {
                      if(typeof name !== 'string') {
                        throw new TypeError('Zeichenkette erwartet');
                      }
                      /* ... */
                    }
                ]]>
            </code-block>

            <img alt="Darstellung Fehlerbehandlung und Fehler schmeißen mit throw"
                 src="js-sprachkern-errorhandling-throw.png"/>
        </chapter>

        <chapter id="errorhandling-fehlertypen" title="Fehlertypen">
            <p>
                In JavaScript gibt es verschiedene Typen von Fehlern, die jeweils durch ein anderen Objekttyp
                repräsentiert werden. Darüber hinaus gibt es auch die Möglichkeit, eigene Fehlertypen zu erstellen.
            </p>

            <table>
                <tr>
                    <td>
                        Fehlertyp
                    </td>
                    <td>
                        Beschreibung
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            Error
                        </code>
                    </td>
                    <td>
                        Basistyp, von dem andere Fehlertypen ableiten
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            EvalEroor
                        </code>
                    </td>
                    <td>
                        Kann bei falscher Verwendung der <code>eval()</code>-Funktion auftreten.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            RangeError
                        </code>
                    </td>
                    <td>
                        Tritt auf, wenn eine Zahl außerhalb eines Wertebereichs liegt, beispielsweise wenn man versucht,
                        ein Array mit negativer Länge zu erstellen: <code>new Array(-5)</code>.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            ReferenceError
                        </code>
                    </td>
                    <td>
                        Tritt auf, wenn an einer Stelle ein Objekt (eben ein Referenztyp) erwartet wird. Typischerweise
                        tritt dieser Fehlertyp auf, wenn man versucht, auf eine nicht existente Variable zuzugreifen.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            SyntaxError
                        </code>
                    </td>
                    <td>
                        Tritt auf, wenn beim Parsen des Quelltextes mit der Funktion <code>eval()</code> ein Fehler in
                        der Syntax gefunden wird.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            TypeError
                        </code>
                    </td>
                    <td>
                        Tritt auf, wenn eine Variable oder ein Parameter mit einem ungültigen Typ aufgerufen wird.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            URIError
                        </code>
                    </td>
                    <td>
                        Tritt auf, wenn im Zusammenhang mit einer URI ein Fehler aufgetreten ist, beispielsweise wenn
                        den Funktionen <code>encodeURI()</code> oder <code>decodeURI()</code> falsche Argumente
                        übergeben werden.
                    </td>
                </tr>
            </table>
        </chapter>
    </chapter>

    <chapter id="quellen" title="Quellen">
        <tip>
            <b>(BUCH)</b>
            978-3836256971, "JavaScript", Philip Ackermann, 2019
        </tip>
        <tip>
            <b>(WEBSEITE)</b>
            <a href="https://www.w3schools.com/js/js_whereto.asp"/>, 2023-11-06 08:00
        </tip>
        <tip>
            <b>(WEBSEITE)</b>
            <a href="https://edube.org/learn/jse1-1-0-1/precedence-continued-1"/>, 2023-11-07 07:00
        </tip>
    </chapter>
</topic>