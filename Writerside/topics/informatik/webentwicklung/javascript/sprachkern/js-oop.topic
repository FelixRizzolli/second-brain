<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
        SYSTEM "https://resources.jetbrains.com/writerside/1.0/xhtml-entities.dtd">
<topic id="js-oop"
       title="Objektorientierte Programmierung"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="https://resources.jetbrains.com/writerside/1.0/topic.v2.xsd">
    <show-structure depth="2" for="chapter,procedure"/>

    <!-- TODO: migrate from Confluence -->
    <chapter id="grundlagen" title="Grundlagen">
        <tip>
            Grundlegende Konzepte der objektorientierten Programmierung: <a href="swe-pk-paradigmen-oop.topic"/>
        </tip>

        <p>
            JavaScript ist eine Programmiersprache die das objektorientierte Programmierparadigma unterstützt.
        </p>

        <chapter id="grundlagen-instanceof" title="Der instanceof-Operator">
            <p>
                Der <code>instanceof</code>-Operator bestimmt, ob eine Variable von einem bestimmten Referenztyp ist.
                Als Rückgabewert liefert der Operator dabei einen booleschen Wert. <code>Object</code> ist der Typ, von
                dem alle anderen Referenztypen ableiten. Der <code>instanceof</code>-Operator liefert daher für alle
                Variablen beliebigen Referenztyps den Wert <code>true</code> zurück. Im Gegensatz zum
                <code>typeof</code>-Operator funktioniert der <code>instanceof</code>-Operator nur für Werte, die einen
                Referenztyp enthalten. Für Werte primitiven Datentyps dagegen liefert der Operator immer
                <code>false</code> zurück.
            </p>

            <p>
                Beispiele für Referenztypen wären:
            </p>

            <list type="bullet">
                <li>
                    der Referenztyp <code>Object</code>, der alle Arten von Objekten repräsentiert
                </li>
                <li>
                    der Referenztyp <code>Array</code>, der Arrays repräsentiert
                </li>
                <li>
                    der Referenztyp <code>RegExp</code>, der sogenannte reguläre Ausdrücke repräsentiert, mit denen man
                    innerhalb von Zeichenketten nach bestimmten Mustern suchen kann
                </li>
                <li>
                    der Referenztyp <code>Date</code>, der Datums- und Zeitangaben repräsentiert
                </li>
                <li>
                    der Referenztyp <code>Math</code>, mit dem sich komplexere Berechnungen durchführen lassen.
                </li>
            </list>

            <p>
                Darüber hinaus gibt es verschiedene sogenannte <b>Wrapperobjekte</b>, die den primitiven Datentypen
                zusätzliche Funktionalitäten bereitstellen.
            </p>
        </chapter>

        <chapter id="grundlagen-this" title="Das Schlüsselwort this">
            <p>
                Das Schlüsselwort <code>this</code> repräsentiert das Objekt, in dem es verwendet wird.
            </p>
        </chapter>

        <chapter id="grundlagen-objekte-erstellen" title="Objekte erstellen">
            <p>
                In JavaScript gibt es zwei Möglichkeiten Objekte zu erstellen: Das Erzeugen eines Objekts über die
                Konstruktorfunktion oder ober die Literal-Schreibweise. Aber welche Methode sollte verwendet werden?
            </p>

            <list type="bullet">
                <li>
                    Für einfache Objekte, die on-the-fly erstellt werden sollten, von denen nicht mehrere Instanzen
                    benötigt werden, ist die Objekt-Literal-Schreibweise gut geeignet.
                </li>
                <li>
                    Werden mehrere Objektinstanzen von einem Objekttyp erstellt, so ist die Klassensyntax die bessere
                    Wahl. Die Konstruktorfunktion wird mittlerweile nur noch in Ausnahmefällen verwendet.
                </li>
                <li>
                    Die Methode <code>Object.create()</code> kann verwendet werden, wenn die Klassensyntax nicht zur
                    Verfügung steht – wenn die Laufzeitumgebung noch keine ES6-Features unterstützt.
                </li>
            </list>

            <chapter id="grundlagen-objekte-erstellen-literal-schreibweise" title="Die Objekt-Literal-Schreibweise">
                <code-block lang="javascript">
                    <![CDATA[
                        let item = {
                          name: 'Professionell entwickeln mit JavaScript',
                          price: 49.90,
                          author: 'Philip Ackermann',
                          isbn: '978-3-8362-5687-2',
                          printDescription: function() {
                            console.log(this.author + ': ' + this.name);
                          }
                        }

                        console.log(item.name);    // "Professionell entwickeln mit JavaScript"
                        console.log(item.price);   // 49.90
                        console.log(item.author);  // "Philip Ackermann"
                        console.log(item.isbn);    // "978-3-8362-5687-2"
                        item.printDescription();   // "Philip Ackermann: Professionell entwickeln mit JavaScript"
                    ]]>
                </code-block>
            </chapter>

            <chapter id="grundlagen-objekte-erstellen-konstruktorfunktion" title="Konstruktorfunktion">
                <p>
                    Eine Funktion wird erst dadurch zu einer Konstruktorfunktion, dass man sie über das Schüsselwort
                    <code>new</code> aufruft. Ruft man eine Funktion als Konstrktorfunktion auf, ist innerhalb der
                    Funktion keine <code>return</code>-Anweisung notwendig. Stattdessen wird eine neue Objektinstanz
                    zurückgegeben. Eine Konstruktorfunktion kann mehrfach verwendet werden, um verschiedene
                    Objektinstanzen zu erzeugen. Bei der Literal-Schreibweise dagegen trifft dies nicht zu, hier werden
                    immer einzelne Objekte erstellt.
                </p>

                <note>
                    Prinzipiell ist es auch möglich, eine als Konstruktorfunktion gedachte Funktion als »normale«
                    Funktion, sprich ohne vorangestelltes <code>new</code>, aufzurufen. Umgekehrt können Sie »normalen«
                    Funktionen auch ein <code>new</code> voranstellen und sie somit als Konstruktorfunktion aufrufen.
                    Allerdings macht beides in der Regel keinen Sinn.
                </note>

                <p>
                    Der Konvention folgend, beginnen Funktionen, die als Konstruktorfunktionen aufgerufen werden können,
                    mit einem Großbuchstaben bzw., genauer gesagt: Sie folgen der Upper-CamelCase-Schreibweise, bei der
                    ja – wenn ein Funktionsname aus mehreren Wörtern besteht – jedes Wort mit einem Großbuchstaben
                    beginnt.
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        function Item(name, price, author, isbn) {
                          this.name = name;
                          this.price = price;
                          this.author = author;
                          this.isbn = isbn;
                          this.printDescription = function() {
                            console.log(this.author + ': ' + this.name);
                          }
                        }

                        let item = new Item(
                          'Professionell entwickeln mit JavaScript',
                          49.90,
                          'Philip Ackermann',
                          '978-3-8362-5687-2'
                        );

                        console.log(item.name);    // "Professionell entwickeln mit JavaScript"
                        console.log(item.price);   // 49.90
                        console.log(item.author);  // "Philip Ackermann"
                        console.log(item.isbn);    // "978-3-8362-5687-2"
                        item.printDescription();   // "Philip Ackermann: Professionell entwickeln mit JavaScript"
                    ]]>
                </code-block>

                <img alt="Konstruktorfunktion" src="js-sprachkern-oop-konstruktorfunktion.png"/>

                <p>
                    Konstrukterfunktionen werden auch beispielsweise verwendet, wenn ein neues Array mit
                    <code>new Array()</code> erstellt wird oder ein Fehlerobjekt mit <code>new Error()</code>.
                </p>
            </chapter>

            <chapter id="grundlagen-objekte-erstellen-prototypen" title="Prototypen">
                <p>
                    Jede Konstruktorfunktion verwaltet intern einen sogenannten Prototyp, sprich ein Objekt, welches als
                    Basis für die Konstruktorfunktion zu erzeugenden Objekte dient. Dieser Prototyp ist der Funktion in
                    der Eigenschaft <code>prototype</code> hinterlegt. Wird nun ein Objekt mit einer solchen
                    Konstruktorfunktion erzeugt, basiert das Objekt also auf dem dort hinterlegten Prototyp.
                </p>

                <p>
                    Nach dem Erzeugen des Objekts kann der Prototyp entweder über die Eigenschaft <code>__proto__</code>
                    des Objekts über die Methode <code>Object.getPrototypeOf()</code> ermittelt werden. Über die
                    Eigenschaft <code>constructor</code> kann eine Objektinstanz außerdem bestimmt werden, mit welcher
                    Konstruktorfunktion es erzeugt wurde.
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        console.log(Item.prototype);               // Item {}
                        console.log(item.__proto__);               // Item {}
                        console.log(Object.getPrototypeOf(item));  // Item {}
                        console.log(item.constructor);             // function Item(...)
                    ]]>
                </code-block>

                <img alt="Prototypen" src="js-sprachkern-oop-prototypen.png"/>

                <p>
                    Mit dem <code>instanceof</code>-Operator lässt sich überprüfen, ob ein Objekt mit einer
                    bestimmten Konstruktorfunktion erzeugt wurde. Wurde beispielsweise das Objekt <code>item</code> mit
                    der Konstruktorfunktion <code>Item()</code> erzeugt, liefert der Ausdruck item <code>instanceof
                    Item</code> den Wert <code>true</code>. Im Detail ist der Sachverhalt bei der Verwendung einer
                    Konstruktorfunktion und der Anwendung des <code>instanceof</code>-Operators etwas komplizierter:
                    Prototypen können nämlich auch ihrerseits Prototypen haben, was dann zu einer ganzen Kette von
                    Prototypen, der sogenannten Prototypenkette, führt. Der <code>instanceof</code>-Operator prüft
                    daher, genauer gesagt, ob das jeweilige Objekt auf einem der Prototypen in der prototypenkette
                    basiert.
                </p>
            </chapter>

            <chapter id="grundlagen-objekte-erstellen-klassensyntax" title="Klassensyntax aus ES6">
                <p>
                    Klassen wurden in JavaScript mit ECMAScript 6 eingeführt. Klassen werden in JavaScript über das
                    Schlüsselwort <code>class</code> definiert. Hinter diesem Schlüsselwort notiert man den Namen der
                    Klasse (in Upper-CamelCase-Schreibweise) sowie Klassenkörper (den Inhalt der Klasse) in geschweiften
                    Klammern. Innerhalb des Klassenkörpers definiert man die Methoden, die für Objektinstanzen der
                    Klasse zur Verfügung stehen sollen. Die Methode mit dem Namen constructor() nimmt dabei eine
                    besondere Rolle ein: Sie wird implizit aufgerufen, wenn man eine neue Objektinstanz der
                    entsprechenden Klasse erzeugt.
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        class Item {
                          constructor(name, price, author, isbn) {
                            this.name = name;
                            this.price = price;
                            this.author = author;
                            this.isbn = isbn;
                          }
                          printDescription() {
                            console.log(this.author + ': ' + this.name);
                          }
                        }
                    ]]>
                </code-block>

                <img alt="Klassensyntax (1)" src="js-sprachkern-oop-klassensyntax-es6-1.png"/>

                <p>
                    Die neue ES6-Klassensyntax ist letztendlich lediglich eine syntaktische Alternative zu der
                    Verwendung von Konstruktorfunktionen. Wie auch Konstruktorfunktionen haben Klassen ebenfalls eine
                    Eigenschaft <code>prototype</code>, welche das Basisobjekt, also den Prototyp enthält, auf Basis
                    dessen Instanz der Klasse erzeugt werden. Instanzen der Klasse wiederum verfügen ebenfalls über die
                    zwei Eigenschaften <code>__proto__</code> und <code>constructor</code>: Erstere referenziert den
                    Prototyp der Instanz, Letztere die Klasse, über die die Instanz erzeugt wurde.
                </p>

                <img alt="Klassensyntax (2)" src="js-sprachkern-oop-klassensyntax-es6-2.png"/>
            </chapter>

            <chapter id="grundlagen-objekte-erstellen-object-create" title="Object.create() aus ES5">
                <p>
                    Die <code>Object.create()</code>-Methode, als Helfermethode Objekte zu erzeugen, wurde in
                    ECMAScript 5 eingeführt. Sie erwartet als ersten Parameter den Prototyp des zu erzeugenden
                    Objekts und als zweiten optionalen Parameter ein Konfigurationsobjekt, über das man die
                    Eigenschaften und Methoden des Objekts konfigurieren kann. Die Eigenschaften stellen dabei die
                    Namen der Eigenschaften des zu erstellenden Objekts dar. Als wert ist dabei jeweils wiederum ein
                    Objekt hinterlegt, über welches neben dem Wert auch sogenannte Eigenschaftsattribute definieren
                    lassen. Mit <code>Object.create(null)</code> kann ein Objekt ohne Prototyp erstellt werden, dies
                    sollten wir aber nicht verwenden, wenn wir uns nicht zu 100&nbsp;% sicher sind, warum wir das
                    wollen.
                </p>

                <code-block collapsed-title="Beispiel" collapsible="true" lang="javascript">
                    <![CDATA[
                    let item = Object.create(Object.prototype, {
                      name: {
                        value: 'Schrödinger programmiert Java',
                        writable: false,
                        configurable: true,
                        enumerable: true
                      },
                      price: {
                        value: 44.90,
                        writable: true,
                        configurable: true,
                        enumerable: true
                      },
                      author: {
                        value: 'Philip Ackermann',
                        writable: false,
                        configurable: true,
                        enumerable: true
                      },
                      isbn: {
                        value: '978-3-8362-4583-8',
                        writable: false,
                        configurable: true,
                        enumerable: false     // Die Eigenschaft "isbn" wird bei Iteration nicht ausgegeben.
                      },
                      printDescription: {
                        value: function() {
                          console.log(this.author + ': ' + this.name);
                        }
                      }
                    });

                    for(let property in item) {
                      console.log(property);    // Ausgabe: "name", "price", "author"
                    }

                    item.name = 'Cooles neues Java-Buch';
                    console.log(item.name);     // "Schrödinger programmiert Java", da die
                                                // Eigenschaft "name" nicht "writeable" ist.

                    item.price = 54.95;
                    console.log(item.price);    // "54.95", da für die Eigenschaft "price"
                                                // das Attribut "writable" den Wert "true" hat.
                    ]]>
                </code-block>
            </chapter>

            <chapter id="grundlagen-objekte-erstellen-eigenschaftsattribute" title="Eigenschaftsattribute">
                <p>
                    Über diese Eigenschaftsattribute können einzelne Objekteigenschaften konfiguriert werden.
                </p>

                <table style="header-row">
                    <tr>
                        <td>
                            Eigenschaftsattribut
                        </td>
                        <td>
                            Beschreibung
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                value
                            </code>
                        </td>
                        <td>
                            Definiert den Wert der Eigenschaft.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                writable
                            </code>
                        </td>
                        <td>
                            Dieses Eigenschaftsattribut gibt (über einen booleschen Wert) an, ob die jeweilige
                            Eigenschaft überschrieben werden kann, sprich nach Initialisierung mit einem neuen Wert
                            belegt werden darf. Standardmäßig hat dieses Attribut den Wert <code>false</code>.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                enumerable
                            </code>
                        </td>
                        <td>
                            Dieses Eigenschaftsattribut gibt (über einen booleschen Wert) an, ob die jeweilige
                            Eigenschaft aufzählbar ist, sprich, ob – wenn über die Eigenschaften des entsprechenden
                            Objekts iteriert wird – diese Eigenschaft dazugezählt wird, Standardmäßig hat dieses
                            Attribut den Wert <code>false</code>.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                configurable
                            </code>
                        </td>
                        <td>
                            Dieses Eigenschaftsattribut gibt (über einen booleschen Wert) an, ob das
                            Eigenschaftsattribut an sich für die jeweilige Eigenschaft verändert werden kann, sprich, ob
                            die Eigenschaft über die Attribute im Nachhinein konfiguriert werden kann. Auch für dieses
                            Attribut ist der Standardwert <code>false</code>.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                set
                            </code>
                        </td>
                        <td>
                            Dieses Eigenschaftsattribut gibt an, welche Funktion aufgerufen wird, wenn schreibend auf
                            die Eigenschaft zugegriffen wird (nur für sogenannte Zugriffseigenschaften verwendbar).
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                get
                            </code>
                        </td>
                        <td>
                            Dieses Eigenschaftsattribut gibt an, welche Funktion aufgerufen wird, wenn lesend auf die
                            Eigenschaft zugegriffen wird (nur für sogenannte Zugriffseigenschaften verwendbar).
                        </td>
                    </tr>
                </table>

                <p>
                    Um auf die Eigenschaftsattribute einer Eigenschaft bzw. Methode zuzugreifen, steht einem die Methode
                    <code>Object.getOwnPropertyDescriptor()</code> zur Verfügung. Diese Methode erwartet als ersten
                    Parameter das jeweilige Objekt, sowie als zweiten Parameter den Namen der Eigenschaft/Methode, für
                    welche die Attribute ermittelt werden sollen. Zurück liefert die Methode ein Objekt mit den
                    bekannten Eigenschaften: <code>value</code>, <code>writable</code>, <code>enumerable</code>,
                    <code>configurable</code> sowie <code>set</code> und <code>get</code>.
                </p>
            </chapter>
        </chapter>

        <chapter id="grundlagen-eigenschaften-methoden" title="Eigenschaften und Methoden">
            <chapter id="grundlagen-eigenschaften-methoden-zugriff" title="Zugriff">
                <p>
                    Um auf Objekteigenschaften und Objektmethoden zuzugreifen gibt es in JavaScript zwei Möglichkeiten:
                </p>

                <list type="bullet">
                    <li>
                        <p>
                            Die <b>Punktschreibweise</b> über den Punkt, dem sogenannten <b>Memberoperator</b>, da
                            Eigenschaften und Methoden eines Objektes auch als Member bezeichnet werden.
                        </p>

                        <code-block lang="javascript">
                            <![CDATA[
                                let itemName = item.name;
                                item.printDescription();
                            ]]>
                        </code-block>
                    </li>
                    <li>
                        <p>
                            Die <b>Klammerschreibweise</b> bei der, der Name der Eigenschaft bzw. Methode in eckigen
                            Klammern hinter den Namen des Objekts geschrieben wird. Ob beim Zugriff über die
                            Klammerschreibweise einfache oder doppelte Anführungszeichen verwendet werden, spielt keine
                            Rolle. Es sollte nur einheitlich programmiert werden.
                        </p>

                        <code-block lang="javascript">
                            <![CDATA[
                                let itemName = item['name'];
                                item['printDescription']();
                            ]]>
                        </code-block>
                    </li>
                </list>

                <p>
                    In einigen Fällen ist ausschließlich die Klammerschreibweise möglich, und zwar immer dann, wenn der
                    Name der jeweiligen Eigenschaft oder Methode das Minuszeichen enthält.
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        let person = {
                          'first-name': 'Max',
                          'last-name': 'Mustermann'
                        }

                        console.log(person.first-name);     // Syntaxfehler
                        console.log(person.last-name);      // Syntaxfehler
                        console.log(person['first-name']);  // "Max"
                        console.log(person['last-name']);   // "Mustermann"
                    ]]>
                </code-block>
            </chapter>

            <chapter id="grundlagen-eigenschaften-methoden-datenkapselung" title="Datenkapselung">
                <p>
                    In JavaScript gibt es zwei spezielle Schüsselwörter, um Setter- und Getter Methoden als solche
                    auszuzeichnen: <code>set</code> für Setter-Methoden und <code>get</code> für Getter-Methoden. Diese
                    Schlüsselwörter können in Kombination mit der Objekt-Literal-Schreibweise, mit
                    Kunstruktorfunktionen, mit Klassen und in Kombination mit der Methode <code>Object.create()</code>
                    verwendet werden. Mehr zur Theorie hier:
                    <a href="swe-pk-paradigmen-oop.topic#konzepte-kapselung">OOP - Kapselung</a>
                </p>

                <p>
                    Um Namenskonflikte zwischen Eigenschaften und den Methoden zu vermeiden, lässt man Erstere häufig
                    mit einem Unterstrich beginnen. Im Codebeispiel sind die Eigenschaften, um die es
                    geht(<code>_name</code>, <code>_price</code>, <code>_author</code> und <code>_isbn</code>), zwar
                    auch ohne Verwendung der Setter und Getter zugänglich und somit nicht vor direktem Zugriff
                    geschützt.
                </p>

                <code-block collapsed-title="Getter und Setter bei der Verwendung von der Objekt-Literal-Schreibweise"
                            collapsible="true"
                            lang="javascript">
                    <![CDATA[
                        let item = {
                          _name: 'Schrödinger programmiert Java',
                           _price: 44.90,
                          _author: 'Philip Ackermann',
                           _isbn: '978-3-8362-4583-8',
                           set name(newName) {
                            if(typeof newName === 'string') {
                              console.log('Neuen Namen setzen');
                              this._name = newName;
                            } else {
                              throw new TypeError('Name muss eine Zeichenkette sein.')
                            }
                          },
                          get name() {
                            console.log('Namen zurückgeben');
                            return this._name;
                          }  /* Analog für die anderen Eigenschaften. */
                        }

                        console.log(item.name);    // "Namen zurückgeben"
                                                   // "Schrödinger programmiert Java"
                        item.name = 'Schrödinger programmiert Java - Das etwas andere Fachbuch';
                                                   // "Neuen Namen setzen"
                    ]]>
                </code-block>

                <code-block collapsed-title="Getter und Setter bei der Verwendung von Konstruktorfunktionen"
                            collapsible="true"
                            lang="javascript">
                    <![CDATA[
                        function Item(name, price, author, isbn) {
                          this._name = name;
                          this._price = price;
                          this._author = author;
                          this._isbn = isbn;
                        }

                        Item.prototype = {
                          set name(newName) {
                            if(typeof newName === 'string') {
                              console.log('Neuen Namen setzen');
                              this._name = newName;
                            } else {
                              throw new TypeError('Name muss eine Zeichenkette sein.')
                            }
                          },
                          get name() {
                            console.log('Namen zurückgeben');
                            return this._name;
                          }  /* Analog für die anderen Eigenschaften. */
                        };

                        let item = new Item(
                          'Schrödinger programmiert Java',
                          44.90,
                          'Philip Ackermann',
                          '978-3-8362-4583-8'
                        );

                        console.log(item.name);    // "Namen zurückgeben"
                                                   // "Schrödinger programmiert Java"
                        item.name = 'Schrödinger programmiert Java - Das etwas andere Fachbuch';
                                                   // "Neuen Namen setzen"
                    ]]>
                </code-block>

                <code-block collapsed-title="Getter und Setter bei der Verwendung von Klassen"
                            collapsible="true"
                            lang="javascript">
                    <![CDATA[
                        class Item {
                          constructor(name, price, author, isbn) {
                            this._name = name;
                            this._price = price;
                            this._author = author;
                            this._isbn = isbn;
                          }
                          set name(newName) {
                            if(typeof newName === 'string') {
                              console.log('Neuen Namen setzen');
                              this._name = newName;
                            } else {
                              throw new TypeError('Name muss eine Zeichenkette sein.')
                            }
                          }
                          get name() {
                            console.log('Namen zurückgeben');
                            return this._name;
                          }  /* Analog für die anderen Eigenschaften. */
                        }

                        let item = new Item(
                          'Schrödinger programmiert Java',
                          44.90,
                          'Philip Ackermann',
                          '978-3-8362-4583-8'
                        );

                        console.log(item.name);    // "Namen zurückgeben"
                                                   // "Schrödinger programmiert Java"
                        item.name = 'Schrödinger programmiert Java - Das etwas andere Fachbuch';
                                                   // "Neuen Namen setzen"
                    ]]>
                </code-block>

                <code-block collapsed-title="Getter und Setter bei der Verwendung von »Object.create()«"
                            collapsible="true"
                            lang="javascript">
                    <![CDATA[
                        let item = Object.create(Object.prototype, {
                          name: {
                            set: function(newName) {
                              if (typeof newName === 'string') {
                                console.log('Neuen Namen setzen');
                                this._name = newName;
                              } else {
                                throw new TypeError('Name muss eine Zeichenkette sein.')
                              }
                            }
                          },
                          get: function() {
                            console.log('Namen zurückgeben');
                            return this._name;
                          }    /* Analog für die anderen Eigenschaften. */
                        });

                        item.name = "Schrödinger programmiert Java - Das etwas andere Fachbuch";
                        // Ausgabe: 'Neuen Namen setzen'
                        console.log(item.name);
                        // Ausgabe: 'Namen zurückgeben'
                        //          'Schrödinger programmiert Java - Das etwas andere Fachbuch'
                    ]]>
                </code-block>
            </chapter>

            <chapter id="grundlagen-eigenschaften-methoden-manipulieren"
                     title="Objekteigenschaften und Objektmethoden hinzufügen, ändern, überprüfen und löschen">
                <p>
                    In JavaScript können Objekteigenschaften und Objektmethoden jederzeit hinzugefügt, gelöscht und
                    verändert werden. Das ist in vielen anderen Sprachen nicht möglich. Fürs Hinzufügen von
                    Objekteigenschaften und Objektmethoden gibt es in JavaScript folgende Möglichkeiten:
                </p>

                <table style="header-row">
                    <tr>
                        <td>
                            Typ
                        </td>
                        <td>
                            Beispiel
                        </td>
                        <td>
                            Beschreibung
                        </td>
                    </tr>
                    <tr>
                        <td>
                            Hinzufügen/Verändern
                        </td>
                        <td>
                            <code-block lang="javascript">
                                <![CDATA[
                                    item.publisher = 'Galileo Press';
                                ]]>
                            </code-block>
                        </td>
                        <td>
                            <p>
                                Mit dem Memberoperator bzw. über die Punktschreibweise lassen sich neue
                                Objekteigenschaften und Objektmethoden hinzufügen, falls sie im jeweiligen Objekt noch
                                nicht existieren. Existieren sie bereits so werden sie mit dieser Methode überschrieben.
                            </p>

                            <p>
                                Prinzipiell ist es egal, ob direkt beim Anlegen eines Objekts über die
                                Literal-Schreibweise alle Eigenschaften und Methoden direkt angegeben oder über die
                                Punktschreibweise einzeln hinzugefügt werden.
                            </p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            Hinzufügen/Verändern
                        </td>
                        <td>
                            <code-block lang="javascript">
                                <![CDATA[
                                    item['publisher'] = 'Galileo Press';
                                ]]>
                            </code-block>
                        </td>
                        <td>
                            <p>
                                Wie bei der Punktschreibweise können über die Klammerschreibweise Objekteigenschaften
                                und Objektmethoden hinzugefügt oder überschrieben werden.
                            </p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            Hinzufügen
                        </td>
                        <td>
                            <code-block lang="javascript">
                                <![CDATA[
                                    let item = {};
                                    Object.defineProperty(item,
                                      'name', {
                                       value: 'Schrödinger programmiert Java'
                                      }
                                    );
                                ]]>
                            </code-block>

                            <code-block lang="javascript">
                                <![CDATA[
                                    let item = {};
                                    Object.defineProperties(item, {
                                      name: {
                                        value: 'Schrödinger programmiert Java'
                                      },
                                      // ...
                                    });
                                ]]>
                            </code-block>
                        </td>
                        <td>
                            <p>
                                Seit ECMAScript 5 stellt JavaScript für das Definieren von Objekteigenschafen und
                                Objektmethoden zwei Helfermethoden zur Verfügung: über die
                                <code>Object.defineProperty()</code> lässt sich eine einzelne neue Eigenschaft (bzw.
                                Methode) definieren, über <code>Object.defineProperties()</code> direkt mehrere auf
                                einen Schlag.
                            </p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            Überprüfen
                        </td>
                        <td>
                            <code-block lang="javascript">
                                <![CDATA[
                                    'price' in item;
                                ]]>
                            </code-block>
                        </td>
                        <td>
                            <p>
                                Mit dem <code>in</code>-Operator kann überprüft werden, ob ein Objekt über eine gewisse
                                Eigenschaft oder Methode verfügt. Er gibt <code>true</code> zurück, falls die
                                Eigenschaft, die als erster Operand übergeben wird, in dem als zweiten Operanden
                                übergebenen Objekt existiert.
                            </p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            Löschen
                        </td>
                        <td>
                            <code-block lang="javascript">
                                <![CDATA[
                                    delete item.price;
                                ]]>
                            </code-block>
                        </td>
                        <td>
                            <p>
                                Objekteigenschaften und Objektmethoden werden mit dem <code>delete</code>-Operator, dem
                                als Operanden die zu entfernende Objekteigenschaft übergeben wird, gelöscht. Das
                                Verwenden des <code>delete</code>-Operators ist übrigens nicht gleichzusetzen mit dem
                                Zuweisen des <code>null</code>-Wertes oder des <code>undefined</code>-Wertes einer
                                Objekteigenschaft. Letzteres sorgt lediglich dafür, dass die Eigenschaft den Wert
                                <code>null</code> oder <code>undefined</code> erhält, nicht aber die Eigenschaft aus
                                dem Objekt entfernt wird.
                            </p>
                        </td>
                    </tr>
                </table>
            </chapter>

            <chapter id="grundlagen-eigenschaften-methoden-ausgeben"
                     title="Objekteigenschaften und Objektmethoden ausgeben">
                <p>
                    Werden die Eigenschaftsnamen und Methodennamen eines Objekts oder deren Werte als Array benötigt
                    sollte man zu den Helfermethoden <code>Object.keys()</code>, <code>Object.values()</code> oder
                    <code>Object.entries()</code> greifen. Soll hingegen einmalig über die Namen iteriert werden, ist es
                    besser die <code>for-in</code>-Schleife zu verwenden.
                </p>

                <p>
                    Erwähnenswert ist, dass die <code>for-in</code>-Schleife auch über(aufzählbare) Eigenschaften und
                    Methoden der Prototypen eines Objekts iteriert, während die Methode <code>Object.keys()</code> nur
                    die Namen der (aufzählbaren) Eigenschaften und Methoden zurückgibt, die an der jeweiligen
                    Objektinstanz selbst definiert wurden.
                </p>

                <chapter id="grundlagen-eigenschaften-methoden-ausgeben-for-in" title="Die for-in-Schleife">
                    <p>
                        Mithilfe der <code>for-in</code>-Schleife lässt sich über all aufzählbaren Eigenschaften und
                        Methoden eines Objekts iterieren (also über solche, deren Eigenschaftsattribut
                        <code>enumerable</code> den Wert <code>true</code> hat). In jeder Iteration der
                        <code>for-in</code>-Schleife wird hier der Variablen <code>property</code> jeweils der
                        entsprechende Namen der Eigenschaft bzw. Methode des Objekts item zugewiesen. Über die
                        Klammerschreibweise ist es dann beispielsweise möglich, auf die jeweiligen Werte der
                        Eigenschaften zuzugreifen (über die Punktschreibweise wäre dies beispielweise nicht möglich.
                    </p>

                    <code-block lang="javascript">
                        <![CDATA[
                            let item = {
                              name: 'Schrödinger programmiert Java',
                              price: 44.90,
                              author: 'Philip Ackermann',
                              isbn: '978-3-8362-4583-8',
                              printDescription: function() {
                                console.log(this.author + ': ' + this.name);
                              }
                            }

                            for(let property in item) {
                              console.log('Name: ' + property);
                              console.log('Wert: ' + item[property]);
                            }
                        ]]>
                    </code-block>
                </chapter>

                <chapter id="grundlagen-eigenschaften-methoden-ausgeben-helfermethoden" title="Helfermethoden">
                    <p>
                        Seit ECMAScript 5 gibt es die Methode <code>Object.keys()</code>, die für ein Objekt die Namen
                        aller (aufzählbaren) Eigenschaften und Methoden als Array zurückgibt.
                    </p>

                    <code-block lang="javascript">
                        <![CDATA[
                            let properties = Object.keys(item);
                            for(let i=0; i<properties.length; i++) {
                              let property = properties[i];
                              console.log('Name: ' + property);
                              console.log('Wert: ' + item[property]);
                            }

                            printArray(properties);
                            function printArray(array) {
                              for(let i=0; i<array.length; i++) {
                                console.log(array[i]);
                              }
                            }
                        ]]>
                    </code-block>

                    <p>
                        Seit ES2017 gibt es die Methoden <code>Object.values()</code> und <code>Object.entries()</code>.
                        Erstere gibt die Werte aller (aufzählbaren) Eigenschaften und Methoden als Array zurück,
                        Letztere Name-Wert-Paare aller (aufzählbaren Eigenschaften und Methoden.
                    </p>

                    <code-block lang="javascript">
                        <![CDATA[
                            let keys = Object.keys(item);
                            console.log(keys);
                            // => [ 'name', 'price', 'author', 'isbn', 'printDescription' ]

                            let values = Object.values(item);
                            console.log(values);
                            // => [ 'Schrödinger programmiert Java', 44.9, 'Philip Ackermann', '978-3-8362-4583-8', [Function: printDescription] ]

                            let entries = Object.entries(item);
                            console.log(entries);
                            // [
                            //   [ 'name', 'Schrödinger programmiert Java' ],
                            //   [ 'price', 44.9 ],
                            //   [ 'author', 'Philip Ackermann' ],
                            //   [ 'isbn', '978-3-8362-4583-8' ],
                            //   [ 'printDescription', [Function: printDescription] ]
                            // ]
                        ]]>
                    </code-block>
                </chapter>
            </chapter>
        </chapter>

        <chapter id="grundlagen-aenderung-verhindern" title="Änderung an Objekten verhindern">
            <p>
                In einigen Fällen kann es sinnvoll sein, Objekte vor Änderungen zu schützen, sprich zu verhindern, dass
                einem Objekt neue Eigenschaften oder Methoden hinzugefügt werden. JavaScript bietet dazu drei
                verschiedene Möglichkeiten an.
            </p>

            <img alt="Änderung an Objekten verhindern" src="js-sprachkern-oop-aenderung-an-objekten-verhindern.png"/>

            <chapter id="grundlagen-aenderung-verhindern-prevent-extensions" title="Erweiterung an Objekten verhindern">
                <p>
                    Übergibt man der Methode <code>Object.preventExtensions()</code> ein Objekt, so kann man
                    anschließend keine Erweiterungen am jeweiligen Objekt vornehmen. Versucht man dies dennoch, kommt es
                    zu einem Fehler. Immer noch erlaubt bleibt jedoch das Ändern der Eigenschaftswerte und
                    Eigenschaftsattribute.
                </p>

                <p>
                    Mit der Methode <code>Object.isExtenible()</code> kann man überprüfen, ob das übergebene Objekt
                    erweiterbar ist.
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        let max = {
                          firstName: 'Max',
                          lastName: 'Mustermann'
                        }

                        console.log(Object.isExtensible(max));    // => true
                        Object.preventExtensions(max);
                        console.log(Object.isExtensible(max));    // => false
                        max.weight = 88; // => TypeError: Can't add property weight, object is not extensible
                    ]]>
                </code-block>
            </chapter>

            <chapter id="grundlagen-aenderung-verhindern-seal" title="Objekte versiegeln">
                <p>
                    Mit der Methode <code>Object.seal()</code> lässt sich das übergebene Objekt versiegeln. Versigelte
                    Objekte sind nicht erweiterbar, zusätzlich aber auch ihre bestehenden Eigenschaften nicht
                    konfigurierbar – nur die Werte der Eigenschaften lassen sich ändern. Ob ein Objekt versigelt ist
                    lässt sich mit <code>Object.isSealed()</code> überprüfen. Da versiegelte Objekte zugleich nicht
                    erweiterbar sind, liefert die Methode <code>Object.isExtensible()</code> bei einem versigelten
                    Objekt den Wert <code>false</code> zurück.
                </p>
            </chapter>

            <chapter id="grundlagen-aenderung-verhindern-freeze" title="Objekte einfrieren">
                <p>
                    Mit der Methode <code>Object.freeze()</code> lässt sich das übergebene Objekt einfrieren. Bei
                    eingefrorenen Objekten lassen sich nur mehr die Objekteigenschaften und Objektmethoden abrufen. Es
                    können keine neuen Eigenschaften und Methoden hinzugefügt werden, die Eigenschaftsattribute sowie
                    die Eigenschaftswerte können auch nicht verändert werden. Über die Methode
                    <code>Object.isFrozen()</code> lässt sich ermitteln, ob ein Objekt eingefroren ist. Der Aufruf von
                    <code>Object.isExtensible()</code> gibt für das eingefrorene Objekt den Wert <code>false</code>
                    zurück, der Aufruf von <code>Object.isSealed()</code> den Wert <code>true</code>, weil eingefrorene
                    Objekte immer auch versiegelt sind und nicht erweiterbar.
                </p>
            </chapter>
        </chapter>
    </chapter>

    <chapter id="prinzipien" title="Prinzipien der Objektorientierung">
        <p>
            Die Tatsache allein allerdings, dass man mit Objekten arbeitet, bedeutet nicht zwangsläufig, dass man auch
            objektorientiert arbeitet. Vielmehr liegen der objektorientierten Programmierung vier wesentliche Prinzipien
            zugrunde:
        </p>

        <list>
            <li>
                <b>Abstraktion:</b> Abstraktes Verhalten von Objekten wird in Klassen oder Prototypen zusammengefasst.
                Mehr dazu unter
                <a href="swe-pk-paradigmen-oop.topic#konzepte-abstraktion-generalisierung">
                    Abstraktion &amp; Generalisierung / Spezialisierung
                </a>.
            </li>
            <li>
                <b>Datenkapselung:</b> Eigenschaften und Methoden werden in Form von Klassen oder Prototypen gekapselt
                und vor dem Zugriff von außen verborgen. Mehr dazu unter <a href="">Kapselung</a> und
                <a href="swe-pk-paradigmen-oop.topic#konzepte-sichtbarkeit">Geheimprinzip / Sichtbarkeit</a>
            </li>
            <li>
                <b>Vererbung:</b> Eigenschaften und Methoden können von einer Klasse an eine andere Klasse oder von
                einem Objekt (dem Prototyp) an ein anderes Objekt vererbt werden. Mehr dazu unter
                <a href="swe-pk-paradigmen-oop.topic#konzepte-vererbung">Vererbung</a>
            </li>
            <li>
                <b>Polymorphie:</b> Objekte können abhängig von ihrer Verwendung unterschiedliche Typen annehmen. Mehr
                dazu unter
                <a href="swe-pk-paradigmen-oop.topic#konzepte-polymorphismus">Polymorphismus</a>
            </li>
        </list>

        <p>
            JavaScript verhält sich bezüglich der objektorientierten Programmierung nicht so eindeutig wie andere
            Sprachen (beispielsweise Java). Vielmehr gibt es in JavaScript verschiedene Techniken, um objektorientiert
            zu programmieren. Prinzipiell unterscheidet man dabei zwischen folgenden Techniken:
        </p>

        <list>
            <li>
                <b>Prototypische Objektorientierung</b> – dies ist die Art der Objektorientierung, die der Sprache
                JavaScript am natürlichsten ist, weil hierbei lediglich Objekte zum Einsatz kommen.
            </li>
            <li>
                <b>Pseudoklassische Objektorientierung</b> – hierbei handelt es sich um eine Art der Objektorientierung,
                bei der man so tut, als wäre JavaScript eine klassenbasierte Programmiersprache. Zum Einsatz kommen
                hierbei Konstruktorfunktionen.
            </li>
            <li>
                <b>Objektorientierung mit Klassensyntax</b> – diese Art der Objektorientierung stellt eine syntaktische
                Vereinfachung der pseudoklassischen Objektorientierung dar.
            </li>
        </list>

        <p>
            Die Art der Objektorientierung hat je nach Art der Programmiersprache ebenfalls unterschiedliche
            Bezeichnungen: In der klassenbasierten Programmierung spricht man von klassenbasierter Objektorientierung,
            in der objektbasierten bzw. prototypenbasierten Programmierung spricht man von prototypischer
            Objektorientierung. Ein Beispiel für eine klassenbasierte Programmiersprache ist die Programmiersprache
            Java. JavaScript dagegen ist, wohlgemerkt, <b>keine klassenbasierte Programmiersprache</b>, auch wenn es
            seit ES6/ES2015 eine Klassensyntax gibt. JavaScript ist vielmehr eine <b>objektbasierte
            Programmiersprache</b>: Objektinstanzen werden hier nicht auf Basis von Klassen, sondern auf Basis von
            anderen Objekten erstellt. Diese anderen Objekte stellen dann den sogenannten Prototyp dar.
        </p>

        <chapter id="prinzipien-prototypen" title="Prototypische Objektorientierung">
            <p>
                JavaScript ist eine prototypenbasierte Sprache, kennt also keine Klassen, zumindest keine echten. Alles
                in JavaScript basiert dagegen auf Objekten. Jedes Objekt in JavaScript basiert auf einem Prototyp.
                Zumindest fast jedes Objekt, denn einige Objekte wie beispielsweise die Mutter aller Objekte
                <code>Object</code> oder Objekte, deren Prototyp explizit auf <code>null</code> gesetzt wurde, haben
                keinen Prototyp. Jedes Objekt kann zudem selbst als Vorlage, also als Prototyp für ein anderes Objekt
                herhalten. In diesem Fall erbt das neue Objekt die Eigenschaften und Methoden vom Prototyp. Übersetzt in
                die klassenbasierte Programmierung entspricht das also in etwa dem Erstellen einer Unterklasse.
            </p>

            <p>
                Bei der prototypischen Vererbung erben nicht Klassen von Klassen, sondern Objekte von Objekten.
            </p>

            <p>
                Der Prototyp eines Objekts ist in der Eigenschaft <code>__proto__</code> hinterlegt. Erstmals
                implementiert wurde diese Eigenschaft im Firefox-Browser als Alias zu der internen Eigenschaft
                <code>[[Prototype]]</code> und seitdem von fast allen Browsern bzw. Laufzeitumgebungen übernommen.
                Fest in den ECMAScript-Standard übernommen wurde die Eigenschaft aber erst mit der Version 6. Statt
                jedoch direkt auf die Eigenschaft zuzugreifen, ist es üblich und empfehlenswert, den Prototyp eines
                Objekts über die Methode <code>Object.getPrototypeOf()</code> zu ermitteln. Außerdem ist es möglich, mit
                <code>Object.isPrototypeOf()</code> zu überprüfen, ob ein Objekt der Prototyp eines anderen Objekts ist.
            </p>

            <code-block lang="javascript">
                <![CDATA[
                    let animal = {
                      name: '',  color: 'Braun',  age: 0,
                      eat: function(food) { /* ... */ },
                      drink: function(drink) { /* ... */ }
                    }
                    let cat = Object.create(animal);
                    let dog = Object.create(animal);
                ]]>
            </code-block>

            <p>
                Um ein Objekt auf Basis eines Prototyps zu definieren, wird die Methode <code>Object.create()</code>
                verwendet. Zur Erinnerung: Beim Erstellen eines Objekts über die Objekt-Literal-Schreibweise kann kein
                Prototyp angegeben werden. Die Objekte erben die Eigenschaften und Methoden des Prototyps. Das bedeutet,
                dass die Objekte <code>cat</code> und <code>dog</code> im Beispiel beide den Wert <code>'Braun'</code>
                für die Eigenschaft <code>color</code> haben.
            </p>

            <code-block lang="javascript">
                <![CDATA[
                    cat.meow = function() { /* ... */ }
                ]]>
            </code-block>

            <p>
                Es ist selbstverständlich auch möglich, dass an Objekten, die von einem Prototyp erben, zusätzliche
                Eigenschaften und Methoden definiert werden können. Jene Methoden und Eigenschaften stehen dann
                natürlich nur auf den jeweiligen Objekten zur Verfügung. Die Methode <code>meow()</code> aus dem
                Beispiel kann beispielsweise nicht vom Objekt dog aufgerufen werden.
            </p>

            <code-block lang="javascript">
                <![CDATA[
                    cat.eat = function() { /* ... */ }
                ]]>
            </code-block>

            <p>
                Klassen bzw. im Fall der prototypischen Objektorientierung Objekte, die in der Vererbungshierarchie
                weiter unten stehen, sind spezieller als solche, die in der Vererbungshierarchie weiter oben stehen.
                Oder umgekehrt formuliert: Klassen/Objekte, die in der Hierarchie weiter oben stehen, sind abstrakter
                als solche weiter unten. Spezielleres Verhalten kann dabei zum einen dadurch entstehen, dass Klassen
                bzw. Objekten neue Methoden hinzugefügt werden, zum anderen aber auch, dass <b>geerbte Methoden
                überschrieben</b> werden. Das bedeutet, dass dem Objekt <code>cat</code> eine Methode
                <code>eat()</code> hinzugefügt werden kann, obwohl es diese bereits vom Prototyp <code>animal</code>
                geerbt hat.
            </p>

            <chapter id="prinzipien-prototypen-kette" title="Die Prototypkette">
                <p>
                    Objekte erben Eigenschaften und Methoden von ihrem Prototyp bzw. allen vorangegangenen Prototypen
                    über die sogenannte Prototypenkette. Vom Ablauf her funktioniert das wie folgt: Wird auf eine
                    Eigenschaft bzw. Methode eines Objekts zugegriffen, prüft der JavaScript-Interpreter zunächst, ob
                    das entsprechende Objekt über die jeweilige Eigenschaft/Methode verfügt. Ist dies der Fall, wird die
                    Eigenschaft/Methode verwendet, ist dies dagegen nicht der Fall, wird auf den Prototyp des Objekts
                    (welcher ja u. a. in der <code>__proto__</code>-Eigenschaft hinterlegt ist) zugegriffen. Ist die
                    Eigenschaft/Methode auch dort nicht vorhanden, wird im Prototyp des Prototyps geschaut usw., bis
                    irgendwann das Basisobjekt Object erreicht wird.
                </p>

                <p>
                    Die Prototypenkette bezeichnet also eine Kette von Objekten, die jeweils als Prototyp für die
                    nachfolgenden Objekte in dieser Kette dienen.
                </p>
            </chapter>

            <chapter id="prinzipien-prototypen-methoden" title="Methoden eines Prototypen aufrufen">
                <p>
                    Um eine Methode des Prototyps eines Objekts aufzurufen, muss man zunächst an den Prototyp des
                    Objekts gelangen. Dazu hat man prinzipiell zwei Möglichkeiten: Zum einen ist der Prototyp eines
                    Objekts ja, wie gesagt, in dessen Eigenschaft <code>__proto__</code> hinterlegt, zum anderen kann
                    man über die Methode <code>Object.getPrototypeOf()</code> den Prototyp eines Objekts ermitteln.
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        cat.eat = function(food) {
                          this.__proto__.eat.call(this, food);              // Methode (1)
                          Object.getPrototypeOf(this).eat.call(this, food); // Methode (2)
                        }
                    ]]>
                </code-block>

                <p>
                    In beiden Fällen wird zunächst über genannte Wege auf den Prototyp des aktuellen Objekts
                    zugegriffen, dann auf die Methode <code>eat()</code> und auf dieser wiederum die Methode
                    <code>call()</code> aufgerufen. Diese Methode, die standardmäßig für alle Funktionen bzw.
                    Methoden zur Verfügung steht, macht nichts anderes, als die jeweilige Funktion/Methode in einem
                    bestimmten Kontext auszuführen. Diesen Ausführungskontext übergibt man ihr dabei als ersten
                    Parameter, optional können, wie im Beispiel gezeigt, weitere Parameter übergeben werden, mit denen
                    die ursprüngliche Funktion/Methode aufgerufen werden soll.
                </p>
            </chapter>
        </chapter>

        <chapter id="prinzipien-pseudoklassisch" title="Pseudoklassische Objektorientierung">
            <p>
                Im Gegensatz zur prototypischen Objektorientierung basiert die pseudoklassische Objektorientierung auf
                dem Einsatz von Konstruktorfunktionen. Die Idee dabei ist, dass sich die objektorientierte
                Programmierung mit JavaScript so anfühlt, als würde man klassenbasiert programmieren.
            </p>

            <table style="none">
                <tr>
                    <td>
                        <p>
                            <b>
                                Konstruktor Funktion definieren
                            </b>
                        </p>

                        <p>
                            Innerhalb einer Konstruktorfunktion bezieht sich dann das Schlüsselwort <code>this</code>
                            auf das Objekt, welches durch den Aufruf der Konstruktorfunktion erzeugt wird.
                        </p>
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                function Animal(name, color, age) {
                                  this.name = name;
                                  this.color = color;
                                  this.age = age;
                                };
                            ]]>
                        </code-block>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p>
                            <b>
                                Objektinstanzen erzeugen
                            </b>
                        </p>

                        <p>
                            Um unter Verwendung einer Konstruktorfunktion eine neue Objektinstanz zu erzeugen, ruft man
                            die Konstruktorfunktion mit dem Schlüsselwort <code>new</code> auf.
                        </p>
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                let fish = new Animal('Fischi', 'Grün', 2);
                                console.log(fish.name); // => "Fischi"
                            ]]>
                        </code-block>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p>
                            <b>
                                Methoden definieren
                            </b>
                        </p>

                        <p>
                            Um Methoden zu erstellen, die allen Objektinstanzen, die mithilfe einer Konstruktorfunktion
                            erstellt werden, gemeinsam sind, definiert man diese an dem Objekt, welches den durch die
                            Konstruktorfunktion erzeugten Objektinstanzen als Prototyp dient. Dieses Objekt ist in der
                            Eigenschaft <code>prototype</code> der entsprechenden Konstruktorfunktion hinterlegt.
                        </p>
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                Animal.prototype.eat = function(food) {
                                  console.log('Mmpf mmpf, ' + food + '!');
                                }
                                Animal.prototype.drink = function(drink) {
                                  console.log('Mmmmmmh, ' + drink + '!');
                                }
                            ]]>
                        </code-block>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p>
                            <b>
                                Von Objekten ableiten
                            </b>
                        </p>

                        <img alt="Von Objekten ableiten" src="js-sprachkern-oop-von-objekten-ableiten.png"/>
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                function Dog(name, color, age, type) {
                                  Animal.call(this, name, color, age);
                                  this.type = type;
                                };
                                Dog.prototype = new Animal();
                                Dog.prototype.constructor = Dog;
                                Dog.prototype.bark = function() {
                                  console.log('Wuff wuff');
                                }
                                let bello = new Dog('Bello', 'Weiß', 2, 'Malteser');
                            ]]>
                        </code-block>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p>
                            <b>
                                Konstruktor der »Oberklasse« aufrufen
                            </b>
                        </p>

                        <p>
                            Um den Konstruktor einer »Oberklasse« aufzurufen, muss lediglich die entsprechende
                            Konstruktorfunktion über die Methode <code>call()</code> aufgerufen und dabei
                            <code>this</code> als Ausführungskontext sowie optional weitere Parameter übergeben werden.
                        </p>
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                function Dog(name, color, age, type) {
                                  Animal.call(this, name, color, age);  this.type = type;
                                };
                            ]]>
                        </code-block>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p>
                            <b>
                                Methoden überschreiben
                            </b>
                        </p>

                        <p>
                            Um eine Methode in einer »Unterklasse« zu überschreiben, definieren Sie die entsprechende
                            Methode einfach am Prototyp, die der entsprechenden Konstruktorfunktion der »Unterklasse«
                            zugrunde liegt.
                        </p>
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                function VegetarianDog(name, color, age, type) {
                                  Dog.call(this, name, color, age, type);
                                };
                                VegetarianDog.prototype.eat = function(food) {
                                  /* ... */
                                }
                            ]]>
                        </code-block>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p>
                            <b>
                                Methoden der »Oberklasse« aufrufen
                            </b>
                        </p>

                        <p>
                            Der Aufruf einer Methode der »Oberklasse« funktioniert wie schon der Aufruf von
                            Konstruktoren unter Verwendung der Methode <code>call()</code>.
                        </p>
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                VegetarianDog.prototype.eat = function(food) {
                                  Dog.prototype.eat.call(this, food);
                                }
                            ]]>
                        </code-block>
                    </td>
                </tr>
            </table>
        </chapter>

        <chapter id="prinzipien-klassensyntax" title="Objektorientierung mit Klassensyntax">
            <p>
                Seit ES6/ES2015 hat auch eine neue Klassensyntax in den ECMAScript-Standard Einzug gehalten. Diese
                Klassensyntax ermöglicht zwar keine echte klassenbasierte Programmierung, fühlt sich aber u.a. aufgrund
                der verwendeten Schlüsselwörter und Syntax relativ ähnlich an. Eigentlich wird durch die Klassensyntax
                aber lediglich etwas von der Komplexität der pseudoklassischen Objektorientierung genommen, weil im
                Hintergrund nach wie vor Objekte und Prototypen werkeln.
            </p>

            <table>
                <tr>
                    <td>
                        <p>
                            <b>
                                Klassen definieren
                            </b>
                        </p>

                        <p>
                            Um in JavaScript eine »Klasse« zu definieren, wird das Schlüsselwort class verwendet. Hinter
                            dieses Schlüsselwort wird der Namen der Klasse, gefolgt von einem Paar geschweifter
                            Klammern, die den Körper der Klasse (den Klassenkörper) definieren geschrieben. Innerhalb
                            dieses Klassenkörpers können anschließend die Methoden der Klasse definiert werden
                            (Eigenschaften dagegen können an dieser Stelle nicht angegeben werden).
                        </p>

                        <p>
                            Die Methode mit dem Namen <code>constructor()</code> entspricht dem Konstruktor der
                            jeweiligen Klasse und wird immer dann aufgerufen, wenn ein Objekt der Klasse mit dem
                            Schlüsselwort <code>new</code> instanziiert wird. Zurückgeliefert wird von
                            <code>constructor()</code> nämlich implizit eine neue Objektinstanz. Innerhalb der
                            Methode <code>constructor()</code> kann über das Schlüsselwort <code>this</code> auf
                            diese Objektinstanz zugegriffen werden. Das ist wiederum dann auch die Stelle, an der
                            Eigenschaften definiert werden können.
                        </p>
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                class Animal {
                                  constructor(name, color, age) {
                                    this.name = name;
                                    this.color = color;
                                    this.age = age;
                                  }
                                  eat(food) { /* ... */  }
                                  drink(drink) { /* ... */ }
                                  toString() { /* ... */ }
                                }
                            ]]>
                        </code-block>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p>
                            <b>
                                Objektinstanzen erzeugen
                            </b>
                        </p>

                        <p>
                            Um eine Objektinstanz einer »Klasse« zu erzeugen, wird das Schlüsselwort <code>new</code>
                            verwendet.
                        </p>
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                let fish = new Animal('Fischi', 'Grün', 2);
                            ]]>
                        </code-block>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p>
                            <b>
                                Getter und Setter definieren
                            </b>
                        </p>

                        <p>
                            Über die Schlüsselwörter <code>get</code> und <code>set</code> können Getter- und
                            Setter-Methoden an Objekten definiert werden. Die gleichen Schlüsselwörter können auch in
                            Kombination mit »Klassen« verwendet werden, um dort Getter und Setter zu definieren.
                        </p>

                        <list>
                            <li>
                                Getter-Methoden können keine Argumente annehmen!
                            </li>
                            <li>
                                Setter-Methoden können nur ein Argument annehmen!
                            </li>
                            <li>
                                Getter- und Setter-Methoden werden nicht wie normale Funktionen aufgerufen, sondern wie
                                eine Wertzuweisung einer Eigenschaft einer Variable (setter) oder als Variable (getter).
                            </li>
                        </list>

                        <p>
                            Zu beachten ist außerdem, dass der Name der jeweiligen Getter- bzw. Setter-Methode nicht
                            gleich der entsprechenden Eigenschaft ist, um eine Endlosrekursion, einen damit verbundenen
                            Stacküberlauf und damit den Absturz des jeweiligen Programms zu verhindern.
                        </p>
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                class Animal {
                                  constructor(name, color, age) {
                                    this.name = name;
                                    this.color = color;
                                    this.age = age;
                                  }
                                  eat(food) { /* ... */  }
                                  drink(drink) { /* ... */ }
                                  toString() { /* ... */ }
                                  get name() { return this._name; }
                                  set name(name) { this._name = name; }
                                  /* ... */
                                }
                            ]]>
                        </code-block>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p>
                            <b>
                                Von »Klassen« ableiten
                            </b>
                        </p>

                        <p>
                            Über das Schlüsselwort <code>extends</code> ist es möglich, dass eine »Klasse« von einer
                            anderen »Klasse« erbt bzw. ableitet. Das Schlüsselwort schreibt man dabei einfach hinter die
                            (neue) »Klasse«, die erben soll, dem Schlüsselwort folgt dann der Name der »Klasse«, von der
                            geerbt werden soll. Die Klasse von der geerbt werden soll, muss nicht zwingend mit der
                            Klassensyntax geschrieben worden sein es muss sich nur um ein Objekt handeln.
                        </p>

                        <p>
                            Innerhalb des Konstruktors der ableitenden »Klasse« kann per <code>super()</code> der
                            Konstruktor der »Oberklasse« (der Elternkonstruktor) aufgerufen werden. Es ist übrigens sehr
                            wichtig, dies zu tun, bevor innerhalb des Konstruktors auf <code>this</code> zugegriffen
                            wird. Ansonsten kommt es zu einem Fehler. Das Gleiche gilt, wenn man innerhalb eines
                            Konstruktors den Aufruf des Elternkonstruktors ganz weglässt. Es ist allerdings möglich, den
                            Konstruktor einer »Klasse«, sprich die <code>constructor()</code>-Methode, ganz wegzulassen.
                            In diesem Fall wird intern implizit ein Konstruktor verwendet, der alle Parameter an den
                            Elternkonstruktor weiterleitet.
                        </p>
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                class Dog extends Animal {
                                  constructor(name, color, age, type) {
                                    super(name, color, age);
                                    this.type = type;
                                  }
                                  get type() { return this._type; }
                                  set type(type) { this._type = type; }
                                  bark() { /* ... */ }
                                }
                            ]]>
                        </code-block>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p>
                            <b>
                                Methoden überschreiben
                            </b>
                        </p>

                        <p>
                            Um eine Methode in einer »Unterklasse« zu überschreiben, definiert man einfach eine
                            entsprechende Methode mit gleichem Namen wie die zu überschreibende Methode.
                        </p>
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                class Dog extends Animal {
                                  constructor(name, color, age, type) {
                                    super(name, color, age);
                                    this.type = type;
                                  }
                                  get type() { return this._type; }
                                  set type(type) { this._type = type; }
                                  eat(food) { /* ... */ }
                                  bark() { /* ... */ }
                                }
                            ]]>
                        </code-block>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p>
                            <b>
                                Methoden der »Oberklasse« aufrufen
                            </b>
                        </p>

                        <p>
                            Möchte man innerhalb einer Methode eine andere Methode der gleichen »Klasse« aufrufen, kann
                            man dies über die Verwendung des Schlüsselwortes <code>this</code> erreichen. Soll dagegen
                            innerhalb einer Methode gezielt eine Methode der »Oberklasse« aufgerufen werden, kann das
                            Schlüsselwort super verwendet werden, welches sozusagen eine Referenz auf die »Oberklasse«
                            darstellt.
                        </p>

                        <p>
                            Es zwar auch per <code>this</code> auf Methoden der »Oberklasse« zugegriffen werden, aber
                            nur, wenn es die jeweilige Methode nicht in der »Unterklasse« gibt. Ist dies dagegen nicht
                            der Fall, wird bei Zugriff per <code>this</code> die Methode der »Unterklasse« verwendet.
                        </p>
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                class Dog extends Animal {
                                  constructor(name, color, age, type) {
                                    super(name, color, age);
                                    this.type = type;
                                  }
                                  get type() { return this._type; }
                                  set type(type) { this._type = type; }
                                  eat(food) { return super.eat(food); }
                                  bark() { /* ... */ }
                                }
                            ]]>
                        </code-block>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p>
                            <b>
                                Statische Methoden definieren
                            </b>
                        </p>

                        <p>
                            Statische Methoden bezeichnen in der objektorientierten Programmierung solche Methoden, die
                            man direkt auf der Klasse aufruft und nicht auf einer Objektinstanz. Statische Methoden
                            eignen sich immer dann, wenn damit Funktionalität bereitgestellt werden soll, die thematisch
                            zu der jeweiligen Klasse gehört, aber nicht zwangsweise eine Objektinstanz voraussetzt. In
                            der Klassensyntax wird in JavaScript eine Methode als statisch definiert, indem ihr das
                            Schlüsselwort <code>static</code> vorangestellt wird. Anschließend kann die Methode direkt
                            über die »Klasse« aufgerufen werden.
                        </p>
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                class Animal {
                                  /* ... */
                                  static getAnimalColors() {
                                    return {
                                      WHITE: 'Weiß',
                                      BLACK: 'Schwarz',
                                      BROWN: 'Braun',
                                      GREEN: 'Grün',
                                      YELLOW: 'Gelb',
                                      ORANGE: 'Orange'
                                    }
                                  }
                                  /* ... */
                                }
                                let bird = new Animal('Birdie', Animal.getAnimalColors().BLACK, 5);
                            ]]>
                        </code-block>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p>
                            <b>
                                Statische Eigenschaften definieren
                            </b>
                        </p>

                        <p>
                            Neben statischen Methoden gibt es in der Objektorientierung auch das Konzept der statischen
                            Eigenschaften. Analog zu statischen Methoden werden statische Eigenschaften direkt auf einer
                            Klasse definiert, und man benötigt keine Objektinstanz, um auf diese Eigenschaften
                            zuzugreifen.
                        </p>

                        <p>
                            In der Klassensyntax in JavaScript war es bis ES2022 nicht möglich, statische Eigenschaften
                            explizit innerhalb des Klassenkörpers zu definieren (es war auch noch nicht mal möglich,
                            überhaupt Eigenschaften auf die gleiche Weise wie Methoden direkt innerhalb des
                            Klassenkörpers zu definieren). Stattdessen wurden statische Eigenschaften als Eigenschaften
                            der »Klasse« definiert. Eine gebräuchliche Konvention ist es hierbei, die Namen der
                            statischen Eigenschaften in Großbuchstaben zu schreiben.
                        </p>
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                Animal.ANIMAL_COLORS = {
                                  WHITE: 'Weiß',
                                  BLACK: 'Schwarz',
                                  BROWN: 'Braun',
                                  GREEN: 'Grün',
                                  YELLOW: 'Gelb',
                                  ORANGE: 'Orange'
                                }
                                let bird = new Animal('Birdie', Animal.ANIMAL_COLORS.BLACK, 5);
                            ]]>
                        </code-block>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p>
                            <b>
                                Eigenschaften im Klassenkörper
                            </b>
                        </p>

                        <p>
                            Seit einer neueren Version des EcmaScript-Standards (= EcmaScript 2022) wurde die
                            Deklaration von Eigenschaften innerhalb des Klassenkörpers eingeführt. Diese können als
                            <b>public</b> und <b>privat</b> deklariert werden. Eigenschaften in private werden mit
                            dem Prefix <code>#</code> angegeben.
                        </p>
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                class Vehicle {
                                  status = "unavailable";
                                  #longitude;
                                  #latitude;
                                  constructor(/*...*/) {/*...*/}
                                  set position(/*...*/) {/*...*/}
                                  get position() {
                                    return {
                                      latitude: this.#latitude;
                                      longitude: this.#longitude;
                                    };
                                  };
                                };
                            ]]>
                        </code-block>
                    </td>
                </tr>
            </table>

            <note>
                <p>
                    <b>
                        Statische Methoden sind Methoden am Funktionsobjekt
                    </b>
                </p>

                <p>
                    Da die Klassensyntax inklusive des Schlüsselwortes <code>static</code> ja letztendlich nur eine
                    syntaktische Verfeinerung der pseudoklassischen Objektorientierung darstellt, sind auch statische
                    Methoden eigentlich Methoden, die an dem jeweiligen Funktionsobjekt definiert werden, und statische
                    Eigenschaften eigentlich Eigenschaften des Funktionsobjekts.
                </p>
            </note>
        </chapter>
    </chapter>

    <chapter id="globale-objekte" title="Globale Objekte - »built-in objects«">

        <chapter id="globale-objekte-primitiver-datentypen" title="Objekte primitiver Datentypen">

            <chapter id="globale-objekte-boolean" title="Boolean">

            </chapter>

            <chapter id="globale-objekte-number" title="Number">

            </chapter>

            <chapter id="globale-objekte-string" title="String">

                <chapter id="globale-objekte-string-verkettung" title="Verkettung von Strings">

                </chapter>

                <chapter id="globale-objekte-string-template" title="Template Strings">

                </chapter>

                <chapter id="globale-objekte-string-backslash-und-zeilenumbrueche" title="Backslash und Zeilenumbrüche">

                </chapter>

                <chapter id="globale-objekte-string-methoden" title="Methoden für Strings">

                </chapter>
            </chapter>

            <chapter id="globale-objekte-primitiver-datentypen-pad-start-und-end"
                     title="Die Methoden padStart() und padEnd()">

            </chapter>

            <chapter id="globale-objekte-date" title="Date - mit Datum und Zeit arbeiten">

            </chapter>

            <chapter id="globale-objekte-primitiver-datentypen-wrapperobjekte"
                     title="Wrapperobjekte für primitive Datentypen">

            </chapter>
        </chapter>

        <chapter id="globale-objekte-array" title="Arrays">

            <chapter id="globale-objekte-array-erzeugen" title="Arrays erzeugen und initialisieren">

                <chapter id="globale-objekte-array-erzeugen-konstruktorfunktion" title="Die Konstruktorfunktion">

                </chapter>

                <chapter id="globale-objekte-array-erzeugen-literal-schreibweise"
                         title="Die Array-Literal-Schreibweise">

                </chapter>

                <chapter id="globale-objekte-array-erzeugen-typen" title="Unterschiedliche Typen in Arrays">

                </chapter>
            </chapter>

            <chapter id="globale-objekte-array-elemente" title="Auf Elemente eines Arrays zugreifen">

            </chapter>

            <chapter id="globale-objekte-array-funktionen" title="Funktionen für Arrays">

                <chapter id="globale-objekte-array-funktionen-liste" title="Liste der Funktionen">

                </chapter>
            </chapter>

            <chapter id="globale-objekte-array-higher-order-funktionen" title="Higher-Order-Funktionen">

            </chapter>

            <chapter id="globale-objekte-array-mehrdimensional"
                     title="Mehrdimensionale Arrays: 2D-, 3D-, ... nD-Arrays">

            </chapter>

            <chapter id="globale-objekte-array-als-stack" title="Arrays als Stack verwenden">

            </chapter>

            <chapter id="globale-objekte-array-als-queue" title="Arrays als Queue verwenden">

            </chapter>

            <chapter id="globale-objekte-array-in-zeichenketten-umwandeln" title="Arrays in Zeichenketten umwandeln">

            </chapter>
        </chapter>

        <chapter id="globale-objekte-math" title="Math – komplexe Berechnungen durchführen">

        </chapter>

        <chapter id="globale-objekte-regexp" title="RegExp – reguläre Ausdrücke">

        </chapter>
    </chapter>

    <chapter id="funktionen-als-referenztypen" title="Funktionen als Referenztypen">

        <chapter id="funktionen-als-referenztypen-argumente" title="Funktionen als Argumente verwenden">

        </chapter>

        <chapter id="funktionen-als-referenztypen-return" title="Funktionen als Rückgabewerte verwenden">

        </chapter>

        <chapter id="funktionen-als-referenztypen-standardmethoden" title="Standardmethoden jeder Funktion">

            <chapter id="funktionen-als-referenztypen-standardmethoden-bind"
                     title="Objekte binden mit der Methode bind()">

            </chapter>

            <chapter id="funktionen-als-referenztypen-standardmethoden-call"
                     title="Funktionen aufrufen über die Methode call()">

            </chapter>

            <chapter id="funktionen-als-referenztypen-standardmethoden-apply"
                     title="Funktionen aufrufen über die Methode apply()">

            </chapter>
        </chapter>
    </chapter>

    <chapter id="quellen" title="Quellen">
        <tip>
            <b>(BUCH)</b>
            978-3836256971, "JavaScript", Philip Ackermann, 2019
        </tip>
    </chapter>
</topic>