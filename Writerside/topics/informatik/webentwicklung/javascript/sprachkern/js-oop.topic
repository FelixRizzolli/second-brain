<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
        SYSTEM "https://resources.jetbrains.com/writerside/1.0/xhtml-entities.dtd">
<topic id="js-oop"
       title="Objektorientierte Programmierung"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="https://resources.jetbrains.com/writerside/1.0/topic.v2.xsd">
    <show-structure depth="2" for="chapter,procedure"/>

    <!-- TODO: migrate from Confluence -->
    <chapter id="grundlagen" title="Grundlagen">
        <tip>
            Grundlegende Konzepte der objektorientierten Programmierung: <a href="swe-pk-paradigmen-oop.topic"/>
        </tip>

        <p>
            JavaScript ist eine Programmiersprache die das objektorientierte Programmierparadigma unterstützt.
        </p>

        <chapter id="grundlagen-instanceof" title="Der instanceof-Operator">
            <p>
                Der <code>instanceof</code>-Operator bestimmt, ob eine Variable von einem bestimmten Referenztyp ist.
                Als Rückgabewert liefert der Operator dabei einen booleschen Wert. <code>Object</code> ist der Typ, von
                dem alle anderen Referenztypen ableiten. Der <code>instanceof</code>-Operator liefert daher für alle
                Variablen beliebigen Referenztyps den Wert <code>true</code> zurück. Im Gegensatz zum
                <code>typeof</code>-Operator funktioniert der <code>instanceof</code>-Operator nur für Werte, die einen
                Referenztyp enthalten. Für Werte primitiven Datentyps dagegen liefert der Operator immer
                <code>false</code> zurück.
            </p>

            <p>
                Beispiele für Referenztypen wären:
            </p>

            <list type="bullet">
                <li>
                    der Referenztyp <code>Object</code>, der alle Arten von Objekten repräsentiert
                </li>
                <li>
                    der Referenztyp <code>Array</code>, der Arrays repräsentiert
                </li>
                <li>
                    der Referenztyp <code>RegExp</code>, der sogenannte reguläre Ausdrücke repräsentiert, mit denen man
                    innerhalb von Zeichenketten nach bestimmten Mustern suchen kann
                </li>
                <li>
                    der Referenztyp <code>Date</code>, der Datums- und Zeitangaben repräsentiert
                </li>
                <li>
                    der Referenztyp <code>Math</code>, mit dem sich komplexere Berechnungen durchführen lassen.
                </li>
            </list>

            <p>
                Darüber hinaus gibt es verschiedene sogenannte <b>Wrapperobjekte</b>, die den primitiven Datentypen
                zusätzliche Funktionalitäten bereitstellen.
            </p>
        </chapter>

        <chapter id="grundlagen-this" title="Das Schlüsselwort this">
            <p>
                Das Schlüsselwort <code>this</code> repräsentiert das Objekt, in dem es verwendet wird.
            </p>
        </chapter>

        <chapter id="grundlagen-objekte-erstellen" title="Objekte erstellen">
            <p>
                In JavaScript gibt es zwei Möglichkeiten Objekte zu erstellen: Das Erzeugen eines Objekts über die
                Konstruktorfunktion oder ober die Literal-Schreibweise. Aber welche Methode sollte verwendet werden?
            </p>

            <list type="bullet">
                <li>
                    Für einfache Objekte, die on-the-fly erstellt werden sollten, von denen nicht mehrere Instanzen
                    benötigt werden, ist die Objekt-Literal-Schreibweise gut geeignet.
                </li>
                <li>
                    Werden mehrere Objektinstanzen von einem Objekttyp erstellt, so ist die Klassensyntax die bessere
                    Wahl. Die Konstruktorfunktion wird mittlerweile nur noch in Ausnahmefällen verwendet.
                </li>
                <li>
                    Die Methode <code>Object.create()</code> kann verwendet werden, wenn die Klassensyntax nicht zur
                    Verfügung steht – wenn die Laufzeitumgebung noch keine ES6-Features unterstützt.
                </li>
            </list>

            <chapter id="grundlagen-objekte-erstellen-literal-schreibweise" title="Die Objekt-Literal-Schreibweise">
                <code-block lang="javascript">
                    <![CDATA[
                        let item = {
                          name: 'Professionell entwickeln mit JavaScript',
                          price: 49.90,
                          author: 'Philip Ackermann',
                          isbn: '978-3-8362-5687-2',
                          printDescription: function() {
                            console.log(this.author + ': ' + this.name);
                          }
                        }

                        console.log(item.name);    // "Professionell entwickeln mit JavaScript"
                        console.log(item.price);   // 49.90
                        console.log(item.author);  // "Philip Ackermann"
                        console.log(item.isbn);    // "978-3-8362-5687-2"
                        item.printDescription();   // "Philip Ackermann: Professionell entwickeln mit JavaScript"
                    ]]>
                </code-block>
            </chapter>

            <chapter id="grundlagen-objekte-erstellen-konstruktorfunktion" title="Konstruktorfunktion">
                <p>
                    Eine Funktion wird erst dadurch zu einer Konstruktorfunktion, dass man sie über das Schüsselwort
                    <code>new</code> aufruft. Ruft man eine Funktion als Konstrktorfunktion auf, ist innerhalb der
                    Funktion keine <code>return</code>-Anweisung notwendig. Stattdessen wird eine neue Objektinstanz
                    zurückgegeben. Eine Konstruktorfunktion kann mehrfach verwendet werden, um verschiedene
                    Objektinstanzen zu erzeugen. Bei der Literal-Schreibweise dagegen trifft dies nicht zu, hier werden
                    immer einzelne Objekte erstellt.
                </p>

                <note>
                    Prinzipiell ist es auch möglich, eine als Konstruktorfunktion gedachte Funktion als »normale«
                    Funktion, sprich ohne vorangestelltes <code>new</code>, aufzurufen. Umgekehrt können Sie »normalen«
                    Funktionen auch ein <code>new</code> voranstellen und sie somit als Konstruktorfunktion aufrufen.
                    Allerdings macht beides in der Regel keinen Sinn.
                </note>

                <p>
                    Der Konvention folgend, beginnen Funktionen, die als Konstruktorfunktionen aufgerufen werden können,
                    mit einem Großbuchstaben bzw., genauer gesagt: Sie folgen der Upper-CamelCase-Schreibweise, bei der
                    ja – wenn ein Funktionsname aus mehreren Wörtern besteht – jedes Wort mit einem Großbuchstaben
                    beginnt.
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        function Item(name, price, author, isbn) {
                          this.name = name;
                          this.price = price;
                          this.author = author;
                          this.isbn = isbn;
                          this.printDescription = function() {
                            console.log(this.author + ': ' + this.name);
                          }
                        }

                        let item = new Item(
                          'Professionell entwickeln mit JavaScript',
                          49.90,
                          'Philip Ackermann',
                          '978-3-8362-5687-2'
                        );

                        console.log(item.name);    // "Professionell entwickeln mit JavaScript"
                        console.log(item.price);   // 49.90
                        console.log(item.author);  // "Philip Ackermann"
                        console.log(item.isbn);    // "978-3-8362-5687-2"
                        item.printDescription();   // "Philip Ackermann: Professionell entwickeln mit JavaScript"
                    ]]>
                </code-block>

                <img alt="Konstruktorfunktion" src="js-sprachkern-oop-konstruktorfunktion.png"/>

                <p>
                    Konstrukterfunktionen werden auch beispielsweise verwendet, wenn ein neues Array mit
                    <code>new Array()</code> erstellt wird oder ein Fehlerobjekt mit <code>new Error()</code>.
                </p>
            </chapter>

            <chapter id="grundlagen-objekte-erstellen-prototypen" title="Prototypen">
                <p>
                    Jede Konstruktorfunktion verwaltet intern einen sogenannten Prototyp, sprich ein Objekt, welches als
                    Basis für die Konstruktorfunktion zu erzeugenden Objekte dient. Dieser Prototyp ist der Funktion in
                    der Eigenschaft <code>prototype</code> hinterlegt. Wird nun ein Objekt mit einer solchen
                    Konstruktorfunktion erzeugt, basiert das Objekt also auf dem dort hinterlegten Prototyp.
                </p>

                <p>
                    Nach dem Erzeugen des Objekts kann der Prototyp entweder über die Eigenschaft <code>__proto__</code>
                    des Objekts über die Methode <code>Object.getPrototypeOf()</code> ermittelt werden. Über die
                    Eigenschaft <code>constructor</code> kann eine Objektinstanz außerdem bestimmt werden, mit welcher
                    Konstruktorfunktion es erzeugt wurde.
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        console.log(Item.prototype);               // Item {}
                        console.log(item.__proto__);               // Item {}
                        console.log(Object.getPrototypeOf(item));  // Item {}
                        console.log(item.constructor);             // function Item(...)
                    ]]>
                </code-block>

                <img alt="Prototypen" src="js-sprachkern-oop-prototypen.png"/>

                <p>
                    Mit dem <code>instanceof</code>-Operator lässt sich überprüfen, ob ein Objekt mit einer
                    bestimmten Konstruktorfunktion erzeugt wurde. Wurde beispielsweise das Objekt <code>item</code> mit
                    der Konstruktorfunktion <code>Item()</code> erzeugt, liefert der Ausdruck item <code>instanceof
                    Item</code> den Wert <code>true</code>. Im Detail ist der Sachverhalt bei der Verwendung einer
                    Konstruktorfunktion und der Anwendung des <code>instanceof</code>-Operators etwas komplizierter:
                    Prototypen können nämlich auch ihrerseits Prototypen haben, was dann zu einer ganzen Kette von
                    Prototypen, der sogenannten Prototypenkette, führt. Der <code>instanceof</code>-Operator prüft
                    daher, genauer gesagt, ob das jeweilige Objekt auf einem der Prototypen in der prototypenkette
                    basiert.
                </p>
            </chapter>

            <chapter id="grundlagen-objekte-erstellen-klassensyntax" title="Klassensyntax aus ES6">
                <p>
                    Klassen wurden in JavaScript mit ECMAScript 6 eingeführt. Klassen werden in JavaScript über das
                    Schlüsselwort <code>class</code> definiert. Hinter diesem Schlüsselwort notiert man den Namen der
                    Klasse (in Upper-CamelCase-Schreibweise) sowie Klassenkörper (den Inhalt der Klasse) in geschweiften
                    Klammern. Innerhalb des Klassenkörpers definiert man die Methoden, die für Objektinstanzen der
                    Klasse zur Verfügung stehen sollen. Die Methode mit dem Namen constructor() nimmt dabei eine
                    besondere Rolle ein: Sie wird implizit aufgerufen, wenn man eine neue Objektinstanz der
                    entsprechenden Klasse erzeugt.
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        class Item {
                          constructor(name, price, author, isbn) {
                            this.name = name;
                            this.price = price;
                            this.author = author;
                            this.isbn = isbn;
                          }
                          printDescription() {
                            console.log(this.author + ': ' + this.name);
                          }
                        }
                    ]]>
                </code-block>

                <img alt="Klassensyntax (1)" src="js-sprachkern-oop-klassensyntax-es6-1.png"/>

                <p>
                    Die neue ES6-Klassensyntax ist letztendlich lediglich eine syntaktische Alternative zu der
                    Verwendung von Konstruktorfunktionen. Wie auch Konstruktorfunktionen haben Klassen ebenfalls eine
                    Eigenschaft <code>prototype</code>, welche das Basisobjekt, also den Prototyp enthält, auf Basis
                    dessen Instanz der Klasse erzeugt werden. Instanzen der Klasse wiederum verfügen ebenfalls über die
                    zwei Eigenschaften <code>__proto__</code> und <code>constructor</code>: Erstere referenziert den
                    Prototyp der Instanz, Letztere die Klasse, über die die Instanz erzeugt wurde.
                </p>

                <img alt="Klassensyntax (2)" src="js-sprachkern-oop-klassensyntax-es6-2.png"/>
            </chapter>

            <chapter id="grundlagen-objekte-erstellen-object-create" title="Object.create() aus ES5">
                <p>
                    Die <code>Object.create()</code>-Methode, als Helfermethode Objekte zu erzeugen, wurde in
                    ECMAScript 5 eingeführt. Sie erwartet als ersten Parameter den Prototyp des zu erzeugenden
                    Objekts und als zweiten optionalen Parameter ein Konfigurationsobjekt, über das man die
                    Eigenschaften und Methoden des Objekts konfigurieren kann. Die Eigenschaften stellen dabei die
                    Namen der Eigenschaften des zu erstellenden Objekts dar. Als wert ist dabei jeweils wiederum ein
                    Objekt hinterlegt, über welches neben dem Wert auch sogenannte Eigenschaftsattribute definieren
                    lassen. Mit <code>Object.create(null)</code> kann ein Objekt ohne Prototyp erstellt werden, dies
                    sollten wir aber nicht verwenden, wenn wir uns nicht zu 100&nbsp;% sicher sind, warum wir das
                    wollen.
                </p>

                <code-block collapsed-title="Beispiel" collapsible="true" lang="javascript">
                    <![CDATA[
                    let item = Object.create(Object.prototype, {
                      name: {
                        value: 'Schrödinger programmiert Java',
                        writable: false,
                        configurable: true,
                        enumerable: true
                      },
                      price: {
                        value: 44.90,
                        writable: true,
                        configurable: true,
                        enumerable: true
                      },
                      author: {
                        value: 'Philip Ackermann',
                        writable: false,
                        configurable: true,
                        enumerable: true
                      },
                      isbn: {
                        value: '978-3-8362-4583-8',
                        writable: false,
                        configurable: true,
                        enumerable: false     // Die Eigenschaft "isbn" wird bei Iteration nicht ausgegeben.
                      },
                      printDescription: {
                        value: function() {
                          console.log(this.author + ': ' + this.name);
                        }
                      }
                    });

                    for(let property in item) {
                      console.log(property);    // Ausgabe: "name", "price", "author"
                    }

                    item.name = 'Cooles neues Java-Buch';
                    console.log(item.name);     // "Schrödinger programmiert Java", da die
                                                // Eigenschaft "name" nicht "writeable" ist.

                    item.price = 54.95;
                    console.log(item.price);    // "54.95", da für die Eigenschaft "price"
                                                // das Attribut "writable" den Wert "true" hat.
                    ]]>
                </code-block>
            </chapter>

            <chapter id="grundlagen-objekte-erstellen-eigenschaftsattribute" title="Eigenschaftsattribute">
                <p>
                    Über diese Eigenschaftsattribute können einzelne Objekteigenschaften konfiguriert werden.
                </p>

                <table style="header-row">
                    <tr>
                        <td>
                            Eigenschaftsattribut
                        </td>
                        <td>
                            Beschreibung
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                value
                            </code>
                        </td>
                        <td>
                            Definiert den Wert der Eigenschaft.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                writable
                            </code>
                        </td>
                        <td>
                            Dieses Eigenschaftsattribut gibt (über einen booleschen Wert) an, ob die jeweilige
                            Eigenschaft überschrieben werden kann, sprich nach Initialisierung mit einem neuen Wert
                            belegt werden darf. Standardmäßig hat dieses Attribut den Wert <code>false</code>.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                enumerable
                            </code>
                        </td>
                        <td>
                            Dieses Eigenschaftsattribut gibt (über einen booleschen Wert) an, ob die jeweilige
                            Eigenschaft aufzählbar ist, sprich, ob – wenn über die Eigenschaften des entsprechenden
                            Objekts iteriert wird – diese Eigenschaft dazugezählt wird, Standardmäßig hat dieses
                            Attribut den Wert <code>false</code>.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                configurable
                            </code>
                        </td>
                        <td>
                            Dieses Eigenschaftsattribut gibt (über einen booleschen Wert) an, ob das
                            Eigenschaftsattribut an sich für die jeweilige Eigenschaft verändert werden kann, sprich, ob
                            die Eigenschaft über die Attribute im Nachhinein konfiguriert werden kann. Auch für dieses
                            Attribut ist der Standardwert <code>false</code>.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                set
                            </code>
                        </td>
                        <td>
                            Dieses Eigenschaftsattribut gibt an, welche Funktion aufgerufen wird, wenn schreibend auf
                            die Eigenschaft zugegriffen wird (nur für sogenannte Zugriffseigenschaften verwendbar).
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                get
                            </code>
                        </td>
                        <td>
                            Dieses Eigenschaftsattribut gibt an, welche Funktion aufgerufen wird, wenn lesend auf die
                            Eigenschaft zugegriffen wird (nur für sogenannte Zugriffseigenschaften verwendbar).
                        </td>
                    </tr>
                </table>

                <p>
                    Um auf die Eigenschaftsattribute einer Eigenschaft bzw. Methode zuzugreifen, steht einem die Methode
                    <code>Object.getOwnPropertyDescriptor()</code> zur Verfügung. Diese Methode erwartet als ersten
                    Parameter das jeweilige Objekt, sowie als zweiten Parameter den Namen der Eigenschaft/Methode, für
                    welche die Attribute ermittelt werden sollen. Zurück liefert die Methode ein Objekt mit den
                    bekannten Eigenschaften: <code>value</code>, <code>writable</code>, <code>enumerable</code>,
                    <code>configurable</code> sowie <code>set</code> und <code>get</code>.
                </p>
            </chapter>
        </chapter>

        <chapter id="grundlagen-eigenschaften-methoden" title="Eigenschaften und Methoden">
            <chapter id="grundlagen-eigenschaften-methoden-zugriff" title="Zugriff">
                <p>
                    Um auf Objekteigenschaften und Objektmethoden zuzugreifen gibt es in JavaScript zwei Möglichkeiten:
                </p>

                <list type="bullet">
                    <li>
                        <p>
                            Die <b>Punktschreibweise</b> über den Punkt, dem sogenannten <b>Memberoperator</b>, da
                            Eigenschaften und Methoden eines Objektes auch als Member bezeichnet werden.
                        </p>

                        <code-block lang="javascript">
                            <![CDATA[
                                let itemName = item.name;
                                item.printDescription();
                            ]]>
                        </code-block>
                    </li>
                    <li>
                        <p>
                            Die <b>Klammerschreibweise</b> bei der, der Name der Eigenschaft bzw. Methode in eckigen
                            Klammern hinter den Namen des Objekts geschrieben wird. Ob beim Zugriff über die
                            Klammerschreibweise einfache oder doppelte Anführungszeichen verwendet werden, spielt keine
                            Rolle. Es sollte nur einheitlich programmiert werden.
                        </p>

                        <code-block lang="javascript">
                            <![CDATA[
                                let itemName = item['name'];
                                item['printDescription']();
                            ]]>
                        </code-block>
                    </li>
                </list>

                <p>
                    In einigen Fällen ist ausschließlich die Klammerschreibweise möglich, und zwar immer dann, wenn der
                    Name der jeweiligen Eigenschaft oder Methode das Minuszeichen enthält.
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        let person = {
                          'first-name': 'Max',
                          'last-name': 'Mustermann'
                        }

                        console.log(person.first-name);     // Syntaxfehler
                        console.log(person.last-name);      // Syntaxfehler
                        console.log(person['first-name']);  // "Max"
                        console.log(person['last-name']);   // "Mustermann"
                    ]]>
                </code-block>
            </chapter>

            <chapter id="grundlagen-eigenschaften-methoden-datenkapselung" title="Datenkapselung">
                <p>
                    In JavaScript gibt es zwei spezielle Schüsselwörter, um Setter- und Getter Methoden als solche
                    auszuzeichnen: <code>set</code> für Setter-Methoden und <code>get</code> für Getter-Methoden. Diese
                    Schlüsselwörter können in Kombination mit der Objekt-Literal-Schreibweise, mit
                    Kunstruktorfunktionen, mit Klassen und in Kombination mit der Methode <code>Object.create()</code>
                    verwendet werden. Mehr zur Theorie hier:
                    <a href="swe-pk-paradigmen-oop.topic#konzepte-kapselung">OOP - Kapselung</a>
                </p>

                <p>
                    Um Namenskonflikte zwischen Eigenschaften und den Methoden zu vermeiden, lässt man Erstere häufig
                    mit einem Unterstrich beginnen. Im Codebeispiel sind die Eigenschaften, um die es
                    geht(<code>_name</code>, <code>_price</code>, <code>_author</code> und <code>_isbn</code>), zwar
                    auch ohne Verwendung der Setter und Getter zugänglich und somit nicht vor direktem Zugriff
                    geschützt.
                </p>

                <code-block collapsed-title="Getter und Setter bei der Verwendung von der Objekt-Literal-Schreibweise"
                            collapsible="true"
                            lang="javascript">
                    <![CDATA[
                        let item = {
                          _name: 'Schrödinger programmiert Java',
                           _price: 44.90,
                          _author: 'Philip Ackermann',
                           _isbn: '978-3-8362-4583-8',
                           set name(newName) {
                            if(typeof newName === 'string') {
                              console.log('Neuen Namen setzen');
                              this._name = newName;
                            } else {
                              throw new TypeError('Name muss eine Zeichenkette sein.')
                            }
                          },
                          get name() {
                            console.log('Namen zurückgeben');
                            return this._name;
                          }  /* Analog für die anderen Eigenschaften. */
                        }

                        console.log(item.name);    // "Namen zurückgeben"
                                                   // "Schrödinger programmiert Java"
                        item.name = 'Schrödinger programmiert Java - Das etwas andere Fachbuch';
                                                   // "Neuen Namen setzen"
                    ]]>
                </code-block>

                <code-block collapsed-title="Getter und Setter bei der Verwendung von Konstruktorfunktionen"
                            collapsible="true"
                            lang="javascript">
                    <![CDATA[
                        function Item(name, price, author, isbn) {
                          this._name = name;
                          this._price = price;
                          this._author = author;
                          this._isbn = isbn;
                        }

                        Item.prototype = {
                          set name(newName) {
                            if(typeof newName === 'string') {
                              console.log('Neuen Namen setzen');
                              this._name = newName;
                            } else {
                              throw new TypeError('Name muss eine Zeichenkette sein.')
                            }
                          },
                          get name() {
                            console.log('Namen zurückgeben');
                            return this._name;
                          }  /* Analog für die anderen Eigenschaften. */
                        };

                        let item = new Item(
                          'Schrödinger programmiert Java',
                          44.90,
                          'Philip Ackermann',
                          '978-3-8362-4583-8'
                        );

                        console.log(item.name);    // "Namen zurückgeben"
                                                   // "Schrödinger programmiert Java"
                        item.name = 'Schrödinger programmiert Java - Das etwas andere Fachbuch';
                                                   // "Neuen Namen setzen"
                    ]]>
                </code-block>

                <code-block collapsed-title="Getter und Setter bei der Verwendung von Klassen"
                            collapsible="true"
                            lang="javascript">
                    <![CDATA[
                        class Item {
                          constructor(name, price, author, isbn) {
                            this._name = name;
                            this._price = price;
                            this._author = author;
                            this._isbn = isbn;
                          }
                          set name(newName) {
                            if(typeof newName === 'string') {
                              console.log('Neuen Namen setzen');
                              this._name = newName;
                            } else {
                              throw new TypeError('Name muss eine Zeichenkette sein.')
                            }
                          }
                          get name() {
                            console.log('Namen zurückgeben');
                            return this._name;
                          }  /* Analog für die anderen Eigenschaften. */
                        }

                        let item = new Item(
                          'Schrödinger programmiert Java',
                          44.90,
                          'Philip Ackermann',
                          '978-3-8362-4583-8'
                        );

                        console.log(item.name);    // "Namen zurückgeben"
                                                   // "Schrödinger programmiert Java"
                        item.name = 'Schrödinger programmiert Java - Das etwas andere Fachbuch';
                                                   // "Neuen Namen setzen"
                    ]]>
                </code-block>

                <code-block collapsed-title="Getter und Setter bei der Verwendung von »Object.create()«"
                            collapsible="true"
                            lang="javascript">
                    <![CDATA[
                        let item = Object.create(Object.prototype, {
                          name: {
                            set: function(newName) {
                              if (typeof newName === 'string') {
                                console.log('Neuen Namen setzen');
                                this._name = newName;
                              } else {
                                throw new TypeError('Name muss eine Zeichenkette sein.')
                              }
                            }
                          },
                          get: function() {
                            console.log('Namen zurückgeben');
                            return this._name;
                          }    /* Analog für die anderen Eigenschaften. */
                        });

                        item.name = "Schrödinger programmiert Java - Das etwas andere Fachbuch";
                        // Ausgabe: 'Neuen Namen setzen'
                        console.log(item.name);
                        // Ausgabe: 'Namen zurückgeben'
                        //          'Schrödinger programmiert Java - Das etwas andere Fachbuch'
                    ]]>
                </code-block>
            </chapter>

            <chapter id="grundlagen-eigenschaften-methoden-manipulieren"
                     title="Objekteigenschaften und Objektmethoden hinzufügen, ändern, überprüfen und löschen">
                <p>
                    In JavaScript können Objekteigenschaften und Objektmethoden jederzeit hinzugefügt, gelöscht und
                    verändert werden. Das ist in vielen anderen Sprachen nicht möglich. Fürs Hinzufügen von
                    Objekteigenschaften und Objektmethoden gibt es in JavaScript folgende Möglichkeiten:
                </p>

                <table style="header-row">
                    <tr>
                        <td>
                            Typ
                        </td>
                        <td>
                            Beispiel
                        </td>
                        <td>
                            Beschreibung
                        </td>
                    </tr>
                    <tr>
                        <td>
                            Hinzufügen/Verändern
                        </td>
                        <td>
                            <code-block lang="javascript">
                                <![CDATA[
                                    item.publisher = 'Galileo Press';
                                ]]>
                            </code-block>
                        </td>
                        <td>
                            <p>
                                Mit dem Memberoperator bzw. über die Punktschreibweise lassen sich neue
                                Objekteigenschaften und Objektmethoden hinzufügen, falls sie im jeweiligen Objekt noch
                                nicht existieren. Existieren sie bereits so werden sie mit dieser Methode überschrieben.
                            </p>

                            <p>
                                Prinzipiell ist es egal, ob direkt beim Anlegen eines Objekts über die
                                Literal-Schreibweise alle Eigenschaften und Methoden direkt angegeben oder über die
                                Punktschreibweise einzeln hinzugefügt werden.
                            </p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            Hinzufügen/Verändern
                        </td>
                        <td>
                            <code-block lang="javascript">
                                <![CDATA[
                                    item['publisher'] = 'Galileo Press';
                                ]]>
                            </code-block>
                        </td>
                        <td>
                            <p>
                                Wie bei der Punktschreibweise können über die Klammerschreibweise Objekteigenschaften
                                und Objektmethoden hinzugefügt oder überschrieben werden.
                            </p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            Hinzufügen
                        </td>
                        <td>
                            <code-block lang="javascript">
                                <![CDATA[
                                    let item = {};
                                    Object.defineProperty(item,
                                      'name', {
                                       value: 'Schrödinger programmiert Java'
                                      }
                                    );
                                ]]>
                            </code-block>

                            <code-block lang="javascript">
                                <![CDATA[
                                    let item = {};
                                    Object.defineProperties(item, {
                                      name: {
                                        value: 'Schrödinger programmiert Java'
                                      },
                                      // ...
                                    });
                                ]]>
                            </code-block>
                        </td>
                        <td>
                            <p>
                                Seit ECMAScript 5 stellt JavaScript für das Definieren von Objekteigenschafen und
                                Objektmethoden zwei Helfermethoden zur Verfügung: über die
                                <code>Object.defineProperty()</code> lässt sich eine einzelne neue Eigenschaft (bzw.
                                Methode) definieren, über <code>Object.defineProperties()</code> direkt mehrere auf
                                einen Schlag.
                            </p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            Überprüfen
                        </td>
                        <td>
                            <code-block lang="javascript">
                                <![CDATA[
                                    'price' in item;
                                ]]>
                            </code-block>
                        </td>
                        <td>
                            <p>
                                Mit dem <code>in</code>-Operator kann überprüft werden, ob ein Objekt über eine gewisse
                                Eigenschaft oder Methode verfügt. Er gibt <code>true</code> zurück, falls die
                                Eigenschaft, die als erster Operand übergeben wird, in dem als zweiten Operanden
                                übergebenen Objekt existiert.
                            </p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            Löschen
                        </td>
                        <td>
                            <code-block lang="javascript">
                                <![CDATA[
                                    delete item.price;
                                ]]>
                            </code-block>
                        </td>
                        <td>
                            <p>
                                Objekteigenschaften und Objektmethoden werden mit dem <code>delete</code>-Operator, dem
                                als Operanden die zu entfernende Objekteigenschaft übergeben wird, gelöscht. Das
                                Verwenden des <code>delete</code>-Operators ist übrigens nicht gleichzusetzen mit dem
                                Zuweisen des <code>null</code>-Wertes oder des <code>undefined</code>-Wertes einer
                                Objekteigenschaft. Letzteres sorgt lediglich dafür, dass die Eigenschaft den Wert
                                <code>null</code> oder <code>undefined</code> erhält, nicht aber die Eigenschaft aus
                                dem Objekt entfernt wird.
                            </p>
                        </td>
                    </tr>
                </table>
            </chapter>

            <chapter id="grundlagen-eigenschaften-methoden-ausgeben"
                     title="Objekteigenschaften und Objektmethoden ausgeben">
                <p>
                    Werden die Eigenschaftsnamen und Methodennamen eines Objekts oder deren Werte als Array benötigt
                    sollte man zu den Helfermethoden <code>Object.keys()</code>, <code>Object.values()</code> oder
                    <code>Object.entries()</code> greifen. Soll hingegen einmalig über die Namen iteriert werden, ist es
                    besser die <code>for-in</code>-Schleife zu verwenden.
                </p>

                <p>
                    Erwähnenswert ist, dass die <code>for-in</code>-Schleife auch über(aufzählbare) Eigenschaften und
                    Methoden der Prototypen eines Objekts iteriert, während die Methode <code>Object.keys()</code> nur
                    die Namen der (aufzählbaren) Eigenschaften und Methoden zurückgibt, die an der jeweiligen
                    Objektinstanz selbst definiert wurden.
                </p>

                <chapter id="grundlagen-eigenschaften-methoden-ausgeben-for-in" title="Die for-in-Schleife">
                    <p>
                        Mithilfe der <code>for-in</code>-Schleife lässt sich über all aufzählbaren Eigenschaften und
                        Methoden eines Objekts iterieren (also über solche, deren Eigenschaftsattribut
                        <code>enumerable</code> den Wert <code>true</code> hat). In jeder Iteration der
                        <code>for-in</code>-Schleife wird hier der Variablen <code>property</code> jeweils der
                        entsprechende Namen der Eigenschaft bzw. Methode des Objekts item zugewiesen. Über die
                        Klammerschreibweise ist es dann beispielsweise möglich, auf die jeweiligen Werte der
                        Eigenschaften zuzugreifen (über die Punktschreibweise wäre dies beispielweise nicht möglich.
                    </p>

                    <code-block lang="javascript">
                        <![CDATA[
                            let item = {
                              name: 'Schrödinger programmiert Java',
                              price: 44.90,
                              author: 'Philip Ackermann',
                              isbn: '978-3-8362-4583-8',
                              printDescription: function() {
                                console.log(this.author + ': ' + this.name);
                              }
                            }

                            for(let property in item) {
                              console.log('Name: ' + property);
                              console.log('Wert: ' + item[property]);
                            }
                        ]]>
                    </code-block>
                </chapter>

                <chapter id="grundlagen-eigenschaften-methoden-ausgeben-helfermethoden" title="Helfermethoden">
                    <p>
                        Seit ECMAScript 5 gibt es die Methode <code>Object.keys()</code>, die für ein Objekt die Namen
                        aller (aufzählbaren) Eigenschaften und Methoden als Array zurückgibt.
                    </p>

                    <code-block lang="javascript">
                        <![CDATA[
                            let properties = Object.keys(item);
                            for(let i=0; i<properties.length; i++) {
                              let property = properties[i];
                              console.log('Name: ' + property);
                              console.log('Wert: ' + item[property]);
                            }

                            printArray(properties);
                            function printArray(array) {
                              for(let i=0; i<array.length; i++) {
                                console.log(array[i]);
                              }
                            }
                        ]]>
                    </code-block>

                    <p>
                        Seit ES2017 gibt es die Methoden <code>Object.values()</code> und <code>Object.entries()</code>.
                        Erstere gibt die Werte aller (aufzählbaren) Eigenschaften und Methoden als Array zurück,
                        Letztere Name-Wert-Paare aller (aufzählbaren Eigenschaften und Methoden.
                    </p>

                    <code-block lang="javascript">
                        <![CDATA[
                            let keys = Object.keys(item);
                            console.log(keys);
                            // => [ 'name', 'price', 'author', 'isbn', 'printDescription' ]

                            let values = Object.values(item);
                            console.log(values);
                            // => [ 'Schrödinger programmiert Java', 44.9, 'Philip Ackermann', '978-3-8362-4583-8', [Function: printDescription] ]

                            let entries = Object.entries(item);
                            console.log(entries);
                            // [
                            //   [ 'name', 'Schrödinger programmiert Java' ],
                            //   [ 'price', 44.9 ],
                            //   [ 'author', 'Philip Ackermann' ],
                            //   [ 'isbn', '978-3-8362-4583-8' ],
                            //   [ 'printDescription', [Function: printDescription] ]
                            // ]
                        ]]>
                    </code-block>
                </chapter>
            </chapter>
        </chapter>

        <chapter id="grundlagen-aenderung-verhindern" title="Änderung an Objekten verhindern">
            <p>
                In einigen Fällen kann es sinnvoll sein, Objekte vor Änderungen zu schützen, sprich zu verhindern, dass
                einem Objekt neue Eigenschaften oder Methoden hinzugefügt werden. JavaScript bietet dazu drei
                verschiedene Möglichkeiten an.
            </p>

            <img alt="Änderung an Objekten verhindern" src="js-sprachkern-oop-aenderung-an-objekten-verhindern.png"/>

            <chapter id="grundlagen-aenderung-verhindern-prevent-extensions" title="Erweiterung an Objekten verhindern">
                <p>
                    Übergibt man der Methode <code>Object.preventExtensions()</code> ein Objekt, so kann man
                    anschließend keine Erweiterungen am jeweiligen Objekt vornehmen. Versucht man dies dennoch, kommt es
                    zu einem Fehler. Immer noch erlaubt bleibt jedoch das Ändern der Eigenschaftswerte und
                    Eigenschaftsattribute.
                </p>

                <p>
                    Mit der Methode <code>Object.isExtenible()</code> kann man überprüfen, ob das übergebene Objekt
                    erweiterbar ist.
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        let max = {
                          firstName: 'Max',
                          lastName: 'Mustermann'
                        }

                        console.log(Object.isExtensible(max));    // => true
                        Object.preventExtensions(max);
                        console.log(Object.isExtensible(max));    // => false
                        max.weight = 88; // => TypeError: Can't add property weight, object is not extensible
                    ]]>
                </code-block>
            </chapter>

            <chapter id="grundlagen-aenderung-verhindern-seal" title="Objekte versiegeln">
                <p>
                    Mit der Methode <code>Object.seal()</code> lässt sich das übergebene Objekt versiegeln. Versigelte
                    Objekte sind nicht erweiterbar, zusätzlich aber auch ihre bestehenden Eigenschaften nicht
                    konfigurierbar – nur die Werte der Eigenschaften lassen sich ändern. Ob ein Objekt versigelt ist
                    lässt sich mit <code>Object.isSealed()</code> überprüfen. Da versiegelte Objekte zugleich nicht
                    erweiterbar sind, liefert die Methode <code>Object.isExtensible()</code> bei einem versigelten
                    Objekt den Wert <code>false</code> zurück.
                </p>
            </chapter>

            <chapter id="grundlagen-aenderung-verhindern-freeze" title="Objekte einfrieren">
                <p>
                    Mit der Methode <code>Object.freeze()</code> lässt sich das übergebene Objekt einfrieren. Bei
                    eingefrorenen Objekten lassen sich nur mehr die Objekteigenschaften und Objektmethoden abrufen. Es
                    können keine neuen Eigenschaften und Methoden hinzugefügt werden, die Eigenschaftsattribute sowie
                    die Eigenschaftswerte können auch nicht verändert werden. Über die Methode
                    <code>Object.isFrozen()</code> lässt sich ermitteln, ob ein Objekt eingefroren ist. Der Aufruf von
                    <code>Object.isExtensible()</code> gibt für das eingefrorene Objekt den Wert <code>false</code>
                    zurück, der Aufruf von <code>Object.isSealed()</code> den Wert <code>true</code>, weil eingefrorene
                    Objekte immer auch versiegelt sind und nicht erweiterbar.
                </p>
            </chapter>
        </chapter>
    </chapter>

    <chapter id="prinzipien" title="Prinzipien der Objektorientierung">
        <p>
            Die Tatsache allein allerdings, dass man mit Objekten arbeitet, bedeutet nicht zwangsläufig, dass man auch
            objektorientiert arbeitet. Vielmehr liegen der objektorientierten Programmierung vier wesentliche Prinzipien
            zugrunde:
        </p>

        <list>
            <li>
                <b>Abstraktion:</b> Abstraktes Verhalten von Objekten wird in Klassen oder Prototypen zusammengefasst.
                Mehr dazu unter
                <a href="swe-pk-paradigmen-oop.topic#konzepte-abstraktion-generalisierung">
                    Abstraktion &amp; Generalisierung / Spezialisierung
                </a>.
            </li>
            <li>
                <b>Datenkapselung:</b> Eigenschaften und Methoden werden in Form von Klassen oder Prototypen gekapselt
                und vor dem Zugriff von außen verborgen. Mehr dazu unter
                <a href="swe-pk-paradigmen-oop.topic#konzepte-kapselung">Kapselung</a> und
                <a href="swe-pk-paradigmen-oop.topic#konzepte-sichtbarkeit">Geheimprinzip / Sichtbarkeit</a>
            </li>
            <li>
                <b>Vererbung:</b> Eigenschaften und Methoden können von einer Klasse an eine andere Klasse oder von
                einem Objekt (dem Prototyp) an ein anderes Objekt vererbt werden. Mehr dazu unter
                <a href="swe-pk-paradigmen-oop.topic#konzepte-vererbung">Vererbung</a>
            </li>
            <li>
                <b>Polymorphie:</b> Objekte können abhängig von ihrer Verwendung unterschiedliche Typen annehmen. Mehr
                dazu unter
                <a href="swe-pk-paradigmen-oop.topic#konzepte-polymorphismus">Polymorphismus</a>
            </li>
        </list>

        <p>
            JavaScript verhält sich bezüglich der objektorientierten Programmierung nicht so eindeutig wie andere
            Sprachen (beispielsweise Java). Vielmehr gibt es in JavaScript verschiedene Techniken, um objektorientiert
            zu programmieren. Prinzipiell unterscheidet man dabei zwischen folgenden Techniken:
        </p>

        <list>
            <li>
                <b>Prototypische Objektorientierung</b> – dies ist die Art der Objektorientierung, die der Sprache
                JavaScript am natürlichsten ist, weil hierbei lediglich Objekte zum Einsatz kommen.
            </li>
            <li>
                <b>Pseudoklassische Objektorientierung</b> – hierbei handelt es sich um eine Art der Objektorientierung,
                bei der man so tut, als wäre JavaScript eine klassenbasierte Programmiersprache. Zum Einsatz kommen
                hierbei Konstruktorfunktionen.
            </li>
            <li>
                <b>Objektorientierung mit Klassensyntax</b> – diese Art der Objektorientierung stellt eine syntaktische
                Vereinfachung der pseudoklassischen Objektorientierung dar.
            </li>
        </list>

        <p>
            Die Art der Objektorientierung hat je nach Art der Programmiersprache ebenfalls unterschiedliche
            Bezeichnungen: In der klassenbasierten Programmierung spricht man von klassenbasierter Objektorientierung,
            in der objektbasierten bzw. prototypenbasierten Programmierung spricht man von prototypischer
            Objektorientierung. Ein Beispiel für eine klassenbasierte Programmiersprache ist die Programmiersprache
            Java. JavaScript dagegen ist, wohlgemerkt, <b>keine klassenbasierte Programmiersprache</b>, auch wenn es
            seit ES6/ES2015 eine Klassensyntax gibt. JavaScript ist vielmehr eine <b>objektbasierte
            Programmiersprache</b>: Objektinstanzen werden hier nicht auf Basis von Klassen, sondern auf Basis von
            anderen Objekten erstellt. Diese anderen Objekte stellen dann den sogenannten Prototyp dar.
        </p>

        <chapter id="prinzipien-prototypen" title="Prototypische Objektorientierung">
            <p>
                JavaScript ist eine prototypenbasierte Sprache, kennt also keine Klassen, zumindest keine echten. Alles
                in JavaScript basiert dagegen auf Objekten. Jedes Objekt in JavaScript basiert auf einem Prototyp.
                Zumindest fast jedes Objekt, denn einige Objekte wie beispielsweise die Mutter aller Objekte
                <code>Object</code> oder Objekte, deren Prototyp explizit auf <code>null</code> gesetzt wurde, haben
                keinen Prototyp. Jedes Objekt kann zudem selbst als Vorlage, also als Prototyp für ein anderes Objekt
                herhalten. In diesem Fall erbt das neue Objekt die Eigenschaften und Methoden vom Prototyp. Übersetzt in
                die klassenbasierte Programmierung entspricht das also in etwa dem Erstellen einer Unterklasse.
            </p>

            <p>
                Bei der prototypischen Vererbung erben nicht Klassen von Klassen, sondern Objekte von Objekten.
            </p>

            <p>
                Der Prototyp eines Objekts ist in der Eigenschaft <code>__proto__</code> hinterlegt. Erstmals
                implementiert wurde diese Eigenschaft im Firefox-Browser als Alias zu der internen Eigenschaft
                <code>[[Prototype]]</code> und seitdem von fast allen Browsern bzw. Laufzeitumgebungen übernommen.
                Fest in den ECMAScript-Standard übernommen wurde die Eigenschaft aber erst mit der Version 6. Statt
                jedoch direkt auf die Eigenschaft zuzugreifen, ist es üblich und empfehlenswert, den Prototyp eines
                Objekts über die Methode <code>Object.getPrototypeOf()</code> zu ermitteln. Außerdem ist es möglich, mit
                <code>Object.isPrototypeOf()</code> zu überprüfen, ob ein Objekt der Prototyp eines anderen Objekts ist.
            </p>

            <code-block lang="javascript">
                <![CDATA[
                    let animal = {
                      name: '',  color: 'Braun',  age: 0,
                      eat: function(food) { /* ... */ },
                      drink: function(drink) { /* ... */ }
                    }
                    let cat = Object.create(animal);
                    let dog = Object.create(animal);
                ]]>
            </code-block>

            <p>
                Um ein Objekt auf Basis eines Prototyps zu definieren, wird die Methode <code>Object.create()</code>
                verwendet. Zur Erinnerung: Beim Erstellen eines Objekts über die Objekt-Literal-Schreibweise kann kein
                Prototyp angegeben werden. Die Objekte erben die Eigenschaften und Methoden des Prototyps. Das bedeutet,
                dass die Objekte <code>cat</code> und <code>dog</code> im Beispiel beide den Wert <code>'Braun'</code>
                für die Eigenschaft <code>color</code> haben.
            </p>

            <code-block lang="javascript">
                <![CDATA[
                    cat.meow = function() { /* ... */ }
                ]]>
            </code-block>

            <p>
                Es ist selbstverständlich auch möglich, dass an Objekten, die von einem Prototyp erben, zusätzliche
                Eigenschaften und Methoden definiert werden können. Jene Methoden und Eigenschaften stehen dann
                natürlich nur auf den jeweiligen Objekten zur Verfügung. Die Methode <code>meow()</code> aus dem
                Beispiel kann beispielsweise nicht vom Objekt dog aufgerufen werden.
            </p>

            <code-block lang="javascript">
                <![CDATA[
                    cat.eat = function() { /* ... */ }
                ]]>
            </code-block>

            <p>
                Klassen bzw. im Fall der prototypischen Objektorientierung Objekte, die in der Vererbungshierarchie
                weiter unten stehen, sind spezieller als solche, die in der Vererbungshierarchie weiter oben stehen.
                Oder umgekehrt formuliert: Klassen/Objekte, die in der Hierarchie weiter oben stehen, sind abstrakter
                als solche weiter unten. Spezielleres Verhalten kann dabei zum einen dadurch entstehen, dass Klassen
                bzw. Objekten neue Methoden hinzugefügt werden, zum anderen aber auch, dass <b>geerbte Methoden
                überschrieben</b> werden. Das bedeutet, dass dem Objekt <code>cat</code> eine Methode
                <code>eat()</code> hinzugefügt werden kann, obwohl es diese bereits vom Prototyp <code>animal</code>
                geerbt hat.
            </p>

            <chapter id="prinzipien-prototypen-kette" title="Die Prototypkette">
                <p>
                    Objekte erben Eigenschaften und Methoden von ihrem Prototyp bzw. allen vorangegangenen Prototypen
                    über die sogenannte Prototypenkette. Vom Ablauf her funktioniert das wie folgt: Wird auf eine
                    Eigenschaft bzw. Methode eines Objekts zugegriffen, prüft der JavaScript-Interpreter zunächst, ob
                    das entsprechende Objekt über die jeweilige Eigenschaft/Methode verfügt. Ist dies der Fall, wird die
                    Eigenschaft/Methode verwendet, ist dies dagegen nicht der Fall, wird auf den Prototyp des Objekts
                    (welcher ja u. a. in der <code>__proto__</code>-Eigenschaft hinterlegt ist) zugegriffen. Ist die
                    Eigenschaft/Methode auch dort nicht vorhanden, wird im Prototyp des Prototyps geschaut usw., bis
                    irgendwann das Basisobjekt Object erreicht wird.
                </p>

                <p>
                    Die Prototypenkette bezeichnet also eine Kette von Objekten, die jeweils als Prototyp für die
                    nachfolgenden Objekte in dieser Kette dienen.
                </p>
            </chapter>

            <chapter id="prinzipien-prototypen-methoden" title="Methoden eines Prototypen aufrufen">
                <p>
                    Um eine Methode des Prototyps eines Objekts aufzurufen, muss man zunächst an den Prototyp des
                    Objekts gelangen. Dazu hat man prinzipiell zwei Möglichkeiten: Zum einen ist der Prototyp eines
                    Objekts ja, wie gesagt, in dessen Eigenschaft <code>__proto__</code> hinterlegt, zum anderen kann
                    man über die Methode <code>Object.getPrototypeOf()</code> den Prototyp eines Objekts ermitteln.
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        cat.eat = function(food) {
                          this.__proto__.eat.call(this, food);              // Methode (1)
                          Object.getPrototypeOf(this).eat.call(this, food); // Methode (2)
                        }
                    ]]>
                </code-block>

                <p>
                    In beiden Fällen wird zunächst über genannte Wege auf den Prototyp des aktuellen Objekts
                    zugegriffen, dann auf die Methode <code>eat()</code> und auf dieser wiederum die Methode
                    <code>call()</code> aufgerufen. Diese Methode, die standardmäßig für alle Funktionen bzw.
                    Methoden zur Verfügung steht, macht nichts anderes, als die jeweilige Funktion/Methode in einem
                    bestimmten Kontext auszuführen. Diesen Ausführungskontext übergibt man ihr dabei als ersten
                    Parameter, optional können, wie im Beispiel gezeigt, weitere Parameter übergeben werden, mit denen
                    die ursprüngliche Funktion/Methode aufgerufen werden soll.
                </p>
            </chapter>
        </chapter>

        <chapter id="prinzipien-pseudoklassisch" title="Pseudoklassische Objektorientierung">
            <p>
                Im Gegensatz zur prototypischen Objektorientierung basiert die pseudoklassische Objektorientierung auf
                dem Einsatz von Konstruktorfunktionen. Die Idee dabei ist, dass sich die objektorientierte
                Programmierung mit JavaScript so anfühlt, als würde man klassenbasiert programmieren.
            </p>

            <table style="none">
                <tr>
                    <td>
                        <p>
                            <b>
                                Konstruktor Funktion definieren
                            </b>
                        </p>

                        <p>
                            Innerhalb einer Konstruktorfunktion bezieht sich dann das Schlüsselwort <code>this</code>
                            auf das Objekt, welches durch den Aufruf der Konstruktorfunktion erzeugt wird.
                        </p>
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                function Animal(name, color, age) {
                                  this.name = name;
                                  this.color = color;
                                  this.age = age;
                                };
                            ]]>
                        </code-block>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p>
                            <b>
                                Objektinstanzen erzeugen
                            </b>
                        </p>

                        <p>
                            Um unter Verwendung einer Konstruktorfunktion eine neue Objektinstanz zu erzeugen, ruft man
                            die Konstruktorfunktion mit dem Schlüsselwort <code>new</code> auf.
                        </p>
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                let fish = new Animal('Fischi', 'Grün', 2);
                                console.log(fish.name); // => "Fischi"
                            ]]>
                        </code-block>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p>
                            <b>
                                Methoden definieren
                            </b>
                        </p>

                        <p>
                            Um Methoden zu erstellen, die allen Objektinstanzen, die mithilfe einer Konstruktorfunktion
                            erstellt werden, gemeinsam sind, definiert man diese an dem Objekt, welches den durch die
                            Konstruktorfunktion erzeugten Objektinstanzen als Prototyp dient. Dieses Objekt ist in der
                            Eigenschaft <code>prototype</code> der entsprechenden Konstruktorfunktion hinterlegt.
                        </p>
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                Animal.prototype.eat = function(food) {
                                  console.log('Mmpf mmpf, ' + food + '!');
                                }
                                Animal.prototype.drink = function(drink) {
                                  console.log('Mmmmmmh, ' + drink + '!');
                                }
                            ]]>
                        </code-block>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p>
                            <b>
                                Von Objekten ableiten
                            </b>
                        </p>

                        <img alt="Von Objekten ableiten" src="js-sprachkern-oop-von-objekten-ableiten.png"/>
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                function Dog(name, color, age, type) {
                                  Animal.call(this, name, color, age);
                                  this.type = type;
                                };
                                Dog.prototype = new Animal();
                                Dog.prototype.constructor = Dog;
                                Dog.prototype.bark = function() {
                                  console.log('Wuff wuff');
                                }
                                let bello = new Dog('Bello', 'Weiß', 2, 'Malteser');
                            ]]>
                        </code-block>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p>
                            <b>
                                Konstruktor der »Oberklasse« aufrufen
                            </b>
                        </p>

                        <p>
                            Um den Konstruktor einer »Oberklasse« aufzurufen, muss lediglich die entsprechende
                            Konstruktorfunktion über die Methode <code>call()</code> aufgerufen und dabei
                            <code>this</code> als Ausführungskontext sowie optional weitere Parameter übergeben werden.
                        </p>
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                function Dog(name, color, age, type) {
                                  Animal.call(this, name, color, age);  this.type = type;
                                };
                            ]]>
                        </code-block>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p>
                            <b>
                                Methoden überschreiben
                            </b>
                        </p>

                        <p>
                            Um eine Methode in einer »Unterklasse« zu überschreiben, definieren Sie die entsprechende
                            Methode einfach am Prototyp, die der entsprechenden Konstruktorfunktion der »Unterklasse«
                            zugrunde liegt.
                        </p>
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                function VegetarianDog(name, color, age, type) {
                                  Dog.call(this, name, color, age, type);
                                };
                                VegetarianDog.prototype.eat = function(food) {
                                  /* ... */
                                }
                            ]]>
                        </code-block>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p>
                            <b>
                                Methoden der »Oberklasse« aufrufen
                            </b>
                        </p>

                        <p>
                            Der Aufruf einer Methode der »Oberklasse« funktioniert wie schon der Aufruf von
                            Konstruktoren unter Verwendung der Methode <code>call()</code>.
                        </p>
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                VegetarianDog.prototype.eat = function(food) {
                                  Dog.prototype.eat.call(this, food);
                                }
                            ]]>
                        </code-block>
                    </td>
                </tr>
            </table>
        </chapter>

        <chapter id="prinzipien-klassensyntax" title="Objektorientierung mit Klassensyntax">
            <p>
                Seit ES6/ES2015 hat auch eine neue Klassensyntax in den ECMAScript-Standard Einzug gehalten. Diese
                Klassensyntax ermöglicht zwar keine echte klassenbasierte Programmierung, fühlt sich aber u.a. aufgrund
                der verwendeten Schlüsselwörter und Syntax relativ ähnlich an. Eigentlich wird durch die Klassensyntax
                aber lediglich etwas von der Komplexität der pseudoklassischen Objektorientierung genommen, weil im
                Hintergrund nach wie vor Objekte und Prototypen werkeln.
            </p>

            <table>
                <tr>
                    <td>
                        <p>
                            <b>
                                Klassen definieren
                            </b>
                        </p>

                        <p>
                            Um in JavaScript eine »Klasse« zu definieren, wird das Schlüsselwort class verwendet. Hinter
                            dieses Schlüsselwort wird der Namen der Klasse, gefolgt von einem Paar geschweifter
                            Klammern, die den Körper der Klasse (den Klassenkörper) definieren geschrieben. Innerhalb
                            dieses Klassenkörpers können anschließend die Methoden der Klasse definiert werden
                            (Eigenschaften dagegen können an dieser Stelle nicht angegeben werden).
                        </p>

                        <p>
                            Die Methode mit dem Namen <code>constructor()</code> entspricht dem Konstruktor der
                            jeweiligen Klasse und wird immer dann aufgerufen, wenn ein Objekt der Klasse mit dem
                            Schlüsselwort <code>new</code> instanziiert wird. Zurückgeliefert wird von
                            <code>constructor()</code> nämlich implizit eine neue Objektinstanz. Innerhalb der
                            Methode <code>constructor()</code> kann über das Schlüsselwort <code>this</code> auf
                            diese Objektinstanz zugegriffen werden. Das ist wiederum dann auch die Stelle, an der
                            Eigenschaften definiert werden können.
                        </p>
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                class Animal {
                                  constructor(name, color, age) {
                                    this.name = name;
                                    this.color = color;
                                    this.age = age;
                                  }
                                  eat(food) { /* ... */  }
                                  drink(drink) { /* ... */ }
                                  toString() { /* ... */ }
                                }
                            ]]>
                        </code-block>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p>
                            <b>
                                Objektinstanzen erzeugen
                            </b>
                        </p>

                        <p>
                            Um eine Objektinstanz einer »Klasse« zu erzeugen, wird das Schlüsselwort <code>new</code>
                            verwendet.
                        </p>
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                let fish = new Animal('Fischi', 'Grün', 2);
                            ]]>
                        </code-block>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p>
                            <b>
                                Getter und Setter definieren
                            </b>
                        </p>

                        <p>
                            Über die Schlüsselwörter <code>get</code> und <code>set</code> können Getter- und
                            Setter-Methoden an Objekten definiert werden. Die gleichen Schlüsselwörter können auch in
                            Kombination mit »Klassen« verwendet werden, um dort Getter und Setter zu definieren.
                        </p>

                        <list>
                            <li>
                                Getter-Methoden können keine Argumente annehmen!
                            </li>
                            <li>
                                Setter-Methoden können nur ein Argument annehmen!
                            </li>
                            <li>
                                Getter- und Setter-Methoden werden nicht wie normale Funktionen aufgerufen, sondern wie
                                eine Wertzuweisung einer Eigenschaft einer Variable (setter) oder als Variable (getter).
                            </li>
                        </list>

                        <p>
                            Zu beachten ist außerdem, dass der Name der jeweiligen Getter- bzw. Setter-Methode nicht
                            gleich der entsprechenden Eigenschaft ist, um eine Endlosrekursion, einen damit verbundenen
                            Stacküberlauf und damit den Absturz des jeweiligen Programms zu verhindern.
                        </p>
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                class Animal {
                                  constructor(name, color, age) {
                                    this.name = name;
                                    this.color = color;
                                    this.age = age;
                                  }
                                  eat(food) { /* ... */  }
                                  drink(drink) { /* ... */ }
                                  toString() { /* ... */ }
                                  get name() { return this._name; }
                                  set name(name) { this._name = name; }
                                  /* ... */
                                }
                            ]]>
                        </code-block>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p>
                            <b>
                                Von »Klassen« ableiten
                            </b>
                        </p>

                        <p>
                            Über das Schlüsselwort <code>extends</code> ist es möglich, dass eine »Klasse« von einer
                            anderen »Klasse« erbt bzw. ableitet. Das Schlüsselwort schreibt man dabei einfach hinter die
                            (neue) »Klasse«, die erben soll, dem Schlüsselwort folgt dann der Name der »Klasse«, von der
                            geerbt werden soll. Die Klasse von der geerbt werden soll, muss nicht zwingend mit der
                            Klassensyntax geschrieben worden sein es muss sich nur um ein Objekt handeln.
                        </p>

                        <p>
                            Innerhalb des Konstruktors der ableitenden »Klasse« kann per <code>super()</code> der
                            Konstruktor der »Oberklasse« (der Elternkonstruktor) aufgerufen werden. Es ist übrigens sehr
                            wichtig, dies zu tun, bevor innerhalb des Konstruktors auf <code>this</code> zugegriffen
                            wird. Ansonsten kommt es zu einem Fehler. Das Gleiche gilt, wenn man innerhalb eines
                            Konstruktors den Aufruf des Elternkonstruktors ganz weglässt. Es ist allerdings möglich, den
                            Konstruktor einer »Klasse«, sprich die <code>constructor()</code>-Methode, ganz wegzulassen.
                            In diesem Fall wird intern implizit ein Konstruktor verwendet, der alle Parameter an den
                            Elternkonstruktor weiterleitet.
                        </p>
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                class Dog extends Animal {
                                  constructor(name, color, age, type) {
                                    super(name, color, age);
                                    this.type = type;
                                  }
                                  get type() { return this._type; }
                                  set type(type) { this._type = type; }
                                  bark() { /* ... */ }
                                }
                            ]]>
                        </code-block>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p>
                            <b>
                                Methoden überschreiben
                            </b>
                        </p>

                        <p>
                            Um eine Methode in einer »Unterklasse« zu überschreiben, definiert man einfach eine
                            entsprechende Methode mit gleichem Namen wie die zu überschreibende Methode.
                        </p>
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                class Dog extends Animal {
                                  constructor(name, color, age, type) {
                                    super(name, color, age);
                                    this.type = type;
                                  }
                                  get type() { return this._type; }
                                  set type(type) { this._type = type; }
                                  eat(food) { /* ... */ }
                                  bark() { /* ... */ }
                                }
                            ]]>
                        </code-block>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p>
                            <b>
                                Methoden der »Oberklasse« aufrufen
                            </b>
                        </p>

                        <p>
                            Möchte man innerhalb einer Methode eine andere Methode der gleichen »Klasse« aufrufen, kann
                            man dies über die Verwendung des Schlüsselwortes <code>this</code> erreichen. Soll dagegen
                            innerhalb einer Methode gezielt eine Methode der »Oberklasse« aufgerufen werden, kann das
                            Schlüsselwort super verwendet werden, welches sozusagen eine Referenz auf die »Oberklasse«
                            darstellt.
                        </p>

                        <p>
                            Es zwar auch per <code>this</code> auf Methoden der »Oberklasse« zugegriffen werden, aber
                            nur, wenn es die jeweilige Methode nicht in der »Unterklasse« gibt. Ist dies dagegen nicht
                            der Fall, wird bei Zugriff per <code>this</code> die Methode der »Unterklasse« verwendet.
                        </p>
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                class Dog extends Animal {
                                  constructor(name, color, age, type) {
                                    super(name, color, age);
                                    this.type = type;
                                  }
                                  get type() { return this._type; }
                                  set type(type) { this._type = type; }
                                  eat(food) { return super.eat(food); }
                                  bark() { /* ... */ }
                                }
                            ]]>
                        </code-block>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p>
                            <b>
                                Statische Methoden definieren
                            </b>
                        </p>

                        <p>
                            Statische Methoden bezeichnen in der objektorientierten Programmierung solche Methoden, die
                            man direkt auf der Klasse aufruft und nicht auf einer Objektinstanz. Statische Methoden
                            eignen sich immer dann, wenn damit Funktionalität bereitgestellt werden soll, die thematisch
                            zu der jeweiligen Klasse gehört, aber nicht zwangsweise eine Objektinstanz voraussetzt. In
                            der Klassensyntax wird in JavaScript eine Methode als statisch definiert, indem ihr das
                            Schlüsselwort <code>static</code> vorangestellt wird. Anschließend kann die Methode direkt
                            über die »Klasse« aufgerufen werden.
                        </p>
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                class Animal {
                                  /* ... */
                                  static getAnimalColors() {
                                    return {
                                      WHITE: 'Weiß',
                                      BLACK: 'Schwarz',
                                      BROWN: 'Braun',
                                      GREEN: 'Grün',
                                      YELLOW: 'Gelb',
                                      ORANGE: 'Orange'
                                    }
                                  }
                                  /* ... */
                                }
                                let bird = new Animal('Birdie', Animal.getAnimalColors().BLACK, 5);
                            ]]>
                        </code-block>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p>
                            <b>
                                Statische Eigenschaften definieren
                            </b>
                        </p>

                        <p>
                            Neben statischen Methoden gibt es in der Objektorientierung auch das Konzept der statischen
                            Eigenschaften. Analog zu statischen Methoden werden statische Eigenschaften direkt auf einer
                            Klasse definiert, und man benötigt keine Objektinstanz, um auf diese Eigenschaften
                            zuzugreifen.
                        </p>

                        <p>
                            In der Klassensyntax in JavaScript war es bis ES2022 nicht möglich, statische Eigenschaften
                            explizit innerhalb des Klassenkörpers zu definieren (es war auch noch nicht mal möglich,
                            überhaupt Eigenschaften auf die gleiche Weise wie Methoden direkt innerhalb des
                            Klassenkörpers zu definieren). Stattdessen wurden statische Eigenschaften als Eigenschaften
                            der »Klasse« definiert. Eine gebräuchliche Konvention ist es hierbei, die Namen der
                            statischen Eigenschaften in Großbuchstaben zu schreiben.
                        </p>
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                Animal.ANIMAL_COLORS = {
                                  WHITE: 'Weiß',
                                  BLACK: 'Schwarz',
                                  BROWN: 'Braun',
                                  GREEN: 'Grün',
                                  YELLOW: 'Gelb',
                                  ORANGE: 'Orange'
                                }
                                let bird = new Animal('Birdie', Animal.ANIMAL_COLORS.BLACK, 5);
                            ]]>
                        </code-block>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p>
                            <b>
                                Eigenschaften im Klassenkörper
                            </b>
                        </p>

                        <p>
                            Seit einer neueren Version des EcmaScript-Standards (= EcmaScript 2022) wurde die
                            Deklaration von Eigenschaften innerhalb des Klassenkörpers eingeführt. Diese können als
                            <b>public</b> und <b>privat</b> deklariert werden. Eigenschaften in private werden mit
                            dem Prefix <code>#</code> angegeben.
                        </p>
                    </td>
                    <td>
                        <code-block lang="javascript">
                            <![CDATA[
                                class Vehicle {
                                  status = "unavailable";
                                  #longitude;
                                  #latitude;
                                  constructor(/*...*/) {/*...*/}
                                  set position(/*...*/) {/*...*/}
                                  get position() {
                                    return {
                                      latitude: this.#latitude;
                                      longitude: this.#longitude;
                                    };
                                  };
                                };
                            ]]>
                        </code-block>
                    </td>
                </tr>
            </table>

            <note>
                <p>
                    <b>
                        Statische Methoden sind Methoden am Funktionsobjekt
                    </b>
                </p>

                <p>
                    Da die Klassensyntax inklusive des Schlüsselwortes <code>static</code> ja letztendlich nur eine
                    syntaktische Verfeinerung der pseudoklassischen Objektorientierung darstellt, sind auch statische
                    Methoden eigentlich Methoden, die an dem jeweiligen Funktionsobjekt definiert werden, und statische
                    Eigenschaften eigentlich Eigenschaften des Funktionsobjekts.
                </p>
            </note>
        </chapter>
    </chapter>

    <chapter id="globale-objekte" title="Globale Objekte - »built-in objects«">
        <p>
            Der Begriff »built-in objekts« ist ein allgemein akzeptierter Begriff, der z.B. im ECMA-Script-Standard oder
            in den MDN (Mozilla Developer Network) Web Docs verwendet wird, die wahrscheinlich die umfassendste Hilfe
            für Webentwickler darstellen. Viele dieser Objekte, wie <code>Math</code> und <code>JSON</code>, sind
            eigentlich ganz normale Objekte. Wir verwenden sie, indem wir den Namen des Objekts und die Methode oder
            Eigenschaft angeben, die für dieses Objekt spezifisch sind, zum Beispiel: <code>JSON.stringify()</code>.
        </p>

        <p>
            Allerdings sind nicht alle »built-in objekts« gewöhnliche Objekte. Es handelt sich lediglich um einen
            Oberbegriff, unter dem sich in vielen Fällen auch eingebaute Klassen oder Funktionen wie <code>Object</code>
            oder <code>Date</code> verbergen. In JavaScript ist alles außer Primitiven ein Objekt, einschließlich
            Klassen und Funktionen. Daher wurde eine einheitliche Namenskonvention für alle in die Sprache eingebauten
            Elemente (Objekte, Klassen, Funktionen, Konstruktoren) eingeführt.
        </p>

        <p>
            Die Unterscheidung zwischen statischen und prototypischen Feldern ist für uns wichtig, da die meisten der
            von uns behandelten eingebauten Objekte beide verwenden werden. Wenn wir diesen Unterschied nicht verstehen,
            werden wir sowohl mit der Dokumentation, die die ausgewählten Objekte beschreibt, als auch mit deren
            korrekter Verwendung Probleme haben.
        </p>

        <p>
            Bei den globalen Objekten unterscheidet man zwischen Objekte primitiver Datentypen (<code>Boolean</code>,
            <code>Number</code>, <code>String</code>, <code>Date</code>, ...); Objekte komplexer Datentypen (=
            <code>Array</code>,<code>Set</code>, <code>Map</code>, <code>Object</code>, ...) und Objekte welche keinen
            eigener Datentyp sind (= <code>JSON</code>, <code>Math</code>, <code>RegExp</code>, ...).
        </p>

        <chapter id="globale-objekte-primitiver-datentypen" title="Objekte primitiver Datentypen">
            <p>
                Es gibt insgesamt sieben primitive Datentypen, von denen die wichtigsten <code>boolean</code>,
                <code>number</code> und <code>string</code> sind. Da es sich nicht um Objekte handelt, haben sie
                keine Methoden oder Eigenschaften. Die Daten jedes dieser Typen, die in Variablen gespeichert werden,
                sind reine Werte, die in dem entsprechenden Format im Speicher abgelegt werden. Für jeden der primitiven
                Datentypen gibt es in JS jedoch einen speziellen Konstruktor (den man wie eine Klasse behandeln kann):
                <code>Boolean</code>, <code>Number</code> und <code>String</code>.
            </p>

            <p>
                Wenn wir eine Instanz eines Strings in einer Variablen speichern, belegen sie inkomparabel mehr Speicher
                als der primitive Wert. Wenn wir die Punktnotation für ein Primitiv verwenden, geben wir an, dass wir
                eine Methode oder eine Eigenschaft eines primitiven Wertes (das weder eine Eigenschaft noch eine
                Eigenschaft seiner Methoden hat) verwenden wollen, dann wandelt es die Engine direkt in das
                entsprechende Objekt um. Das temporäre Objekt wird nur so lange im Speicher gehalten, bis der Vorgang
                abgeschlossen ist; danach wird es von der JavaScript-Engine freigegeben. Eine solche Operation hat
                natürlich Auswirkungen auf die Leistung der Engine, aber der auf diese Weise eingesparte Speicher ist es
                wert. Dieses Verhalten der JavaScript-Engine wird als <b>Autoboxing</b> bezeichnet.
            </p>

            <chapter id="globale-objekte-boolean" title="Boolean">
                <p>
                    Ein <code>Boolean</code>-Objekt hat keine statischen Eigenschaften. Es hat nur folgende Methoden:
                </p>

                <table style="header-row">
                    <tr>
                        <td>
                            Methode
                        </td>
                        <td>
                            Beschreibung
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                toString()
                            </code>
                        </td>
                        <td>
                            Gibt den logischen Wert des Boolean-Objekts in Form eines strings zurück.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                valueOf()
                            </code>
                        </td>
                        <td>
                            Gibt den Wert des <code>Boolean</code>-Objekts in Form eines primitiven Datentyps zurück.
                        </td>
                    </tr>
                </table>
            </chapter>

            <chapter id="globale-objekte-number" title="Number">
                <p>
                    Der kleinste Wert ist <code>-(2^53-1)</code> und der größte <code>(2^53-1)</code>. Es ist zwar
                    möglich Werte außerhalb dies Bereichs einer Variable als Datentyp <code>number</code> zuzuweisen,
                    aber Berechnungen, welche damit erfolgen könnten, unpräzise oder gar nicht durchgeführt werden.
                    Dafür
                    verwendet man <code>BigInt</code>.
                </p>

                <!-- TODO: Beschreibung ergänzen -->
                <table style="header-row">
                    <tr>
                        <td>
                            Methode
                        </td>
                        <td>
                            Beschreibung
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                toString()
                            </code>
                        </td>
                        <td>

                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                valueOf()
                            </code>
                        </td>
                        <td>

                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                toExponential(fractionDigits)
                            </code>
                        </td>
                        <td>

                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                toFixed(digits)
                            </code>
                        </td>
                        <td>

                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                toLocaleString(locales [, options])
                            </code>
                        </td>
                        <td>

                        </td>
                    </tr>
                </table>
            </chapter>

            <chapter id="globale-objekte-string" title="String">
                <p>
                    Zeichenketten, sogenannte Strings, sind vergleichbar mit Arrays, wobei jedes Zeichen innerhalb der
                    Zeichenkette quasi ein Element dieses imaginären Arrays einnimmt. Das erste Zeichen steht also an
                    Position (bzw. Index) <code>0</code>, das zweite Zeichen an Position (bzw. Index) <code>1</code>
                    usw. Beispiel einer Zeichenkette <code>"Max Mustermann"</code>:
                </p>

                <table style="header-column">
                    <tr>
                        <td>
                            Index
                        </td>
                        <td>
                            <code>
                                0
                            </code>
                        </td>
                        <td>
                            <code>
                                1
                            </code>
                        </td>
                        <td>
                            <code>
                                2
                            </code>
                        </td>
                        <td>
                            <code>
                                3
                            </code>
                        </td>
                        <td>
                            <code>
                                4
                            </code>
                        </td>
                        <td>
                            <code>
                                5
                            </code>
                        </td>
                        <td>
                            <code>
                                6
                            </code>
                        </td>
                        <td>
                            <code>
                                7
                            </code>
                        </td>
                        <td>
                            <code>
                                8
                            </code>
                        </td>
                        <td>
                            <code>
                                9
                            </code>
                        </td>
                        <td>
                            <code>
                                10
                            </code>
                        </td>
                        <td>
                            <code>
                                11
                            </code>
                        </td>
                        <td>
                            <code>
                                12
                            </code>
                        </td>
                        <td>
                            <code>
                                13
                            </code>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            Wert
                        </td>
                        <td>
                            <code>
                                M
                            </code>
                        </td>
                        <td>
                            <code>
                                a
                            </code>
                        </td>
                        <td>
                            <code>
                                x
                            </code>
                        </td>
                        <td>
                            <code>

                            </code>
                        </td>
                        <td>
                            <code>
                                M
                            </code>
                        </td>
                        <td>
                            <code>
                                u
                            </code>
                        </td>
                        <td>
                            <code>
                                s
                            </code>
                        </td>
                        <td>
                            <code>
                                t
                            </code>
                        </td>
                        <td>
                            <code>
                                e
                            </code>
                        </td>
                        <td>
                            <code>
                                r
                            </code>
                        </td>
                        <td>
                            <code>
                                m
                            </code>
                        </td>
                        <td>
                            <code>
                                a
                            </code>
                        </td>
                        <td>
                            <code>
                                n
                            </code>
                        </td>
                        <td>
                            <code>
                                n
                            </code>
                        </td>
                    </tr>
                </table>

                <p>
                    Wie bei einem Array kann auch bei einem String die länge (in diesem Fall die Anzahl der Zeichen)
                    über die <code>length</code>-Eigenschaft ermittelt werden.
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        let nameLength = "Max Mustermann".length // => 14
                    ]]>
                </code-block>

                <chapter id="globale-objekte-string-verkettung" title="Verkettung von Strings">
                    <p>
                        In JavaScript ist das Zeichen <code>+</code> doppelt belegt. Für Zahlen (Datentyp:
                        <code>number</code>) dient es als Additionsoperator und bei Strings als Verkettungsoperator.
                    </p>

                    <code-block lang="javascript">
                        <![CDATA[
                            let name = "Felix";
                            console.log("Hi " + name + "!");
                        ]]>
                    </code-block>
                </chapter>

                <chapter id="globale-objekte-string-template" title="Template Strings">
                    <p>
                        Als Alternative zum Verkettungsoperator können Variablen direkt innerhalb von Strings angegeben
                        werden. Die sogenannte Template String Substitution erspart das Hantieren mit Anführungszeichen
                        und dem Verkettungsoperartor. Um eine Variable im Template String zu kennzeichnen, wird die
                        Variable innerhalb von geschwungenen Klammern gesetzt wovor noch ein Dollarzeichen gesetzt wird:
                        <code>${name}</code>. Damit JS erkennt, dass es sich um einen Template String handelt wird der
                        String nicht mit normalen Anführungszeichen, sondern mit sogenannten Backticks gekennzeichnet.
                    </p>

                    <code-block lang="javascript">
                        <![CDATA[
                            let name = prompt("Bitte gib deinen Namen ein!");
                            console.log('Hi ${name}!');
                        ]]>
                    </code-block>
                </chapter>

                <chapter id="globale-objekte-string-backslash-und-zeilenumbrueche" title="Backslash und Zeilenumbrüche">
                    <p>
                        Mit Backslash + n = <code>\n</code> erzeugt man einen Zeilenumbruch innerhalb eines Strings. Es
                        besteht aber auch die Möglichkeit, dass \n innerhalb eines Textes vorkommt (z.B. Pfadangabe)
                        wobei dann in dem Fall eine neue Zeile erzeugt wird. Um das zu verhindern setzt man vor dem
                        Backslash einen weiteren Backslash.
                    </p>
                </chapter>

                <chapter id="globale-objekte-string-methoden" title="Methoden für Strings">
                    <table style="both">
                        <tr>
                            <td>
                                Methode
                            </td>
                            <td>
                                Zweck
                            </td>
                            <td>
                                Beispiel <code>let s = "abcde"</code>
                            </td>
                            <td>
                                Rückgabewert
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>
                                    charAt
                                </code>
                            </td>
                            <td>
                                Ermittelt das Zeichen an der angegebenen Stelle.
                            </td>
                            <td>
                                <code>
                                    s.charAt(1)
                                </code>
                            </td>
                            <td>
                                <code>
                                    b
                                </code>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>
                                    includes
                                </code>
                            </td>
                            <td>
                                Prüft, ob der String den angegebenen Teilstring enthält.
                            </td>
                            <td>
                                <code>
                                    s.includes("bc")
                                </code>
                            </td>
                            <td>
                                <code>
                                    true
                                </code>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>
                                    startsWith
                                </code>
                            </td>
                            <td>
                                Prüft, ob der String mit dem angegebenen Teilstring beginnt.
                            </td>
                            <td>
                                <code>
                                    s.startsWith("ab")
                                </code>
                            </td>
                            <td>
                                <code>
                                    true
                                </code>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>
                                    endsWith
                                </code>
                            </td>
                            <td>
                                Prüft, ob der String mit dem angegebenen Teilstring endet
                            </td>
                            <td>
                                <code>
                                    s.endsWith("de")
                                </code>
                            </td>
                            <td>
                                <code>
                                    true
                                </code>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>
                                    indexOf
                                </code>
                            </td>
                            <td>
                                Ermittelt die Position des angegebenen Teilstrings innerhalb des Strings (Suche beginnt
                                von hinten)
                            </td>
                            <td>
                                <code>
                                    s.indexOf("cd")
                                </code>
                            </td>
                            <td>
                                <code>
                                    2
                                </code>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>
                                    lastIndexOf
                                </code>
                            </td>
                            <td>
                                Ermittelt die Position des angegebenen Teilstring innerhalb des Strings (Suche beginnt
                                von hinten)
                            </td>
                            <td>
                                <code>
                                    s.lastIndexOf("de")
                                </code>
                            </td>
                            <td>
                                <code>
                                    3
                                </code>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>
                                    repeat
                                </code>
                            </td>
                            <td>
                                Widerholt den String so oft wie angegeben
                            </td>
                            <td>
                                <code>
                                    s.repeat(2)
                                </code>
                            </td>
                            <td>
                                <code>
                                    abcdeabcde
                                </code>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>
                                    substring
                                </code>
                            </td>
                            <td>
                                Extrahiert einen Teilstring an der angegebenen Position (von, bis)
                            </td>
                            <td>
                                <code>
                                    s.substr(1, 3)
                                </code>
                            </td>
                            <td>
                                <code>
                                    bcd
                                </code>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>
                                    substr
                                </code>
                            </td>
                            <td>
                                Extrahiert einen Teilstring an der angegebenen Position (von, länge)
                            </td>
                            <td>
                                <code>
                                    s.substr(1, 3)
                                </code>
                            </td>
                            <td>
                                <code>
                                    bcd
                                </code>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>
                                    toLowerCase
                                </code>
                            </td>
                            <td>
                                Gibt den String in Kleinschreibung zurück
                            </td>
                            <td>
                                <code>
                                    "AbCdE".toLowerCase()
                                </code>
                            </td>
                            <td>
                                <code>
                                    abcde
                                </code>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>
                                    toUpperCase
                                </code>
                            </td>
                            <td>
                                Gibt den String in Großschreibung zurück
                            </td>
                            <td>
                                <code>
                                    "AbCdE".toUpperCase()
                                </code>
                            </td>
                            <td>
                                <code>
                                    ABCDE
                                </code>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>
                                    trim
                                </code>
                            </td>
                            <td>
                                Entfernt Leerzeichen am Anfang und am Ende
                            </td>
                            <td>
                                <code>
                                    " abc ".trim()
                                </code>
                            </td>
                            <td>
                                <code>
                                    abc
                                </code>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>
                                    slice
                                </code>
                            </td>
                            <td>
                                Extrahiert den Teil einer Zeichenkette welcher mit dem übergebenen Start- und
                                (optionalen) Endindex definiert wird.
                            </td>
                            <td>
                                <p>
                                    <code>
                                        s.slice(2, 5)
                                    </code>
                                </p>

                                <p>
                                    <code>
                                        s.slice(2)
                                    </code>
                                </p>
                            </td>
                            <td>
                                <code>
                                    cde
                                </code>
                            </td>
                        </tr>
                    </table>
                </chapter>
            </chapter>

            <tip>
                Unterschied zwischen <code>slice()</code>, <code>substr()</code> und <code>substring()</code>:
                <a href="https://stackoverflow.com/questions/2243824/what-is-the-difference-between-string-slice-and-string-substring"/>
            </tip>

            <chapter id="globale-objekte-primitiver-datentypen-pad-start-und-end"
                     title="Die Methoden padStart() und padEnd()">
                <p>
                    Die Methoden <code>padStart()</code> und <code>padEnd()</code> wurden mit der Version ES2017
                    eingeführt. Beide Methoden füllen eine gegebene Zeichenkette. Beide Methoden füllen eine gegebene
                    Zeichenkette vorne (<code>padStart()</code>) oder hinten (<code>padEnd()</code>) mit einer weiteren
                    Zeichenkette auf, bis eine bestimmte Länge erreicht wird. Der Ausdruck <code>'Hallo'.padStart(9,
                    'H')</code> beispielsweise sorgt dafür, dass die Zeichenkette <code>Hallo</code> bis zu der Länge 9
                    vorne mit der Zeichenkette »H« aufgefüllt wird, was in der Zeichenkette <code>HHHHHallo</code>
                    resultiert. Umgekehrt sorgt <code>'Hallo'.padEnd(9, 'o')</code> dafür, dass die Zeichenkette (wieder
                    bis zu der Länge 9) hinten mit der Zeichenkette »o« aufgefüllt wird, was die Zeichenkette
                    <code>Hallooooo</code> ergibt.
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        for (let i=1; i<15; i++) {
                          console.log(`${i}`.padStart(3,'0'));
                        }

                        // Ausgabe hintereinander:
                        // "001", "002", "003", "004", "005"
                        // "006", "007", "008", "009", "010"
                        // "011", "012", "013", "014"

                        for (let i=1; i<15; i++) {
                          console.log(`${i}`.padEnd(3,'0'));
                        }

                        // Ausgabe hintereinander:
                        // "100", "200", "300", "400", "500"
                        // "600", "700", "800", "900", "100"
                        // "110", "120", "130", "140"
                    ]]>
                </code-block>
            </chapter>

            <chapter id="globale-objekte-date" title="Date - mit Datum und Zeit arbeiten">
                <p>
                    Für das Arbeiten mit Datums- und Zeitangaben stellt JavaScript das Objekt <code>Date</code> zur
                    Verfügung. Um auf Datums- und Zeitangaben zugreifen zu können, muss zunächst eine Instanz von Date
                    erzeugt werden. Dabei können Argumente übergeben, aber auch weggelassen werden. In letzterem Fall
                    wird eine Instanz erzeugt, die das aktuelle Datum und die aktuelle Zeit repräsentiert. Anschließend
                    können über dieses Date-Objekt mehrere Methoden ausgeführt werden.
                </p>

                <table>
                    <tr>
                        <td>
                            Methode
                        </td>
                        <td>
                            Beschreibung
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                getDate
                            </code>
                        </td>
                        <td>
                            Gibt den Monatstag (1–31) für das jeweilige Datum zurück.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                getDay
                            </code>
                        </td>
                        <td>
                            Gibt den Wochentag (0–6) für das jeweilige Datum zurück.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                getFullYear
                            </code>
                        </td>
                        <td>
                            Gibt das Jahr für das jeweilige Datum zurück.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                getHours
                            </code>
                        </td>
                        <td>
                            Gibt die Stunde für das jeweilige Datum zurück.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                getMilliseconds
                            </code>
                        </td>
                        <td>
                            Gibt die Millisekunden (0–999) für das jeweilige Datum zurück.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                getMinutes
                            </code>
                        </td>
                        <td>
                            Gibt die Minuten (0–59) für das jeweilige Datum zurück.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                getMonth
                            </code>
                        </td>
                        <td>
                            Gibt den Monat (0–11) für das jeweilige Datum zurück.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                getSeconds
                            </code>
                        </td>
                        <td>
                            Gibt die Sekunden (0–59) für das jeweilige Datum zurück.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                getTime
                            </code>
                        </td>
                        <td>
                            Liefert die Anzahl an Millisekunden, die seit dem 01. Januar 1970, 00:00:00 UTC für das
                            jeweilige Datum vergangen sind.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                getYear
                            </code>
                        </td>
                        <td>
                            Gibt das Jahr für das jeweilige Datum zurück. Diese Methode ist jedoch veraltet. Stattdessen
                            sollten Sie die Methode <code>Date.prototype.getFullYear()</code> verwenden.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                setDate(dayValue)
                            </code>
                        </td>
                        <td>
                            Setzt den Tag im Monat für das jeweilige Datum.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                setFullYear( yearValue [, monthValue [, dayValue]])
                            </code>
                        </td>
                        <td>
                            Setzt das Jahr für das jeweilige Datum. Optional können Monat (0–11) und Tag (1–31)
                            angegeben werden.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                setHours( hoursValue [, minutesValue [, secondsValue [, msValue]]])
                            </code>
                        </td>
                        <td>
                            Setzt die Stunden für das jeweilige Datum. Optional können Minuten (0–59), Sekunden (0–59)
                            und Millisekunden (0–999) angegeben werden.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                setMilliseconds(millisecondsValue)
                            </code>
                        </td>
                        <td>
                            Setzt die Millisekunden (0–999) für das jeweilige Datum.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                setMinutes( minutesValue [, secondsValue [, msValue]])
                            </code>
                        </td>
                        <td>
                            Setzt die Minuten (0–59) für das jeweilige Datum. Optional können Sekunden (0–59) und
                            Millisekunden (0–999) angegeben werden.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                setMonth( monthValue [, dayValue])
                            </code>
                        </td>
                        <td>
                            Setzt den Monat (0–11) für das jeweilige Datum. Optional kann der Tag (1–31) angegeben
                            werden.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                setSeconds( secondsValue [, msValue])
                            </code>
                        </td>
                        <td>
                            Setzt die Sekunden (0–59) für das jeweilige Datum. Optional können Millisekunden (0–999)
                            angegeben werden.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                setTime(timeValue)
                            </code>
                        </td>
                        <td>
                            Setzt das Datum und die Zeit auf Basis eines Zahlenwertes, der die Millisekunden angibt, die
                            seit dem 01. Januar 1970, 00:00:00 UTC vergangen sind.
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code>
                                setYear()
                            </code>
                        </td>
                        <td>
                            veraltet.
                        </td>
                    </tr>
                </table>
            </chapter>

            <p>
                Wird eine Instanz von Date erstellt, dann gibt es bezüglich der Argumente verschiedene Möglichkeiten:
            </p>

            <list type="bullet">
                <li>
                    <b>Ohne Argumente</b> wird ein Objekt erstellt, welches das aktuelle Datum und die aktuelle Zeit
                    repräsentiert.
                </li>
                <li>
                    Übergibt man als Argument <b>einen Zahlenwert</b>, wird dieser als die Anzahl an Millisekunden
                    gewertet, die seit dem 01.01.1970 vergangen sind, sprich ein Objekt erzeugt, welches den
                    entsprechenden Zeitpunkt repräsentiert.
                </li>
                <li>
                    Alternativ kann man auch <b>eine Zeichenkette</b> übergeben, die nach dem IETF-Standard RFC 2822
                    aufgebaut ist und eine entsprechende Datumsangabe enthält. (beispielsweise "02 14 2015" für den
                    14.02.2015)
                </li>
            </list>

            <chapter id="globale-objekte-primitiver-datentypen-wrapperobjekte"
                     title="Wrapperobjekte für primitive Datentypen">
                <p>
                    Auch für die beiden primitiven Datentypen der Zahlen und der booleschen Werte gibt es jeweils eigene
                    Objekte: <code>Number</code> repräsentiert Zahlenwerte, <code>Boolean</code> entsprechende boolesche
                    Werte. Diese Objekte nennt man auch (wie übrigens auch <code>String</code>) Wrapperobjekte, weil sie
                    wie eine Hülle um primitive Werte fungieren können und diese beispielsweise um Methoden erweitern.
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        let number2 = new Number(2);
                        let number4711 = new Number(4711);
                        console.log(number2.toExponential());       // 2e+0
                        console.log(number4711.toExponential());    // 4.711e+3
                    ]]>
                </code-block>
            </chapter>
        </chapter>

        <chapter id="globale-objekte-array" title="Arrays">
            <chapter id="globale-objekte-array-erzeugen" title="Arrays erzeugen und initialisieren">
                <p>
                    Arrays können in JavaScript auf zwei verschiedene Arten erzeugt werden: über eine sogenannte
                    Konstruktorfunktion und die Kurzschreibweise, der Array-Literal-Schreibweise.
                </p>

                <chapter id="globale-objekte-array-erzeugen-konstruktorfunktion" title="Die Konstruktorfunktion">
                    <code-block lang="javascript">
                        <![CDATA[
                            let names = new Array();                        // Erzeugen eines Arrays
                            let names = new Array(20);                      // Erzeugen eines Arrays mit bestimmter Länge
                            let names = new Array('Max', 'Moriz', 'Peter'); // Erzeugen eines Arrays mit vorgegebenen Werten
                        ]]>
                    </code-block>

                    <p>
                        Hierbei ist immer zu beachten, dass wenn die Konstruktorfunktion <code>Array()</code> mit einem
                        einzigen Wert aufgerufen wird und dieser Wert eine Zahl ist, wird darüber die Länge des Arrays
                        definiert. Wird die Konstruktorfunktion mit zwei Zahlen als Argumenten aufgerufen, ist die Länge
                        des Arrays implizit zwei und das Array enthält die beiden Zahlenelemente.
                    </p>

                    <p>
                        Im Falle von Arrays kann beim Aufruf der Konstruktorfunktion auch das
                        <code>new</code>-Schlüsselwort weggelassen werden:
                    </p>

                    <code-block lang="javascript">
                        <![CDATA[
                            let names = Array('Max', 'Moriz', 'Peter');
                        ]]>
                    </code-block>
                </chapter>

                <chapter id="globale-objekte-array-erzeugen-literal-schreibweise"
                         title="Die Array-Literal-Schreibweise">
                    <p>
                        Da man es als Entwickler in der Praxis relativ häufig mit Arrays zu tun hat bzw. relativ häufig
                        Arrays benötigt, gibt es in JavaScript eine praktische Kurzschreibweise, um Arrays zu erzeugen.
                        Dabei werden die einzelnen Werte in eckigen Klammern geschrieben:
                    </p>

                    <code-block lang="javascript">
                        <![CDATA[
                            let names = ['Max', 'Moritz', 'Peter']; // Erzeugen eines Arrays mit bestimmten Werten
                            let colors = [];                        // Erzeugen eines leeren Arrays
                        ]]>
                    </code-block>
                </chapter>

                <chapter id="globale-objekte-array-erzeugen-typen" title="Unterschiedliche Typen in Arrays">
                    <p>
                        Im Gegensatz zu anderen Sprachen ist es in JavaScript möglich, in einem einzelnen Array auch
                        Werte unterschiedlichen Typs zu speichern. Das heißt, es können sowohl Zeichenketten als auch
                        Zahlen in ein und demselben Array gespeichert werden.
                    </p>

                    <code-block lang="javascript">
                        <![CDATA[
                            let values = [ 'Max', 4711, true ]
                        ]]>
                    </code-block>
                </chapter>
            </chapter>

            <chapter id="globale-objekte-array-elemente" title="Auf Elemente eines Arrays zugreifen">
                <p>
                    Arrays verfügen wie Objekte über verschiedene Schlüssel-Wert-Paare, wobei die Schlüssel Indexnummern
                    sind. Wie in der Informatik üblich, beginnt die Zählung bei 0, d. h., an Index 0 steht das erste
                    Element, an Index 1 das zweite Element usw. Über den <b>Indexoperator</b> kann man auf Elemente
                    innerhalb des Arrays zugreifen. Dabei verwendet man eckige Klammern, um den Index anzugeben, auf den
                    man zugreifen möchte. Mit der Eigenschaft <code>length</code> kann die Anzahl der sich im Array
                    befindenden Elemente ermittelt werden.
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        let todoList = [
                          'Bad putzen',             // Element an Index 0
                          'Einkaufen',              // Element an Index 1
                          'Aufräumen',              // Element an Index 2
                          'Rasen mähen'             // Element an Index 3
                        ];

                        console.log(todoList[0]);   // => "Bad putzen"
                        console.log(todoList[1]);   // => "Einkaufen"
                        console.log(todoList[2]);   // => "Aufräumen"
                        console.log(todoList[3]);   // "Rasen mähen"
                    ]]>
                </code-block>

                <p>
                    Häufig werden <code>for</code>-Schleifen dazu verwendet, um über Arrays zu iterieren und die
                    einzelnen Elemente zu verarbeiten.
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        for (let i = 0; i < todoList.length; i++) {
                          console.log(todoList[i]);
                        }
                    ]]>
                </code-block>
            </chapter>

            <chapter id="globale-objekte-array-funktionen" title="Funktionen für Arrays">
                <p>
                    Hier ein Überblick, um zu schildern, was man mit Arrays alles anstellen kann:
                </p>

                <list type="bullet">
                    <li>
                        <b>Elemente hinzufügen und entfernen:</b> über die Methoden <code>push()</code>,
                        <code>pop()</code>, <code>shift()</code> und <code>unshift()</code> lassen sich Elemente
                        hinzufügen und entfernen.
                    </li>
                    <li>
                        <b>Array als Stacks und Queues verwenden:</b> In anderen Programmiersprachen gibt es teilweise
                        fest in die jeweilige Sprache eingebaute Datenstrukturen wie beispielsweise Stacks und Queues.
                        In JavaScript gibt es (bis zu ES6) nur Arrays (seit ES6 gibt es Sets und Maps). Dafür kann man
                        Arrays dank der Methoden <code>push()</code>, <code>pop()</code>, <code>shift()</code> und
                        <code>unshift()</code> aber wie die Datenstrukturen Stack und Queue nutzen.
                    </li>
                    <li>
                        <b>Arrays sortieren:</b> Die einzelnen Elemente eines Arrays lassen sich über die beiden
                        Methoden <code>reverse()</code> und <code>sort()</code> nach bestimmten Kriterien sortieren.
                    </li>
                    <li>
                        <b>Elemente im Array finden:</b> Für das Finden von Elementen in einem Array gibt es
                        verschiedene Methoden, u.a. die Methoden <code>indexOf()</code> und <code>lastIndexOf()</code>.
                    </li>
                    <li>
                        <b>Funktionale Aspekte:</b> Arrays verfügen über verschiedene Methoden, die die sogenannte
                        funktionale Programmierung unterstützen: <code>every()</code>, <code>filter()</code>,
                        <code>forEach()</code>, <code>map()</code>, <code>some()</code> und <code>reduce()</code>.
                        Diese Funktionen werden auch Higher-Order-Funktionen genannt.
                    </li>
                </list>

                <chapter id="globale-objekte-array-funktionen-liste" title="Liste der Funktionen">
                    <table style="both">
                        <tr>
                            <td>
                                Funktion
                            </td>
                            <td>
                                Zweck
                            </td>
                            <td>
                                Beispielaufruf
                            </td>
                            <td>
                                <code>
                                    a.join("")
                                </code>
                            </td>
                            <td>
                                Rückgabewert (Datentyp)
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>
                                    push
                                </code>
                            </td>
                            <td>
                                fügt Elemente am Ende des Arrays an
                            </td>
                            <td>
                                <code>
                                    abcdxy
                                </code>
                            </td>
                            <td>
                                <code>
                                    abcdxy
                                </code>
                            </td>
                            <td>
                                <code>
                                    6 (number)
                                </code>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>
                                    pop
                                </code>
                            </td>
                            <td>
                                entfernt das Element am Ende des Arrays
                            </td>
                            <td>
                                <code>
                                    abc
                                </code>
                            </td>
                            <td>
                                <code>
                                    abc
                                </code>
                            </td>
                            <td>
                                <code>
                                    d (string)
                                </code>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>
                                    unshift
                                </code>
                            </td>
                            <td>
                                fügt am Anfang des Arrays an
                            </td>
                            <td>
                                <code>
                                    xyabcd
                                </code>
                            </td>
                            <td>
                                <code>
                                    xyabcd
                                </code>
                            </td>
                            <td>
                                <code>
                                    6 (number)
                                </code>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>
                                    shift
                                </code>
                            </td>
                            <td>
                                entfernt das Element am Anfang des Arrays
                            </td>
                            <td>
                                <code>
                                    bcd
                                </code>
                            </td>
                            <td>
                                <code>
                                    bcd
                                </code>
                            </td>
                            <td>
                                <code>
                                    a (string)
                                </code>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>
                                    slice
                                </code>
                            </td>
                            <td>
                                fertigt eine Kopie von einem Teil des Arrays an
                            </td>
                            <td>
                                <code>
                                    abcd
                                </code>
                            </td>
                            <td>
                                <code>
                                    abcd
                                </code>
                            </td>
                            <td>
                                <code>
                                    c,d (array)
                                </code>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>
                                    splice
                                </code>
                            </td>
                            <td>
                                <p>
                                    entfernt und/oder ergänzt Elemente im Array:
                                </p>
                                <p>
                                    <code>
                                        splice(start, deleteCount, item1, item2, /* …, */ itemN)
                                    </code>
                                </p>
                            </td>
                            <td>
                                <code>
                                    a.splice(2, 2, "x");
                                </code>
                            </td>
                            <td>
                                <code>
                                    abx
                                </code>
                            </td>
                            <td>
                                <code>
                                    c,d (array)
                                </code>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>
                                    sort
                                </code>
                            </td>
                            <td>
                                sortiert das Array
                            </td>
                            <td>
                                <code>
                                    a.sort()
                                </code>
                            </td>
                            <td>
                                <code>
                                    abcd
                                </code>
                            </td>
                            <td>
                                <code>
                                    a,b,c,d (array)
                                </code>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>
                                    reverse
                                </code>
                            </td>
                            <td>
                                kehrt die Reihenfolge der Elemente um
                            </td>
                            <td>
                                <code>
                                    a.reverse()
                                </code>
                            </td>
                            <td>
                                <code>
                                    dcba
                                </code>
                            </td>
                            <td>
                                <code>
                                    d,c,b,a (array)
                                </code>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>
                                    concat
                                </code>
                            </td>
                            <td>
                                Verbindet ein Array mit einem oder mehreren Elementen oder Arrays
                            </td>
                            <td>
                                <code>
                                    a.concat(["x", "y"])
                                </code>
                            </td>
                            <td>
                                <code>
                                    abcd
                                </code>
                            </td>
                            <td>
                                <code>
                                    a,b,c,d,x,y (array)
                                </code>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>
                                    fill
                                </code>
                            </td>
                            <td>
                                Befüllt alle Elemente mit einem Wert
                            </td>
                            <td>
                                <code>
                                    a.fill("x")
                                </code>
                            </td>
                            <td>
                                <code>
                                    xxxx
                                </code>
                            </td>
                            <td>
                                <code>
                                    x,x,x,x (array)
                                </code>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>
                                    includes
                                </code>
                            </td>
                            <td>
                                Prüft, ob ein Element im Array vorkommt (seit ES2016)
                            </td>
                            <td>
                                <code>
                                    a.includes("x")
                                </code>
                            </td>
                            <td>
                                <code>
                                    abcd
                                </code>
                            </td>
                            <td>
                                <code>
                                    false (boolean)
                                </code>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>
                                    indexOf
                                </code>
                            </td>
                            <td>
                                Ermittelt die Position (index) eines Elements im Array
                            </td>
                            <td>
                                <code>
                                    a.indexOf("c")
                                </code>
                            </td>
                            <td>
                                <code>
                                    abcd
                                </code>
                            </td>
                            <td>
                                <code>
                                    2 (number)
                                </code>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>
                                    lastIndexOf
                                </code>
                            </td>
                            <td>
                                Ermittelt die Position (index) eines Elements im Array (vom Ende her)
                            </td>
                            <td>
                                <code>
                                    a.indexOf("c")
                                </code>
                            </td>
                            <td>
                                <code>
                                    abcd
                                </code>
                            </td>
                            <td>
                                <code>
                                    2 (number)
                                </code>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>
                                    split
                                </code>
                            </td>
                            <td>
                                Zerlegt einen String anhand eines Separators in ein Array.
                            </td>
                            <td>
                                <code>
                                    ("a-b-c-d").split("-")
                                </code>
                            </td>
                            <td>
                                <code>
                                    abcd
                                </code>
                            </td>
                            <td>
                                <code>
                                    a,b,c,d (array)
                                </code>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>
                                    join
                                </code>
                            </td>
                            <td>
                                Verbindet alle Elemente eines Arrays zu String
                            </td>
                            <td>
                                <code>
                                    a.join("==")
                                </code>
                            </td>
                            <td>
                                <code>
                                    abcd
                                </code>
                            </td>
                            <td>
                                <code>
                                    a==b==c==d (string)
                                </code>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>
                                    toString
                                </code>
                            </td>
                            <td>
                                Wie join, verwendet aber das Komma als festen Separator
                            </td>
                            <td>
                                <code>
                                    a.toString()
                                </code>
                            </td>
                            <td>
                                <code>
                                    abcd
                                </code>
                            </td>
                            <td>
                                <code>
                                    a,b,c,d (string)
                                </code>
                            </td>
                        </tr>
                    </table>
                </chapter>
            </chapter>

            <chapter id="globale-objekte-array-higher-order-funktionen" title="Higher-Order-Funktionen">
                <list type="bullet">
                    <li>
                        <p>
                            <b>
                                <code>
                                    map()
                                </code>
                            </b>
                        </p>

                        <p>
                            die Funktion <code>map()</code> (= abbilden) ermöglicht es ein komplettes Array zu
                            transformieren. Sie benötigt dafür ein Ausgangs-Array und eine Funktion als Argument. Sie
                            erzeugt das Ergebnis-Array, indem sie jedes einzelne Element des Ausgangs-Arrays mithilfe
                            der übergebenen Funktion transformiert.
                        </p>

                        <code-block lang="javascript">
                            <![CDATA[
                                let names = [ "Adelgunde", "Heribert", "Felix" ];
                                let reverseName = name => name.split("").reverse().join();
                                let reversedNames = names.map(reverseName);   // => [ "ednugledA", "trebireH", "xileF" ]
                            ]]>
                        </code-block>
                    </li>
                    <li>
                        <p>
                            <b>
                                <code>
                                    filter()
                                </code>
                            </b>
                        </p>

                        <p>
                            Filtert Elemente anhand eines angegebenen Kriteriums (Bedingung).
                        </p>

                        <code-block lang="javascript">
                            <![CDATA[
                                let even = x => x%2 === 0;
                                [1, 2, 3, 4, 5].filter(even) // => [ 2, 4 ]
                            ]]>
                        </code-block>
                    </li>
                    <li>
                        <p>
                            <b>
                                <code>
                                    reduce()
                                </code>
                            </b>
                        </p>

                        <p>
                            Reduziert das Array auf einen einzigen Wert, indem es jeweils zwei Elemente durch den
                            angegebenen Callback reduziert. Optional besteht die Möglichkeit, als zweiten Parameter
                            einen Initialwert anzugeben.
                        </p>

                        <code-block lang="javascript">
                            <![CDATA[
                                [1, 2, 3, 4, 5].reduce((x, y) => x + y);      // => 1 + 2 + 3 + 4 + 5 => 15
                                [1, 2, 3, 4, 5].reduce((x, y) => x + y, 10);  // => 10 + 1 + 2 + 3 + 4 + 5 => 25
                            ]]>
                        </code-block>
                    </li>
                    <li>
                        <p>
                            <b>
                                <code>
                                    reduceRight()
                                </code>
                            </b>
                        </p>

                        <p>
                            Wie <code>reduce()</code>, aber von rechts. Auch hier kann ein optionaler Initialwert
                            angegeben werden.
                        </p>

                        <code-block lang="javascript">
                            <![CDATA[
                                [1, 2, 3, 4, 5].reduceRight((x, y) => x – y);
                                // => 5 – 4 – 3 – 2 – 1 => -5
                            ]]>
                        </code-block>
                    </li>
                    <li>
                        <p>
                            <b>
                                <code>
                                    every()
                                </code>
                            </b>
                        </p>

                        <p>
                            Gibt <code>true</code> zurück, falls alle Elemente der angegebenen Bedingung entsprechen.
                        </p>

                        <code-block lang="javascript">
                            <![CDATA[
                                let even = x => x%2 === 0;
                                [1, 2, 3, 4, 5].every(even); // => false
                            ]]>
                        </code-block>
                    </li>
                    <li>
                        <p>
                            <b>
                                <code>
                                    some()
                                </code>
                            </b>
                        </p>

                        <p>
                            Gibt <code>true</code> zurück, falls einige Elemente der angegebenen Bedingung entsprechen.
                        </p>

                        <code-block lang="javascript">
                            <![CDATA[
                                let even = x => x%2 === 0;
                                [1, 2, 3, 4, 5].some(even);  // => true
                            ]]>
                        </code-block>
                    </li>
                    <li>
                        <p>
                            <b>
                                <code>
                                    forEach()
                                </code>
                            </b>
                        </p>

                        <p>
                            Führt den Callback für jedes Element aus.
                        </p>

                        <code-block lang="javascript">
                            <![CDATA[
                                [1, 2, 3, 4, 5].forEach(x => console.log(x));
                            ]]>
                        </code-block>
                    </li>
                    <li>
                        <p>
                            <b>
                                <code>
                                    find()
                                </code>
                            </b>
                        </p>

                        <p>
                            Wurde in ES2016 eingeführt. Findet das erste Element, das die angegebene Bedingung erfüllt.
                        </p>

                        <code-block lang="javascript">
                            <![CDATA[
                                let even = x => x%2 ===> 0;
                                [1, 2, 3, 4, 5].find(even); //=> 2
                            ]]>
                        </code-block>
                    </li>
                    <li>
                        <p>
                            <b>
                                <code>
                                    findIndex()
                                </code>
                            </b>
                        </p>

                        <p>
                            Gibt den Index des ersten Elements zurück, das die angegebene Bedingung erfüllt.
                        </p>

                        <code-block lang="javascript">
                            <![CDATA[
                                let even = x => x%2 ===> 0;
                                [1, 2, 3, 4, 5].findIndex(even); //=> 1
                            ]]>
                        </code-block>
                    </li>
                </list>
            </chapter>

            <chapter id="globale-objekte-array-mehrdimensional"
                     title="Mehrdimensionale Arrays: 2D-, 3D-, ... nD-Arrays">
                <p>
                    In JavaScript gibt es keine „echten“ 2D-Arrays. Stattdessen kann man Arrays ineinander
                    verschachteln. Da es sich um die Variable innerhalb des Arrays nun wider um ein Array handelt, muss
                    ein weiterer Index angeben, um Variable zu erreichen.
                </p>

                <code-block lang="javascript">
                    <![CDATA[
                        const array2D = [
                          [ "1A", "2B", "3C" ],
                          [ "1A", "2B", "3C" ],
                          [ "1A", "2B", "3C" ],
                        ];

                        const array1D = array2D[0];    //=> [ "1A", "2B", "3C" ]
                        console.log(array1D[1]);       //=> 1B
                        console.log(array2D[1][1]);    //=> 2B
                    ]]>
                </code-block>
            </chapter>

            <chapter id="globale-objekte-array-als-stack" title="Arrays als Stack verwenden">
                <p>
                    In der Programmierung (und in der Informatik allgemein) bezeichnet ein Stack eine Datenstruktur, die
                    nach dem sogenannten LIFO-Prinzip (Last in First out) arbeitet. Das bedeutet, dass dasjenige
                    Element, welches dem Stack zuletzt hinzugefügt wurde, als Erstes wieder entfernt wird. In der Regel
                    heißt dabei die Methode für das Hinzufügen von Elementen <code>push()</code>, die Methode für das
                    Entfernen von Elementen <code>pop()</code>.
                </p>

                <img alt="Arrays als Stack verwenden" src="js-sprachkern-oop-arrays-als-stack.png"/>

                <code-block lang="javascript">
                    <![CDATA[
                        let stack = [];              // Deklaration eines ganz normalen Arrays
                        stack.push(1);               // Hinzufügen eines Elements ...
                        stack.push(2);               // ... und noch eines ...
                        stack.push(3);               // ... und noch eines ...
                        stack.push(4, 5, 6, 7, 8);   // ... und direkt mehrere auf einen Schlag
                        console.log(stack.pop());    // Zurückgegeben wird das zuletzt hinzugefügte
                                                     // Element, die 8.
                    ]]>
                </code-block>

                <p>
                    Ein praxisnahes Beispiel für die Verwendung der Stack-Datenstruktur ist die Implementierung einer
                    Undo-Funktion, sprich einer Möglichkeit innerhalb einer Anwendung, die letzte Nutzeraktion
                    rückgängig machen zu können. Alternativ zur Verwendung von <code>push()</code> und
                    <code>pop()</code> können für die Implementierung eines Stacks auch die Methoden
                    <code>shift()</code> und <code>unshift()</code> verwendet werden. Der Stack funktioniert dann genau
                    andersherum: Per <code>unshift()</code> werden Elemente vorne hinzugefügt, per <code>shift()</code>
                    wird jeweils das erste Element entfernt.
                </p>
            </chapter>

            <chapter id="globale-objekte-array-als-queue" title="Arrays als Queue verwenden">
                <p>
                    Eine Queue ist wie der Stack ebenfalls eine Datenstruktur, funktioniert aber genau umgekehrt: Eine
                    Queue nämlich gibt immer das Element zurück, welches als Erstes der in der Queue enthaltenen
                    Elemente hinzugefügt wurde (FIFO-Prinip: First in First out). In der Regel heißen die entsprechenden
                    Methoden dabei <code>enqueue()</code> für das Hinzufügen von Elementen und <code>dequeue()</code>
                    für das Entfernen von Elementen.
                </p>

                <img alt="Arrays als Queue verwenden" src="js-sprachkern-oop-arrays-als-queue.png"/>

                <code-block lang="javascript">
                    <![CDATA[
                        let queue = [];              // Deklaration eines ganz normalen Arrays
                        queue.push(1);               // Hinzufügen eines Elements ...
                        queue.push(2);               // ... und noch eines ...
                        queue.push(3);               // ... und noch eines ...
                        queue.push(4, 5, 6, 7, 8);   // ... und direkt mehrere auf einen Schlag
                        console.log(queue.shift());  // Zurückgegeben wird das zuerst hinzugefügte
                                                     // Element, die 1.
                    ]]>
                </code-block>

                <p>
                    Ein praxisnahes Beispiel für die Verwendung der Queue-Datenstruktur sind sogenannte Message Queues,
                    also Warteschlangen für Nachrichten. Alternativ zu der Verwendung von <code>push()</code> und
                    <code>shift()</code> kann für die Implementierung einer Queue auch <code>pop()</code> und
                    <code>unshift()</code> verwendet werden. Die Queue funktioniert dann genau andersherum: Per
                    <code>unshift()</code> werden Elemente vorne hinzugefügt, per <code>pop()</code> wird jeweils das
                    letzte Element entfernt.
                </p>
            </chapter>

            <chapter id="globale-objekte-array-in-zeichenketten-umwandeln" title="Arrays in Zeichenketten umwandeln">
                <code-block lang="javascript">
                    <![CDATA[
                        let names = ['Max', 'Moritz', 'Peter'];
                        console.log(names.toString());        // => Max,Moritz,Peter
                        console.log(names.toLocaleString());  // => Max,Moritz,Peter
                        console.log(names.valueOf());         // => [ "Max", "Moritz", "Peter" ]
                        console.log(names.join('-'));         // => Max-Moritz-Peter
                    ]]>
                </code-block>
            </chapter>
        </chapter>

        <chapter id="globale-objekte-math" title="Math – komplexe Berechnungen durchführen">
            <p>
                Für komplexere Berechnungen stellt JavaScript das <code>Math</code> Objekt zur Verfügung. Dieses Objekt
                stellt eine ganze Reihe verschiedener Methoden und Eigenschaften bereit, mit denen allerlei Berechnungen
                durchgeführt werden können.
            </p>

            <table>
                <tr>
                    <td>
                        Methode
                    </td>
                    <td>
                        Zweck
                    </td>
                    <td>
                        Beispiel
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            sqrt
                        </code>
                    </td>
                    <td>
                        Quadratwurzel
                    </td>
                    <td>
                        <code>Math.sqrt(9)</code> ergibt <code>3</code>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            pow
                        </code>
                    </td>
                    <td>
                        Potenzieren
                    </td>
                    <td>
                        <code>Math.pow(2, 5)</code> ergibt <code>32</code>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            cos
                        </code>
                    </td>
                    <td>
                        Kosinus
                    </td>
                    <td>
                        <code>Math.cos(0)</code> ergibt <code>1</code>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            round
                        </code>
                    </td>
                    <td>
                        kaufmännisches Runden
                    </td>
                    <td>
                        <p>
                            <code>Math.round(3.1)</code> ergibt <code>3</code>
                        </p>
                        <p>
                            <code>Math.round(3.5)</code> ergibt <code>4</code>
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            floor
                        </code>
                    </td>
                    <td>
                        Abrunden
                    </td>
                    <td>
                        <code>Math.floor(3.9)</code> ergibt <code>3</code>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            ceil
                        </code>
                    </td>
                    <td>
                        Aufrunden
                    </td>
                    <td>
                        <code>Math.ceil(3.1)</code> ergibt <code>4</code>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            max
                        </code>
                    </td>
                    <td>
                        Maximalwert aus beliebig vielen Argumenten
                    </td>
                    <td>
                        <code>Math.max(3, 7, 2)</code> ergibt <code>7</code>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            min
                        </code>
                    </td>
                    <td>
                        Minimalwert aus beliebig vielen Argumenten
                    </td>
                    <td>
                        <code>Math.min(3, 7, 2)</code> ergibt <code>2</code>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            abs
                        </code>
                    </td>
                    <td>
                        Betrag einer Zahl (ohne Vorzeichen)
                    </td>
                    <td>
                        <code>Math.abs(-3.678)</code> ergibt <code>3.678</code>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            random
                        </code>
                    </td>
                    <td>
                        Zufallszahl
                    </td>
                    <td>
                        <code>Math.random()</code> gibt eine zufällige Zahl zwischen 0 und 1 zurück, wobei die 1 nie
                        erreicht wird.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            toFixed
                        </code>
                    </td>
                    <td>
                        Runden auf beliebig vielen Nachkommastellen
                    </td>
                    <td>
                        <p>
                            <code>3.4567.toTixed(3); // => 3.457</code>
                        </p>
                        <p>
                            <code>let price = 10;</code>
                        </p>
                        <p>
                            <code>price.toFixed(2); // => 10.00</code>
                        </p>
                    </td>
                </tr>
            </table>

            <table>
                <tr>
                    <td>
                        Konstante
                    </td>
                    <td>
                        Zweck
                    </td>
                    <td>
                        Beispiel
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            PI
                        </code>
                    </td>
                    <td>
                        𝞹
                    </td>
                    <td>
                        <code>Math.PI</code> ergibt <code>3.141592653589796</code>
                    </td>
                </tr>
            </table>
        </chapter>

        <chapter id="globale-objekte-regexp" title="RegExp – reguläre Ausdrücke">
            <tip>
                Grundlagen zu regulären Ausdrücken sind hier: <a href="swe-pk-regex.topic"/>
            </tip>

            <p>
                Fürs Arbeiten mit regulären Ausdrücken stellt JavaScript zum einen das Objekt <code>RegExp</code> zur
                Verfügung, zum anderen bieten Zeichenketten verschiedene Methoden an, um reguläre Ausdrücke auszuwerten.
            </p>

            <table>
                <tr>
                    <td>
                        Methode
                    </td>
                    <td>
                        Anwendbar auf
                    </td>
                    <td>
                        Beschreibung
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            test()
                        </code>
                    </td>
                    <td>
                        RegExp
                    </td>
                    <td>
                        Diese Methode prüft, ob ein bestimmtes Zeichenmuster in einer Zeichenkette vorkommt und gibt
                        einen entsprechenden booleschen Wert zurück.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            exec()
                        </code>
                    </td>
                    <td>
                        RegExp
                    </td>
                    <td>
                        Diese Methode sucht nach Vorkommen für ein entsprechendes Zeichenmuster und gibt diese als Array
                        zurück.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            match()
                        </code>
                    </td>
                    <td>
                        Zeichenkette
                    </td>
                    <td>
                        Diese Methode sucht innerhalb einer Zeichenkette die Vorkommen, die auf ein Zeichenmuster
                        zutreffen, und gibt diese als Array zurück.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            replace()
                        </code>
                    </td>
                    <td>
                        Zeichenkette
                    </td>
                    <td>
                        Diese Methode ersetzt das Vorkommen innerhalb einer Zeichenkette, die auf ein entsprechendes
                        Zeichenmuster zutreffen.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            search()
                        </code>
                    </td>
                    <td>
                        Zeichenkette
                    </td>
                    <td>
                        Diese Methode sucht nach Vorkommen für ein entsprechendes Zeichenmuster und gibt den Index des
                        ersten Vorkommens zurück.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            split()
                        </code>
                    </td>
                    <td>
                        Zeichenkette
                    </td>
                    <td>
                        Diese Methode trennt eine Zeichenkette anhand eines entsprechenden Zeichenmusters und gibt die
                        einzelnen Teile der Zeichenkette als Array zurück.
                    </td>
                </tr>
            </table>

            <p>
                Wie für Objekte und Arrays gibt es auch für reguläre Ausdrücke die Möglichkeit, diese über eine
                Konstruktorfunktion oder über die Literal-Schreibweise zu erzeugen. Bei der Literal-Schreibweise wir der
                reguläre Ausdruck durch zwei Slash-Symbole <code>/</code> umgeben.
            </p>

            <code-block lang="javascript">
                <![CDATA[
                    let regExp = new RegExp('abcde');
                    let regExp = /abcde/;
                ]]>
            </code-block>

            <p>
                Soll ein regulärer Ausdruck dynamisch zur Laufzeit eines Programms erzeugt werden, beispielsweise auf
                Basis einer Nutzereingabe, wird die Konstruktorfunktion verwendet, da hier die Nutzereingabe als
                Zeichenkette angegeben werden kann. Steht der reguläre Ausdruck dagegen fest und ändert sich zur
                Laufzeit eines Programms nicht mehr, dann wird am besten die Literal-Schreibweise verwendet, weil diese
                bezüglich der Ausführgeschwindigkeit schneller arbeitet als die Konstruktorfunktion.
            </p>
        </chapter>
    </chapter>

    <chapter id="funktionen-als-referenztypen" title="Funktionen als Referenztypen">
        <p>
            Funktionen sind in JavaScript ebenfalls Objekte. Dies ist nicht selbstverständlich und nicht in allen
            Programmiersprachen so (in Java beispielsweise nicht). Dies hat wiederum zur Folge, dass Funktionen wie
            »normale« Variablen als Argumente oder als Rückgabewerte anderer Funktionen verwendet werden können.
            Auch verfügen Funktionen ihrerseits wia andere Objekte auch über Methoden, die auf entsprechenden
            Funktionsobjekten aufgerufen werden können.
        </p>

        <chapter id="funktionen-als-referenztypen-argumente" title="Funktionen als Argumente verwenden">
            <p>
                Funktionen können in JavaScript als Argument einer anderen Funktion verwendet werden. Zum einen können
                Funktionen über die entsprechende Variable übergeben werden, die diese Funktion referenziert. Zum
                anderen können Funktionen auch direkt an der Stelle definiert werden, an der das Argument erwartet wird,
                sprich in der Argumentliste der Funktion, die aufgerufen wird. Zum anderen kann die Funktion auch direkt
                an der Stelle definieren, an der das Argument erwartet wird, sprich in der Argumentliste der Funktion,
                die aufgerufen wird. Typischerweise verwendet man in diesem Fall anonyme Funktionen.
            </p>

            <code-block collapsed-title="Code" collapsible="true" lang="javascript">
                <![CDATA[
                    let numbers = [2,3,4,5];
                    function every(array, f) {
                      for(let i=0; i<array.length; i++) {
                        f(array[i]);
                      }
                    }
                    function print(item) {
                      console.log('Item: ' + item);
                    }
                    function printModulo(item) {
                      console.log(item + ' % 2 = ' + item % 2);
                    }
                    every(numbers, print);
                    every(numbers, printModulo);
                ]]>
            </code-block>

            <code-block collapsed-title="Ausgabe" collapsible="true" lang="javascript">
                <![CDATA[
                    Item: 2
                    Item: 3
                    Item: 4
                    Item: 5
                    2 % 2 = 0
                    3 % 2 = 1
                    4 % 2 = 0
                    5 % 2 = 1
                ]]>
            </code-block>

            <p>
                Die Funktion <code>every()</code> welche in diesem Beispiel selbst implementiert wurde, steht den Arrays
                in JavaScript bereits von Haus aus zur Verfügung, und zwar in Form der Array-Methode
                <code>forEach()</code>. Diese Methode führt eine ihr übergeordnete Funktion für jedes Element im Array
                aus bzw. ruft sie mit dem jeweiligen Element als Argument auf.
            </p>
        </chapter>

        <chapter id="funktionen-als-referenztypen-return" title="Funktionen als Rückgabewerte verwenden">
            <p>
                Funktionen können in JavaScript auch als Rückgabewert einer anderen Funktion verwendet werden. Wenn eine
                Funktion eine andere Funktion als Rückgabewert liefert, kann man die zurückgegebene Funktion auch direkt
                aufrufen, ohne sie erst einer Variable zuzuweisen.
            </p>

            <code-block collapsed-title="Code" collapsible="true" lang="javascript">
                <![CDATA[
                    function sayHello() {
                      console.log('Hallo');
                      return function() {
                        console.log('Welt');
                        return function() {
                          console.log('Mein Name ist Max Mustermann.');
                        }
                      }
                    }
                    sayHello();      // Aufruf der »äußeren« Funktion
                    sayHello()();    // Aufruf der »äußeren« und der »mittleren« Funktion
                    sayHello()()();  // Aufruf aller Funktionen
                ]]>
            </code-block>
        </chapter>

        <chapter id="funktionen-als-referenztypen-standardmethoden" title="Standardmethoden jeder Funktion">
            <p>
                Funktionen sind Objekte, was wiederum bedeutet, dass sie ihrerseits Methoden enthalten können.
                Standardmäßig stellt jede Funktion bereits drei Methoden zur Verfügung:
            </p>

            <chapter id="funktionen-als-referenztypen-standardmethoden-bind"
                     title="Objekte binden mit der Methode bind()">
                <p>
                    Das Schlüsselwort <code>this</code> bezieht sich auf den Kontext, in welchem die Funktion aufgerufen
                    wird, nicht auf den, in welchem sie definiert wurde. Dieses Verhalten ist jedoch nicht immer das,
                    was man möchte. Angenommen man möchte eine Objektmethode, die auf <code>this</code> zugreift, als
                    Argument einer Funktion übergeben, beispielsweise Callback-Handler (also eine Funktion, die von der
                    Funktion, der sie übergeben wird, aufgerufen wird). Dann kann dies zu einem Laufzeitfehler führen.
                </p>

                <p>
                    Über die Funktion <code>bind()</code> lässt sich this für eine Funktion an ein bestimmtes Objekt
                    binden. Die Methode <code>bind()</code> wird dabei auf der entsprechenden Funktion aufgerufen, wobei
                    man als Argument das Objekt übergibt, welches den Ausführungskontext darstellt. Hat die Funktion
                    ihrerseits Parameter, werden diese einfach hinten angehängt. Als Ergebnis liefert
                    <code>bind()</code> ein neues Funktionsobjekt, welches identisch mit der Ursprungsfunktion ist, den
                    Ausführungskontext aber an das übergebene Objekt gebunden hat.
                </p>

                <code-block collapsed-title="Code" collapsible="true" lang="javascript">
                    <![CDATA[
                        let button = {
                          handler : null,  // Funktion, die einen Callback-Handler erwartet
                          onClick : function(handler) {
                            this.handler = handler;
                          },
                          click : function() {
                            this.handler();
                          }
                        };

                        let handler = {
                          log : function() {
                            console.log("Button geklickt.");
                          },  // Objektmethode, die weiter unten als Callback-Handler registriert wird
                          handle: function() {
                            this.log();
                          }
                        }

                        // Registrieren des Callback-Handlers mit Fehler
                        button.onClick(handler.handle); // TypeError: Object #<Object> has no method 'log'

                        // Registrieren des Callback-Handlers ohne Fehler
                        button.onClick(handler.handle.bind(handler));


                        // Implizites Aktivieren des Callback-Handlers
                        button.click();
                    ]]>
                </code-block>

                <p>
                    Die Methode <code>bind()</code> gibt es erst seit ES5. Für Browser mit älteren Versionen gibt es
                    die Möglichkeit selbst zu implementieren.
                </p>
            </chapter>

            <chapter id="funktionen-als-referenztypen-standardmethoden-call"
                     title="Funktionen aufrufen über die Methode call()">
                <p>
                    Mit der Methode <code>call()</code> ist es ebenfalls möglich, den Ausführungskontext einer Funktion
                    zu definieren. Allerdings wird bei <code>call()</code> nicht wie im Falle von <code>bind()</code>
                    ein neues Funktionsobjekt erstellt, sondern die entsprechende Funktion direkt aufgerufen. Der
                    Ausführungskontext wird dabei als erstes Argument übergeben, optional können weitere Argumente für
                    die aufzurufende Funktion definiert werden.
                </p>

                <p>
                    Ein besonders häufig anzutreffender Anwendungsfall für die Verwendung von <code>call()</code> ist
                    die Iteration über das <code>arguments</code>-Objekt unter Verwendung der
                    <code>forEach()</code>-Methode. Diese Methode steht eigentlich nur echten Arrays zur Verfügung,
                    arguments ist kein echtes Array und stellt diese Methode daher nicht zur Verfügung.
                </p>

                <code-block collapsed-title="Code" collapsible="true" lang="javascript">
                    <![CDATA[
                        function logNames() {
                          console.log(arguments); // Ausgabe: { '0': 'Max', '1': 'Moritz' }
                          /* Fehler: arguments ist kein Array
                          arguments.forEach(function(argument) {
                            console.log(argument);
                          });  */
                        }

                        logNames('Max', 'Moritz');
                    ]]>
                </code-block>

                <p>
                    Die Funktionalität der <code>forEach()</code>-Methode lässt sich allerdings auch für
                    <code>array</code>-ähnliche Objekte wie arguments verwenden. Der Fachbegriff für diese Technik
                    lautet Function Borrowing bzw. Method Borrowing, was so viel wie das Ausleihen von Funktionen oder
                    Methoden bedeutet.
                </p>

                <p>
                    Die einfachste Möglichkeit, über ein <code>array</code>-ähnliches Objekt zu iterieren:
                </p>

                <code-block collapsed-title="Code" collapsible="true" lang="javascript">
                    <![CDATA[
                        function logNames() {
                          Array.prototype.forEach.call(arguments, function(argument) {
                            console.log(argument);
                          });
                        }

                        logNames('Max', 'Moritz');
                    ]]>
                </code-block>

                <p>
                    Hier wird über <code>Array.prototype</code> auf das globale Array-Objekt bzw. dessen Prototyp
                    zugegriffen. In diesem Prototyp sind alle Methoden enthalten, die den Array-Instanzen im Rahmen der
                    prototypischen Vererbung zur Verfügung stehen. Die Methode <code>forEach()</code> ist eine davon,
                    wobei man über <code>Array.prototype.forEach</code> auf diese Methode zugreifen kann, ohne sie
                    aufzurufen. Der eigentliche Aufruf geschieht erst durch den Aufruf der Methode <code>call()</code>.
                    Das erste Argument von <code>call()</code> definiert dabei den Ausführungskontext, welcher im
                    Beispiel das Objekt <code>arguments</code> sein muss. Das zweite Argument ist dasjenige, welches an
                    die Methode <code>forEach()</code> weitergereicht wird: eine Callback-Funktion, die für jedes
                    Element im Array bzw. hier im <code>arguments</code>-Objekt aufgerufen wird.
                </p>
            </chapter>

            <chapter id="funktionen-als-referenztypen-standardmethoden-apply"
                     title="Funktionen aufrufen über die Methode apply()">
                <p>
                    Vom Prinzip her funktioniert <code>apply()</code> ähnlich wie die Methode <code>call()</code>. Der
                    einzige Unterschied ist, dass die Argumente der aufgerufenen Funktion nicht als einzelne Argumente
                    übergeben werden, sondern gesammelt als Array.
                </p>

                <code-block collapsed-title="Code" collapsible="true" lang="javascript">
                    <![CDATA[
                        function logNames() {
                          Array.prototype.forEach.apply(arguments, [function(argument) {
                            console.log(argument);
                          }]);
                        }
                        logNames('Max', 'Moritz');
                    ]]>
                </code-block>
            </chapter>
        </chapter>
    </chapter>

    <chapter id="quellen" title="Quellen">
        <tip>
            <b>(BUCH)</b>
            978-3836256971, "JavaScript", Philip Ackermann, 2019
        </tip>
    </chapter>
</topic>