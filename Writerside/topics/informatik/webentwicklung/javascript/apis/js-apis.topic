<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
        SYSTEM "https://resources.jetbrains.com/writerside/1.0/xhtml-entities.dtd">
<topic id="js-apis"
       title="Moderne Web-APIs"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="https://resources.jetbrains.com/writerside/1.0/topic.v2.xsd">
    <show-structure depth="2" for="chapter,procedure"/>

    <!-- TODO: migrate from Confluence -->
    <chapter id="overview" title="Übersicht">
        <note>
            Einen guten Überblick darüber, in welchem Arbeitszustand sich eine API befindet, gibt die Webseite
            <a href="https://github.com/dret/HTML5-overview"/>.
        </note>

        <table style="header-row">
            <tr>
                <td>
                    Web-API
                </td>
                <td>
                    Beschreibung
                </td>
                <td>
                    Dokumentation
                </td>
            </tr>
            <tr>
                <td>
                    <a href="js-apis-canvas.topic">Canvas API</a>
                </td>
                <td>
                    Ermöglicht das Zeichnen per JavaScript.
                </td>
                <td>
                    <a href="https://www.w3.org/TR/2dcontext/"/>
                </td>
            </tr>
            <tr>
                <td>
                    <a href="">Constraint Validation API</a>
                </td>
                <td>
                    Ermöglicht das validieren von Formulardaten mittels JavaScript.
                </td>
                <td></td>
            </tr>
            <tr>
                <td>
                    <a href="">Web Socket API</a>
                </td>
                <td>
                    Ermöglicht die bidirektionale Kommunikation zwischen Client und Server.
                </td>
                <td>
                    <a href="https://www.w3.org/TR/websockets"/>
                </td>
            </tr>
            <tr>
                <td>
                    <a href="">Server-Sent Events</a>
                </td>
                <td>
                    Ermöglicht es, vom Server aus aktiven Nachrichten an den Client zu schicken.
                </td>
                <td>
                    <a href="https://www.w3.org/TR/eventsource"/>
                </td>
            </tr>
            <tr>
                <td>
                    <a href="">Web Storage API</a>
                </td>
                <td>
                    Ermöglicht den Zugriff auf einen Browserspeicher.
                </td>
                <td>
                    <a href="https://www.w3.org/TR/webstorage"/>
                </td>
            </tr>
            <tr>
                <td>
                    <a href="">Indexed Database API</a>
                </td>
                <td>
                    Ermöglicht den Zugriff auf eine Browserdatenbank.
                </td>
                <td>
                    <a href="https://www.w3.org/TR/IndexedDB"/>
                </td>
            </tr>
            <tr>
                <td>
                    <a href="">File API</a>
                </td>
                <td>
                    Ermöglicht den Zugriff auf das Dateisystem.
                </td>
                <td>
                    <a href="https://www.w3.org/TR/FileAPI/"/>
                </td>
            </tr>
            <tr>
                <td>
                    <a href="">Drag and Drop API</a>
                </td>
                <td>
                    Ermöglicht es, Komponenten innerhalb einer Webseite zu verschieben.
                </td>
                <td></td>
            </tr>
            <tr>
                <td>
                    <a href="">Web Worker API</a>
                </td>
                <td>
                    Ermöglicht es, JavaScript-Programme parallel auszuführen.
                </td>
                <td>
                    <a href="https://www.w3.org/TR/workers"/>
                </td>
            </tr>
            <tr>
                <td>
                    <a href="">Geolocation API</a>
                </td>
                <td>
                    Ermöglicht es, auf Standortinformationen des Nutzers zuzugreifen.
                </td>
                <td>
                    <a href="https://www.w3.org/TR/geolocation-API/"/>
                </td>
            </tr>
            <tr>
                <td>
                    <a href="">Battery Status API</a>
                </td>
                <td>
                    Ermöglicht es, den Batteriestand eines Endgeräts auszulesen.
                </td>
                <td>
                    <a href="https://www.w3.org/TR/battery-status/"/>
                </td>
            </tr>
            <tr>
                <td>
                    <a href="">Web Speech API</a>
                </td>
                <td>
                    Ermöglicht es, Sprache zu erkennen und Sprach auszugeben.
                </td>
                <td>
                    <a href="https://dvcs.w3.org/hg/speech-api/raw-file/tip/speechapi.html"/>
                </td>
            </tr>
            <tr>
                <td>
                    <a href="">Web Animation API</a>
                </td>
                <td>
                    Ermöglicht es, Animationen zu erstellen.
                </td>
                <td>
                    <a href="https://w3c.github.io/web-animations/"/>
                </td>
            </tr>
            <tr>
                <td>
                    <a href="">Command Line API</a>
                </td>
                <td>
                    Ermöglicht es, mit der Kommandozeile zu arbeiten.
                </td>
                <td>
                    <p>
                        Browserspezifisch:
                    </p>

                    <list>
                        <li>
                            Chrome:
                            <a href="https://developer.chrome.com/docs/devtools/"/>
                        </li>
                        <li>
                            Safari:
                            <a href="https://developer.apple.com/library/archive/documentation/AppleApplications/Conceptual/Safari_Developer_Guide/Console/Console.html"/>
                        </li>
                        <li>
                            Firefox:
                            <a href="https://firefox-source-docs.mozilla.org/devtools-user/web_console/index.html"/>
                        </li>
                    </list>
                </td>
            </tr>
            <tr>
                <td>
                    <a href="">Internationalization API</a>
                </td>
                <td>
                    Ermöglicht es, mehrsprachige Anwendungen zu erstellen.
                </td>
                <td>
                    <a href="https://www.ecma-international.org/ecma-402/1.0/"/>
                </td>
            </tr>
            <tr>
                <td>
                    <a href="">Ambient Light API</a>
                </td>
                <td>
                    Beschreibt eine Sensorschnittstelle, um auf Informationen bezüglich des Umgebungslichts zugreifen zu
                    können.
                </td>
                <td>
                    <a href="https://www.w3.org/TR/ambient-light/"/>
                </td>
            </tr>
            <tr>
                <td>
                    <a href="">Device Orientation API</a>
                </td>
                <td>
                    Ermöglicht das Auslesen von Informationen bezüglich der Orientierung von Endgeräten.
                </td>
                <td>
                    <a href="https://www.w3.org/TR/orientation-event/"/>
                </td>
            </tr>
            <tr>
                <td>
                    <a href="">Fullscreen API</a>
                </td>
                <td>
                    Ermöglicht das Darstellen einer Webseite im Vollbildmodus.
                </td>
                <td>
                    <a href="https://fullscreen.spec.whatwg.org/"/>
                </td>
            </tr>
            <tr>
                <td>
                    <a href="">High Resolution Time API</a>
                </td>
                <td>
                    Ermöglicht den Zugriff auf den aktuellen Zeitpunkt in einer höheren Auflösung als beispielsweise
                    die, die für die Systemzeit verwendet wird.
                </td>
                <td>
                    <a href="https://www.w3.org/TR/hr-time/"/>
                </td>
            </tr>
            <tr>
                <td>
                    <a href="">Media Capture and Streams</a>
                </td>
                <td>
                    Definiert eine Schnittstelle für den Zugriff auf Mediendaten wie Audio- und Videodaten.
                </td>
                <td>
                    <a href="https://www.w3.org/TR/mediacapture-streams/"/>
                </td>
            </tr>
            <tr>
                <td>
                    <a href="">Navigation Timing API</a>
                </td>
                <td>
                    Ermöglicht den Zugriff auf verschiedene zeitliche Informationen bei der Interaktion von Nutzern mit
                    einer Webseite.
                </td>
                <td>
                    <a href="https://www.w3.org/TR/navigation-timing/"/>
                </td>
            </tr>
            <tr>
                <td>
                    <a href="">Network Information API</a>
                </td>
                <td>
                    Ermöglicht den Zugriff auf Verbindungsinformationen eines Endgeräts.
                </td>
                <td>
                    <a href="http://w3c.github.io/netinfo/"/>
                </td>
            </tr>
            <tr>
                <td>
                    <a href="">Notifications API</a>
                </td>
                <td>
                    Ermöglicht es, Hinweismeldungen an den Nutzer zu schicken.
                </td>
                <td>
                    <a href="https://www.w3.org/TR/notifications/"/>
                </td>
            </tr>
            <tr>
                <td>
                    <a href="">Page Visibility API</a>
                </td>
                <td>
                    Ermöglicht es, festzustellen, ob eine Webseite aktuell sichtbar ist oder nicht (beispielsweise wenn
                    sie in einem verdeckten Tab geöffnet ist).
                </td>
                <td>
                    <a href="https://www.w3.org/TR/page-visibility/"/>
                </td>
            </tr>
            <tr>
                <td>
                    <a href="">Performance Timeline</a>
                </td>
                <td>
                    Ermöglicht den Zugriff auf Informationen, um die Performance innerhalb einer Webseite zu messen.
                </td>
                <td>
                    <a href="https://www.w3.org/TR/performance-timeline"/>
                </td>
            </tr>
            <tr>
                <td>
                    <a href="">Presentation API</a>
                </td>
                <td>
                    Definiert eine Schnittstelle für den Zugriff auf externe Präsentationsdisplays wie Beamer oder
                    Fernseher.
                </td>
                <td>
                    <a href="https://www.w3.org/TR/presentation-api/"/>
                </td>
            </tr>
            <tr>
                <td>
                    <a href="">Pointer Events</a>
                </td>
                <td>
                    Definiert eine einheitliche Schnittstelle für Eingabegeräte wie Maus, Stift und Touchscreen.
                </td>
                <td>
                    <a href="https://www.w3.org/TR/pointerevents/"/>
                </td>
            </tr>
            <tr>
                <td>
                    <a href="">Progress Events</a>
                </td>
                <td>
                    Definiert eine Schnittstelle, um auf den Fortschritt von bestimmten Prozessen zugreifen zu können.
                    Wurde in diesem Kapitel beispielsweise verwendet, um den Fortschritt beim Lesen einer Datei zu
                    ermitteln.
                </td>
                <td>
                    <a href="https://www.w3.org/TR/progress-events"/>
                </td>
            </tr>
            <tr>
                <td>
                    <a href="">Proximity API</a>
                </td>
                <td>
                    Ermöglicht den Zugriff auf Angaben zu der Lage von physischen Objekten wie Endgeräten oder Nutzern.
                </td>
                <td>
                    <a href="https://www.w3.org/TR/proximity/"/>
                </td>
            </tr>
            <tr>
                <td>
                    <a href="">Resource Timing API</a>
                </td>
                <td>
                    Ermöglicht den Zugriff auf zeitliche Informationen bezüglich der in einer Webseite eingebundenen
                    Ressourcen, um beispielsweise zu protokollieren, wie lange das Laden einer Ressource dauert.
                </td>
                <td>
                    <a href="https://www.w3.org/TR/resource-timing/"/>
                </td>
            </tr>
            <tr>
                <td>
                    <a href="">Screen Orientation API</a>
                </td>
                <td>
                    Ermöglicht den Zugriff auf Orientierungsinformationen von Endgeräten.
                </td>
                <td>
                    <a href="https://www.w3.org/TR/screen-orientation/"/>
                </td>
            </tr>
            <tr>
                <td>
                    <a href="">Touch Events</a>
                </td>
                <td>
                    Definiert eine Schnittstelle für den Zugriff auf Touch-Oberflächen.
                </td>
                <td>
                    <a href="https://www.w3.org/TR/touch-events"/>
                </td>
            </tr>
            <tr>
                <td>
                    <a href="">User Timing API</a>
                </td>
                <td>
                    Ermöglicht den Zugriff auf verschiedene zeitliche Informationen bei der Interaktion von Nutzern mit
                    einer Webseite unter Verwendung von hochauflösenden Zeitinformationen.
                </td>
                <td>
                    <a href="https://www.w3.org/TR/user-timing/"/>
                </td>
            </tr>
            <tr>
                <td>
                    <a href="">Vibration API</a>
                </td>
                <td>
                    Ermöglicht es, die Vibrationsfunktion von Endgeräten zu nutzen.
                </td>
                <td>
                    <a href="https://www.w3.org/TR/vibration/"/>
                </td>
            </tr>
            <tr>
                <td>
                    <a href="">Web Messaging API</a>
                </td>
                <td>
                    Definiert eine Schnittstelle für den Nachrichtenaustausch. Wird beispielsweise bei Server-Sent
                    Events oder Web Sockets verwendet.
                </td>
                <td>
                    <a href="https://www.w3.org/TR/webmessaging/"/>
                </td>
            </tr>
            <tr>
                <td>
                    <a href="">Web Notification API</a>
                </td>
                <td>
                    Definiert eine Schnittstelle für Benachrichtigungen an Nutzer.
                </td>
                <td>
                    <a href="https://www.w3.org/TR/notifications/"/>
                </td>
            </tr>
        </table>
    </chapter>

    <chapter id="w3c-vs-whatwg" title="W3C vs. WHATWG">
        <p>
            <b>W3C (World Wide Web Consortium)</b> ist das Standardisierungsgremium rund um die Technologien des
            World Wide Web, u.a. HTML, CSS und eben verschiedener Web-APIs.
        </p>

        <p>
            <b>WHATWG (Web Hypertext Application Technology Working Group)</b> eine Arbeitsgruppe, deren Entstehung im
            Jahre 2004 vor allem der Tatsache geschuldet war, dass die damalige Entwicklung verschiedener Web Standards
            beim W3C relativ träge voranschritt. Das W3C hat nämlich zum Ziel, immer endgültige Versionen von Web
            Standards zu verabschieden, was dementsprechend hin und wieder etwas dauern kann. Die WHATWG verfolgt
            dagegen eine andere Strategie: Hier werden sogenannte Living Standards gepflegt: Spezifikationen, die
            kontinuierlich und in enger Zusammenarbeit mit den verschiedenen Browserherstellern (die übrigens auch Teil
            der Arbeitsgruppe sind) weiterentwickelt werden.
        </p>

        <p>
            Bezogen auf die Web-APIs bedeutet dies also, dass man es häufig mit zwei Varianten zu tun hat:
        </p>

        <list type="bullet">
            <li>
                einer vom W3C abgesegneten »endgültigen« Variante
            </li>
            <li>
                und einer, die von der WHATWG weiterentwickelt wird.
            </li>
        </list>
    </chapter>

    <chapter id="kommunikation" title="Über JavaScript kommunizieren">
        <chapter id="kommunikation-unidirektional" title="Unidirektionale Kommunikation mit dem Server">
            <p>
                Bei der Kommunikation über HTTP geschieht die Kommunikation vom Client aus, unabhängig davon, ob es sich
                um eine klassische Website handelt oder um eine moderne Webanwendung, die auf Ajax basiert. In allen
                Fällen ist es der Client, der die (HTTP-)Anfragen an den Server formuliert, auf die dieser dann mit
                (HTTP-)Antworten reagiert. Der Server kann über HTTP keine Daten von sich aus an einen Client schicken.
            </p>

            <p>
                Die Kommunikation von Client und Server geschieht unidirektional, in eine Richtung vom Client zum
                Server. Auch die Tatsache, dass der Server mit Antworten reagiert und man somit schon in zwei Richtungen
                kommuniziert, ändert nichts daran, dass die aktive Kommunikation nur in eine Richtung geht.
            </p>

            <p>
                Angenommen es wird eine Anwendung entwickelt, bei der in unregelmäßigen Abständen Nachrichten auf einem
                Server abgelegt und diese relativ zeitnah in einer Webanwendung angezeigt werden sollen. Schön wäre es
                doch, wenn der Server den Client über neue Nachrichten benachrichtigen würde. Hierfür haben sich
                verschiedene Techniken herausgebildet, die solche Anforderungen durch Hacks realisieren.
            </p>

            <img alt="Unidirektionale Kommunikation mit dem Server (1)"
                 src="js-api-kommunikation-unidirektional-1.png"/>

            <img alt="Unidirektionale Kommunikation mit dem Server (2)"
                 src="js-api-kommunikation-unidirektional-2.png"/>

            <p>
                Bei <b>Polling</b> (Bild 1) fragt der Client im Hintergrund (durch Ajax-Anfragen) beim Server nach
                neuen Daten an, die der Server dann entsprechend beantwortet.
            </p>

            <p>
                Beim <b>Long-Polling</b> (Bild 2) sendet der Client ebenfalls im Hintergrund Anfragen an den Server
                sendet. Liegen neue Daten auf dem Server bereit, liefert der Server umgehend eine Antwort. Liegen
                dagegen keine neuen Daten vor, hält der Server die HTTP-Verbindung so lange offen, bis entweder neue
                Daten auf dem Server vorliegen oder ein zuvor festgelegter Timeout überschritten wurde.
            </p>

            <p>
                In beiden Fällen gilt: Sobald der Client die entsprechende Antwort vom Server erhält, sendet er erneut
                eine Anfrage, wobei der Server die Verbindung wieder offen hält usw.
            </p>

            <p>
                Mittlerweile gibt es jedoch auch Technologien, bei denen der Server wirklich Daten an den Client sendet,
                sodass man auf oben beschriebene Techniken verzichten kann. Eine von diesen Technologien ist die
                sogenannte Web Socket API.
            </p>
        </chapter>

        <chapter id="kommunikation-bidirektional" title="Bidirektionale Kommunikation mit einem Server">
            <p>
                Über die Web Socket API (<a href="https://www.w3.org/TR/websockets/"/> bzw.
                <a href="https://html.spec.whatwg.org/multipage/comms.html#network"/>) können Socket-Verbindungen
                zwischen Client und Server hergestellt werden, über die es dann möglich ist, dass sowohl der Client
                Daten an den Server schickt, als auch, dass der Server Daten an den Client schickt. Sprich, es besteht
                eine dauerhafte Verbindung zwischen Client und Server, und beide können jederzeit Daten an den jeweils
                anderen senden.
            </p>

            <img alt="Bidirektionale Kommunikation mit einem Server" src="js-api-kommunikation-bidirektional.png"/>

            <p>
                Die Spezifikation umfasst dabei lediglich einen Typ (bzw. ein Interface), und zwar WebSocket. Um eine
                Web-Socket-Verbindung herzustellen, verwendet man die entsprechende Konstruktorfunktion.
            </p>

            <code-block lang="javascript">
                <![CDATA[
                    let connection = new WebSocket('ws://example.com/test');
                ]]>
            </code-block>

            <p>
                Bezüglich des Verbindungsaufbaus stellt WebSocket drei Event-Handler zur Verfügung: der Event-Handler
                <code>onopen</code> wird aufgerufen, wenn die Web-Socket-Verbindung geöffnet wurde, der Event-Handler
                <code>onerror</code>, wenn beim Verbindungsaufbau ein Fehler aufgetreten ist, und schließlich der
                Event-Handler <code>onclose</code>, wenn die Verbindung wieder geschlossen wurde. Um Daten an den Server
                zu senden, wird die Methode <code>send()</code> verwendet, welche verständlicherweise nur innerhalb des
                <code>onopen</code>-Event-Handlers Sinn macht.
            </p>
        </chapter>

        <chapter id="kommunikation-vom-server-ausgehend" title="Vom Server ausgehende Kommunikation">
            <img alt="Vom Server ausgehende Kommunikation" src="js-api-kommunikation-server.png"/>

            <p>
                Mithilfe von Server-Sent Events (<a href="https://www.w3.org/TR/eventsource/"/> bzw. im Living Standard
                unter <a href="https://html.spec.whatwg.org/multipage/comms.html#server-sent-events"/>) ist es
                möglich, dass Server von sich aus Nachrichten an einen Client senden.
            </p>

            <p>
                <b>Clientseite</b>: Die API definiert das EventSource-Interface, welches eine serverseitige Quelle
                repräsentiert, die Events generiert bzw. Nachrichten verschickt. Um eine solche Eventquelle zu
                definieren, übergibt man der entsprechenden Konstruktorfunktion die URL und definiert einen
                Event-Handler, um auf die Nachrichten vom Server reagieren zu können.
            </p>

            <p>
                Die <b>Serverseite</b> kann in verschiedensten Sprachen implementiert werden PHP, NodeJS, ...
            </p>

            <tip>
                Ein Beispiel ist hier zu finden:
                <a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events"/>
            </tip>
        </chapter>
    </chapter>

    <chapter id="cookies" title="Cookies – Nutzer wiedererkennen">
        <p>
            Bei Cookies handelt es sich eigentlich um keine reine HTML5-Technologie, sondern eher um eine, die schon
            einige Jahre auf dem Buckel hat. Cookies werden also hauptsächlich für zwei Dinge verwendet: zum einen, um
            Nutzer wiederzuerkennen (in diesem Fall speichert man entsprechende Nutzer-IDs in den Cookies), zum anderen,
            um auf Clientseite (kleine Mengen von) Daten zu speichern.
        </p>

        <p>
            Das HTTP-Protokoll ist ein sogenanntes zustandsloses Protokoll. Das bedeutet, dass jede HTTP-Anfrage vom
            Client an einen Server von diesem unabhängig von anderen Anfragen behandelt wird, unabhängig auch von
            solchen, die der gleiche Client vielleicht schon vorher gestellt hat. Häufig hat man aber gerade
            Anwendungsfälle, bei denen man genau wissen möchte, welcher Client eine Webseite aufruft.
        </p>

        <p>
            Cookies bieten eine Möglichkeit, kleinere Mengen von Informationen auf dem Clientrechner zu speichern und
            diese – wenn der Nutzer die Webseite erneut besucht – auf Serverseite (oder durch JavaScript) wieder
            auszulesen. Cookies sind prinzipiell nichts anderes als kleinere Textdateien, die der Browser auf dem
            Rechner des Nutzers speichert (sofern dieser es zulässt und nicht entsprechende Vorkehrungen in den
            Browsereinstellungen getroffen hat) und die dann bei jedem Aufruf der zugehörigen Webseite mit der
            HTTP-Anfrage zusammen übermittelt werden. Solche Cookie-Dateien enthalten im Wesentlichen folgende
            Informationen:
        </p>

        <list type="bullet">
            <li>
                Den <b>Namen</b> und den <b>Wert</b> des Cookies. Bei dem Namen wird nicht zwischen Groß- und
                Kleinschreibung unterschieden. Als Werte sind lediglich Zeichenketten erlaubt. Name und Wert sind die
                einzigen Informationen, die zwangsweise angegeben werden müssen. Die Angabe folgender Informationen ist
                optional (werden diese nicht angegeben, werden Standardwerte verwendet).
            </li>
            <li>
                Die <b>Domäne</b> des Servers und den <b>Pfad</b> auf dem Server, an den das Cookie geschickt werden
                soll. Beispielsweise wird ein Cookie mit der Domäne <code>www.javascripthandbuch.de</code> auch nur mit
                Anfragen an diese Domäne mitgesendet. Ein Cookie mit der Domäne <code>www.javascripthandbuch.de</code>
                und dem Pfad <code>/probekapitel</code> wird nur mit Anfragen an
                <code>www.javascripthandbuch.de/probekapitel</code> mitgesendet, nicht aber an
                <code>www.javascripthandbuch.de</code>.
            </li>
            <li>
                Ein <b>Ablaufdatum</b>, bis zu dem das Cookie gültig ist. Nach Ablauf des hier angegebenen Datums
                verfällt das Cookie, wird gelöscht und nicht weiter an den Server gesendet. Wird beim Erstellen eines
                Cookies kein Ablaufdatum angegeben, wird es standardmäßig beim Beenden der Browsersession gelöscht.
            </li>
            <li>
                Ein <b>Sicherheitsflag</b>, über das optional angegeben werden kann, ob ein Cookie nur bei Verbindungen
                mitgesendet werden soll, die <b>SSL (Secure Sockets Layer)</b> verwenden, um beispielsweise das
                Mitsenden an <code>https://www.javascripthandbuch.de</code> zu erlauben, aber das Mitsenden an
                <code>http://www.javascripthandbuch.de</code> zu unterbinden.
            </li>
        </list>

        <note>
            <p>
                <b>
                    Alternative Möglichkeiten, um Nutzer zu erkennen
                </b>
            </p>

            <p>
                Neben Cookies gibt es noch andere Möglichkeiten, um Nutzer zu erkennen, beispielsweise das sogenannte
                <b>URL Rewriting</b>, bei dem Links innerhalb einer Webseite umgeschrieben und um einen den Nutzer
                identifizierenden Parameter ergänzt werden. Klickt der Nutzer dann auf einen Link, kann auf Serverseite
                anhand des URL-Parameters erkannt werden, um welchen Nutzer es sich handelt.
            </p>
        </note>

        <p>
            Alle Cookies für eine entsprechende Domäne und den entsprechenden Pfad werden mit jeder Anfrage mitgesendet,
            was sich auf das Datenvolumen auswirkt. Zudem werden Cookies, die über das HTTP-Protokoll gesendet werden
            (und nicht über das sichere HTTPS-Protokoll), unverschlüsselt übersendet, was je nach der Art der
            übermittelten Informationen ein Sicherheitsrisiko darstellt. Eine weitere Einschränkung von Cookies ist die
            erlaubte Speichergröße von 4 KB.
        </p>

        <table style="header-column">
            <tr>
                <td>
                    Lesen
                </td>
                <td>
                    <code-block lang="javascript">
                        <![CDATA[
                            let x = document.cookie; // => "cookie1=value; cookie2=value; cookie3=value;"
                        ]]>
                    </code-block>

                    <p>
                        Die Eigenschaft <code>cookie</code> des Objekts document gibt die Cookies in einem String
                        zurück.
                    </p>
                </td>
            </tr>
            <tr>
                <td>
                    Schreiben
                </td>
                <td>
                    <code-block lang="javascript">
                        <![CDATA[
                            document.cookie = "username=John Smith; expires=Thu, 18 Dec 2013 12:00:00 UTC; path=/";
                        ]]>
                    </code-block>

                    <p>
                        Im Hintergrund wird hierbei ein Setter aufgerufen, womit die bestehenden Cookies nicht
                        überschrieben werden, sondern das neue Cookie dem Cookie-String hinzugefügt wird.
                    </p>
                </td>
            </tr>
            <tr>
                <td>
                    Löschen
                </td>
                <td>
                    <p>
                        Ein Cookie kann ganz einfach gelöscht werden, indem das Verfallsdatum auf einem Zeitstempel in
                        der Vergangenheit gesetzt wird.
                    </p>

                    <code-block lang="javascript">
                        <![CDATA[
                            document.cookie = "username=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
                        ]]>
                    </code-block>
                </td>
            </tr>
        </table>
    </chapter>

    <chapter id="web-storage-api" title="Den Browserspeicher nutzen">
        <p>
            Die Web Storage API (<a href="https://www.w3.org/TR/webstorage/"/> bzw.
            <a href="https://html.spec.whatwg.org/multipage/webstorage.html"/>) definiert eine Schnittstelle für den
            Zugriff auf einen internen Browserspeicher. Prinzipiell gibt es dabei zwei verschiedene Arten von
            Browserspeichern:
        </p>

        <list type="bullet">
            <li>
                den lokalen <b>Browserspeicher</b>, der von allen Fenstern und Tabs innerhalb des jeweiligen Browsers
                zugänglich ist (auf den lokalen Speicher eines anderen Browsers kann man natürlich nicht zugreifen).
            </li>
            <li>
                sowie den <b>Sessionspeicher</b>, der für jedes Fenster bzw. jeden Tab verschieden ist. Ein Zugriff auf
                einen Sessionspeicher eines Fensters bzw. Tabs aus einem anderen Fenster oder Tab ist daher nicht
                möglich.
            </li>
        </list>

        <p>
            Auf Ersteren, d. h. auf den lokalen Speicher, kann über das globale Objekt <code>localStorage</code> (bzw.
            <code>window.localStorage</code>) zugegriffen werden, auf Letzteren, den Sessionspeicher, über das ebenfalls
            globale Objekt <code>sessionStorage</code> (bzw. <code>window.sessionStorage</code>). Bezüglich der API sind
            beide Browserspeicher identisch, d.h., beide verfügen über die gleichen Methoden und Eigenschaften (die
            entsprechenden die Browserspeicher repräsentierenden Objekte sind beide vom Typ <code>Storage</code>).
        </p>

        <table style="header-row">
            <tr>
                <td>
                    Eigenschaft/Methode
                </td>
                <td>
                    Beschreibung
                </td>
            </tr>
            <tr>
                <td>
                    <code>
                        length
                    </code>
                </td>
                <td>
                    <p>
                        Enthält die Anzahl der Elemente in dem Storage.
                    </p>
                </td>
            </tr>
            <tr>
                <td>
                    <code>
                        clear()
                    </code>
                </td>
                <td>
                    <p>
                        Entfernt alle Schlüssel-Wert-Paare aus dem Storage.
                    </p>
                </td>
            </tr>
            <tr>
                <td>
                    <code>
                        getItem(key)
                    </code>
                </td>
                <td>
                    <p>
                        Liefert für einen Schlüssel den entsprechenden Wert aus dem Storage.
                    </p>

                    <code-block lang="javascript">
                        <![CDATA[
                            let firstname = localStorage.getItem('username');
                        ]]>
                    </code-block>
                </td>
            </tr>
            <tr>
                <td>
                    <code>
                        key(index)
                    </code>
                </td>
                <td>
                    <p>
                        Liefert den Namen des Schlüssels an Position index aus dem Storage.
                    </p>
                </td>
            </tr>
            <tr>
                <td>
                    <code>
                        removeItem(key)
                    </code>
                </td>
                <td>
                    <p>
                        Entfernt – falls vorhanden – das Schlüssel-Wert-Paar für den übergebenen Schlüssel aus dem
                        Storage.
                    </p>

                    <code-block lang="javascript">
                        <![CDATA[
                            localStorage.removeItem('username');
                        ]]>
                    </code-block>
                </td>
            </tr>
            <tr>
                <td>
                    <code>
                        setItem(key, value)
                    </code>
                </td>
                <td>
                    <p>
                        Fügt für den entsprechenden Schlüssel einen Wert in den Storage oder – für den Fall, dass
                        bereits ein gleichnamiger Schlüssel existiert – überschreibt den mit dem Schlüssel assoziierten
                        Wert. Bei dem zu speichernden Wert darf es sich ausschließlich um eine Zeichenkette handeln, das
                        bedeutet, Objekte sollten per <code>JSON.stringify()</code> in eine solche umgewandelt werden,
                        bevor diese gespeichert werden können.
                    </p>

                    <code-block lang="javascript">
                        <![CDATA[
                            localStorage.setItem('username', 'Max Mustermann');
                        ]]>
                    </code-block>
                </td>
            </tr>
        </table>

        <p>
            Um auf Änderungen im Browserspeicher zu reagieren, kann über die Methode <code>addEventListener()</code> des
            <code>window</code>-Objekts einen Event-Listener für das <code>storage</code>-Event registriert werden.
            Dieses Event wird immer dann ausgelöst, wenn sich der Browserspeicher (entweder im <code>localStorage</code>
            oder im <code>sessionStorage</code>) ändert.
        </p>

        <code-block lang="javascript">
            <![CDATA[
                window.addEventListener('storage', (e) => {
                  console.log(e.key);             // Schlüssel des aktualisierten Eintrags
                  console.log(e.oldValue);        // alter Wert
                  console.log(e.newValue);        // neuer Wert
                  console.log(e.url)              // die URL des Dokuments, für das ein Eintrag geändert wurde
                  console.log(e.storageArea);     // das Storage-Objekt, welches geändert wurde
                });
            ]]>
        </code-block>
    </chapter>

    <chapter id="indexed-database-api" title="Die Browserdatenbank nutzen">
        <p>
            Bei der <b>Indexed Database API</b> <a href="https://www.w3.org/TR/IndexedDB/"/> handelt es sich um eine
            Datenbank, die sich im Browser befindet bzw. von diesem implementiert und zur Verfügung gestellt wird. Vom
            Prinzip her funktioniert diese (clientseitige) Datenbank genauso wie eine serverseitige Datenbank, d. h.,
            man kann in ihr Datensätze erstellen, Datensätze auslesen, aktualisieren oder wieder löschen. Bei der
            IndexedDB handelt es sich um eine sogenannte nicht relationale Datenbank, auch <b>NoSQL-Datenbank</b>
            genannt.
        </p>

        <tip>
            Grundlagen zu Datenbanken: <a href="datenbanken.topic"/>
        </tip>

        <p>
            Die Grundidee bei der IndexedDB ist es, (JavaScript-)Objekte unter bestimmten Schlüsseln abzuspeichern,
            d.h., bei der IndexedDB handelt es sich um einen sogenannten Key-Value-Store. Vom Prinzip her ist das wie
            bei der Datenstruktur Map, das bedeutet, die einzelnen Objekte in einer solchen Datenbank werden als Werte
            unter bestimmten Schlüsseln abgelegt. Den Kern einer IndexedDB bilden die sogenannten Object Stores bzw.
            Objektspeicher. Diese sind – wenn man denn so will – in etwa vergleichbar mit Tabellen bei relationalen
            Datenbanken und enthalten die verschiedenen Schlüssel-Wert-Paare. Zugriff auf die IndexedDB erlangt man über
            das <code>window</code>-Objekt. Hinter seiner Eigenschaft <code>indexedDB</code> verbirgt sich ein Objekt
            vom Typ <code>IDBFactory</code>.
        </p>

        <tip>
            Mehr zum Arbeiten mit der Browserdatenbank unter: <a href="https://web.dev/indexeddb/"/>
        </tip>
    </chapter>

    <chapter id="file-api" title="Auf das Dateisystem zugreifen">
        <p>
            Über die File API ist es möglich, per JavaScript auf lokale Dateien des Nutzers zuzugreifen, sofern dieser
            die jeweiligen Dateien zuvor in einem entsprechenden Dialog ausgewählt hat. Die Spezifikation unter
            <a href="https://www.w3.org/TR/FileAPI/"/> definiert für das Arbeiten mit Dateien folgende Interfaces:
        </p>

        <list type="bullet">
            <li>
                Das Interface <code>File</code> repräsentiert eine einzelne Datei und enthält Informationen wie den
                Namen der Datei oder das letzte Änderungsdatum.
            </li>
            <li>
                Das Interface <code>FileList</code> repräsentiert eine Liste von <code>File</code>-Objekten, die vom
                Nutzer ausgewählt wurde.
            </li>
            <li>
                Das Interface <code>Blob</code> repräsentiert binäre Daten.
            </li>
            <li>
                Das Interface <code>FileReader</code> stellt Methoden zur Verfügung, um Objekte vom Typ
                <code>File</code> oder <code>Blob</code> zu lesen.
            </li>
        </list>

        <p>
            Für das Auswählen von Dateien gibt es prinzipiell zwei Möglichkeiten: zum einen den schon erwähnten
            Dateidialog. Zum anderen besteht aber auch die Möglichkeit, Dateien per Drag &amp; Drop in einen bestimmten
            Bereich einer Webseite zu "ziehen" und darüber an die Inhalte der jeweiligen Datei zu kommen.
        </p>

        <table style="header-row">
            <tr>
                <td>
                    Dateidialog
                </td>
                <td>
                    Drag &amp; Drop
                </td>
            </tr>
            <tr>
                <td>
                    <code-block lang="javascript">
                        <![CDATA[
                            <input type="file" id="files" name="files[]" multiple />
                        ]]>
                    </code-block>
                    <code-block lang="javascript">
                        <![CDATA[
                            document.getElementById('files').addEventListener(
                              'change',
                              (event) => {
                                 let files = event.target.files;
                                 /* ... */
                              },
                              false
                            );
                        ]]>
                    </code-block>
                </td>
                <td>
                    <code-block lang="javascript">
                        <![CDATA[
                            <div id="target"></div>
                        ]]>
                    </code-block>
                    <code-block lang="javascript">
                        <![CDATA[
                            function handleFileSelected(event) {
                              event.stopPropagation();
                              event.preventDefault();
                              let files = event.dataTransfer.files;
                              /* ... */
                            }
                            function handleDragOver(event) {
                              event.stopPropagation();
                              event.preventDefault();
                              event.dataTransfer.dropEffect = 'copy';
                            }
                            let dropTarget = document.getElementById('target');
                            dropTarget.addEventListener('dragover', handleDragOver, false);
                            dropTarget.addEventListener('drop', handleFileSelected, false);
                        ]]>
                    </code-block>
                </td>
            </tr>
        </table>

        <chapter id="file-api-lesen" title="Lesen von Dateien">
            <p>
                Um den Inhalt von Dateien zu lesen, muss man nämlich zunächst eine Instanz von <code>FileReader</code>
                erzeugen. Dieser Typ stellt verschiedene Methoden für das Lesen von Dateien zur Verfügung:
            </p>

            <table style="header-row">
                <tr>
                    <td>
                        Methode
                    </td>
                    <td>
                        Beschreibung
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            readAsBinaryString()
                        </code>
                    </td>
                    <td>
                        Liest die Daten als binäre Zeichenfolge ein.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            readAsText()
                        </code>
                    </td>
                    <td>
                        Liest die Daten als Text ein.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            readAsDataURL()
                        </code>
                    </td>
                    <td>
                        Liest die Daten als Daten-URL ein (siehe Kasten).
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            readAsArrayBuffer()
                        </code>
                    </td>
                    <td>
                        Liest die Daten als Array-Buffer ein.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            abort()
                        </code>
                    </td>
                    <td>
                        Bricht den Lesevorgang ab.
                    </td>
                </tr>
            </table>

            <p>
                Ruft man eine dieser Methoden auf, wird man nach erfolgreichem Einlesen der Datei über das
                <code>load</code>-Event benachrichtigt, ein entsprechend zuvor definierter Event-Handler oder
                registrierter Event-Listener vorausgesetzt. Wurde das <code>load</code>-Event ausgelöst, steht zudem der
                Inhalt der Datei über die Eigenschaft <code>result</code> (ebenfalls an der entsprechenden
                <code>FileReader</code>-Instanz) zur Verfügung. Zusätzlich zm <code>load</code>-Event bzw. dem
                entsprechenden <code>onload</code>-Event-Handler stehen weitere Event-Handler (bzw. entsprechende
                Events) zur Verfügung:
            </p>

            <table style="header-row">
                <tr>
                    <td>
                        Event
                    </td>
                    <td>
                        Beschreibung
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            onabort
                        </code>
                    </td>
                    <td>
                        Handler für das <code>abort</code>-Ereignis, welches ausgelöst wird, wenn der Lesevorgang
                        abgebrochen wurde.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            onerror
                        </code>
                    </td>
                    <td>
                        Handler für das <code>error</code>-Ereignis, welches ausgelöst wird, wenn ein Fehler beim
                        Lesevorgang aufgetreten ist.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            onload
                        </code>
                    </td>
                    <td>
                        Handler für das <code>load</code>-Ereignis, welches ausgelöst wird, wenn der Lesevorgang
                        erfolgreich abgeschlossen wurde.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            onloadstart
                        </code>
                    </td>
                    <td>
                        Handler für das <code>loadstart</code>-Ereignis, welches ausgelöst wird, wenn der Lesevorgang
                        gestartet wurde.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            onloadend
                        </code>
                    </td>
                    <td>
                        Handler für das <code>loadend</code>-Ereignis, welches ausgelöst wird, wenn der Lesevorgang
                        abgeschlossen wurde.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            onprogress
                        </code>
                    </td>
                    <td>
                        Handler für das <code>progress</code>-Ereignis, welches während des Lesevorgangs ausgelöst wird,
                        um über den Fortschritt zu informieren.
                    </td>
                </tr>
            </table>

            <code-block collapsed-title="Beispiel: Laden von Bildern" collapsible="true" lang="javascript">
                <![CDATA[
                    function handleFileSelected(event) {
                      let files = event.target.files;
                      for (let i = 0; i < files.length; i++) {
                        let file = files[i];
                        let reader = new FileReader();
                        if(file.type.match('image.*')) {
                          reader.onload = (event) => {
                            let span = document.createElement('span');
                            span.innerHTML = '<img class="thumbnail" src="' + reader.result + '"/>';
                            document.getElementById('list').insertBefore(span, null);
                          };
                          reader.readAsDataURL(file);
                        }
                      }
                    }
                    document.getElementById('files').addEventListener('change', handleFileSelected, false);
                ]]>
            </code-block>
        </chapter>

        <chapter id="file-api-lesefortschritt-ueberwachen" title="Den Lesefortschritt überwachen">
            <p>
                Besonders wenn große Dateien über die File API gelesen werden sollen, ist es hilfreich, Nutzern den
                Fortschritt des Lesens mitzuteilen. Dazu bietet die File API bzw. der Typ <code>FileReader</code>,
                den Event-Handler <code>onprogress</code> an. Das entsprechende <code>Event</code>-Objekt, welches
                hierbei versendet wird, ist vom Typ <code>ProgressEvent</code> (siehe
                <a href="https://www.w3.org/TR/progress-events/"/>) und enthält u. a. die beiden Eigenschaften
                <code>loaded</code> und <code>total</code>, welche die geladene Anzahl an Bytes und die komplette Anzahl
                an Bytes für die jeweilige Datei enthalten.
            </p>

            <tip>
                Mehr zu diesem Thema hier:
                <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileReader/progress_event"/>
            </tip>
        </chapter>
    </chapter>

    <chapter id="drag-and-drop-api" title="Komponenten einer Webseite verschieben">
        <p>
            Unter dem Begriff Drag &amp; Drop versteht man das »Ziehen« und »Ablegen« von Bildschirmelementen, bezogen
            auf Webseiten also das Ziehen und Ablegen von Elementen einer Webseite. Um eine Drag-and-Drop-Operation
            auszuführen, klickt man auf das jeweilige Element, hält dann die Maustaste gedrückt, zieht das Element an
            die gewünschte Position und lässt die Maustaste wieder los, um das Element an der Zielposition abzulegen.
        </p>

        <img alt="Drag &amp; Drop" src="js-api-drag-and-drop.png"/>

        <p>
            Während einer Drag-and-Drop-Operation wird eine Reihe verschiedener Ereignisse ausgelöst. Zu Beginn einer
            Drag-and-Drop-Operation wird das <code>dragstart</code>-Event ausgelöst und kurz danach das
            <code>dragenter</code>-Event, beide auf dem Element, welches verschoben werden soll (auch Drag Source
            genannt). Wird das Element dann über andere Elemente der Webseite hinweggezogen, werden hierbei folgende
            Ereignisse ausgelöst: <code>dragenter</code> beim »Betreten« des jeweils anderen Elements,
            <code>dragover</code>, während sich das gezogene Element über dem anderen Element befindet, und
            <code>dragleave</code> beim »Verlassen« des anderen Elements. Wird das gezogene Element auf dem
            Zielelement (Drop Target) losgelassen, löst dies auf diesem Element das <code>drop</code>-Event aus und auf
            dem gezogenen Element das <code>dragend</code>-Event.
        </p>

        <table style="header-row">
            <tr>
                <td>
                    Event
                </td>
                <td>
                    Beschreibung
                </td>
            </tr>
            <tr>
                <td>
                    <code>
                        dragstart
                    </code>
                </td>
                <td>
                    Wird ausgelöst, wenn begonnen wird, ein Element zu ziehen.
                </td>
            </tr>
            <tr>
                <td>
                    <code>
                        drag
                    </code>
                </td>
                <td>
                    Wird kontinuierlich ausgelöst, während ein Element gezogen wird.
                </td>
            </tr>
            <tr>
                <td>
                    <code>
                        dragend
                    </code>
                </td>
                <td>
                    Wird ausgelöst, wenn ein gezogenes Element wieder losgelassen wird.
                </td>
            </tr>
            <tr>
                <td>
                    <code>
                        dragenter
                    </code>
                </td>
                <td>
                    Wird für ein Element ausgelöst, wenn dieses während des Ziehens »betreten« wird.
                </td>
            </tr>
            <tr>
                <td>
                    <code>
                        dragover
                    </code>
                </td>
                <td>
                    Wird kontinuierlich für ein Element ausgelöst, wenn man sich während des Ziehens innerhalb des
                    Elements befindet.
                </td>
            </tr>
            <tr>
                <td>
                    <code>
                        dragleave
                    </code>
                </td>
                <td>
                    Wird für ein Element ausgelöst, wenn während des Ziehens das Element »verlassen« wird.
                </td>
            </tr>
        </table>
    </chapter>

    <chapter id="parallelisieren" title="Aufgaben parallelisieren">
        <p>
            Bei JavaScript handelt es sich um eine Sprache, die <b>single-threaded</b> ausgeführt wird, sprich, es
            können nicht mehrere Skripts gleichzeitig ausgeführt werden. Skripts werden nacheinander Zeile für Zeile
            interpretiert und ausgeführt. Auch das Auslösen von Events und das damit verbundene Ausführen von
            Event-Listenern geschehen nicht parallel: Der Code, der ein Event auslöst, pausiert so lange, bis die
            entsprechenden Event-Listener ausgeführt wurden.
        </p>

        <p>
            Das Gleiche gilt für Callback-Funktionen: Stellt man beispielsweise eine Ajax-Anfrage an einen Server, wird
            das Skript, welches die Anfrage stellt, zwar so lange weiter ausgeführt, bis der Server die Antwort
            vorbereitet und an den Client geschickt hat, sobald aber die Callback-Funktion aufgerufen wird, welche die
            Antwort vom Server auswertet, pausiert der umgebende Code.
        </p>

        <note>
            <p>
                <b>
                    Begriffsdefinition: Thread
                </b>
            </p>

            <p>
                Unter einem Thread versteht man in der Software-Entwicklung einen Ausführungsstrang innerhalb eines
                Programms. Programme, die single-threaded sind, verwenden nur einen einzelnen Thread. Demgegenüber
                stehen Programme, die multi-threaded ausgeführt werden: Hier wird nicht nur ein Thread verwendet,
                sondern mehrere Threads, wobei einer die Rolle des Hauptthreads einnimmt.
            </p>
        </note>

        <img alt="Single Threaded Applikation" src="js-api-parallelisieren-single-thread.png"/>

        <chapter id="parallelisieren-web-worker-prinzip" title="Das Prinzip von Web Workern">
            <p>
                Dieser Einschränkung der seriellen Abarbeitung von Skripts wirkt die sogenannte Web Worker API
                <a href="https://www.w3.org/TR/workers/"/> entgegen, und zwar, indem es eine API für das Ausführen von
                Hintergrund-Skripts innerhalb von Webanwendungen definiert. Mit den in dieser API definierten Web
                Workern ist es dann beispielsweise möglich, rechenintensive Skripts, die andernfalls die Performance
                einer Webanwendung negativ beeinflussen würden, im Hintergrund auszuführen, sprich parallel zum
                Hauptthread.
            </p>

            <p>
                Web Worker werden dabei in separaten Threads ausgeführt. Daher ist es notwendig, den entsprechenden Code
                auch in separaten Dateien vorzuhalten. Aus dem Hauptthread ist es dann möglich, Nachrichten an einzelne
                Web Worker zu versenden oder von diesen zu empfangen.
            </p>

            <p>
                Standardmäßig können Aufgaben in JavaScript zwar asynchron, aber nicht parallel ausgeführt werden. Erst
                Web Worker ermöglichen das parallele Ausführen.
            </p>

            <img alt="Web Worker" src="js-api-parallelisieren-webworker-1.png"/>
        </chapter>

        <chapter id="parallelisieren-web-worker-verwenden" title="Web Worker verwenden">
            <p>
                Um einen Web Worker zu erstellen, wird die Konstruktorfunktion <code>Worker</code> verwendet, welcher
                man als Parameter den Namen bzw. den Pfad zu dem Skript, welches von dem Web Worker ausgeführt werden
                soll. Um vom Hauptthread Nachrichten an einen Web Worker zu versenden, verwendet man die Methode
                <code>postMessage()</code>, wobei als Parameter ein beliebiges JavaScript-Objekt als Nachricht übergeben
                werden kann. Um eine Nachricht aufseiten eines Web Workers zu empfangen, muss man einen entsprechenden
                Event-Listener für das <code>message</code>-Event registrieren oder alternativ den
                <code>onmessage</code>-Event-Handler definieren. Dazu greift man über die Variable self auf das globale
                Objekt des entsprechenden Web Workers zu. Das Versenden und Empfangen von Nachrichten in die andere
                Richtung funktioniert genauso: Innerhalb des Web Workers ruft man die Methode <code>postMessage()</code>
                auf, um eine Nachricht an den Hauptthread zu versenden. Innerhalb des Hauptthreads kann man innerhalb
                eines Event-Listeners für das <code>message</code>-Event bzw. des <code>onmessage</code>-Event-Handlers
                auf die Nachricht zugreifen.
            </p>

            <code-block collapsed-title="main.js" collapsible="true" lang="javascript">
                <![CDATA[
                    let worker = new Worker("scripts/worker.js");
                    let message = 'Hallo Worker';
                    console.log('Hauptthread: Sende Nachricht: ' + message);
                    worker.postMessage(message);
                    worker.addEventListener('message', (event) => {
                      console.log('Hauptthread: Antwort von Worker erhalten: ' + event.data);
                    });
                    worker.addEventListener('error', (event) => {
                      console.log('Fehler aufgetreten');
                    });
                ]]>
            </code-block>

            <code-block collapsed-title="worker.js" collapsible="true" lang="javascript">
                <![CDATA[
                    self.addEventListener('message', (event) => {
                      console.log('Worker: Nachricht erhalten: ' + event.data);
                      let workerResult = 'Hallo Hauptthread';
                      console.log('Worker: Sende Antwort zurück: ' + workerResult);
                      self.postMessage(workerResult);
                    });
                ]]>
            </code-block>

            <img alt="Web Worker" src="js-api-parallelisieren-webworker-2.png"/>

            <p>
                Web Worker unterliegen verschiedenen Einschränkungen: Zum einen können sie nicht auf DOM zugreifen, zum
                anderen ist auch kein Zugriff auf das <code>window</code>-Objekt möglich. Der Grund: Web Worker werden
                nicht im Browserfenster ausgeführt, sondern im Hintergrund.
            </p>
        </chapter>
    </chapter>

    <chapter id="geolocation-api" title="Den Standort von Nutzern ermitteln">
        <p>
            Dank der Geolocation API <a href="https://www.w3.org/TR/geolocation-API/"/> ist es möglich, den Standort
            bzw. die Position des Nutzers zu ermitteln. Den Einstiegspunkt für die Geolocation API bildet die
            <code>geolocation</code>-Eigenschaft des <code>navigator</code>-Objekts. Um die aktuelle Position des
            Nutzers zu ermitteln, stellt das <code>geolocation</code>-Objekt (übrigens vom Typ Geolocation) die Methode
            <code>getCurrentPosition()</code> zur Verfügung.
        </p>

        <p>
            Damit der Standort des Nutzers ermittelt werden kann, muss dieser dazu seine Zustimmung geben. Sobald daher
            innerhalb einer Webseite die Geolocation API verwendet wird, um den Standort zu ermitteln, wird ein
            entsprechender Bestätigungsdialog angezeigt.
        </p>

        <p>
            Soll der Standort nicht nur einmalig, sondern kontinuierlich ermittelt werden, bietet sich die Methode
            <code>watchPosition()</code> an. Diese Methode funktioniert vom Prinzip her wie
            <code>getCurrentPosition()</code>, wird aber kontinuierlich aufgerufen bzw. immer dann, wenn sich die
            Standortinformationen ändern. Zugriff auf die Standortinformationen erfolgt dann wieder über eine
            entsprechende Callback-Funktion. Als Rückgabewert liefert die Methode zudem eine ID, die sich zu einem
            späteren Zeitpunkt – wenn das Ermitteln der Standortinformationen abgebrochen werden soll – der Methode
            <code>clearWatch()</code> übergeben lässt.
        </p>

        <code-block collapsed-title="worker.js" collapsible="true" lang="javascript">
            <![CDATA[
                if(navigator.geolocation) {
                  let watchID = navigator.geolocation.watchPosition(
                    (position) => {
                      /* Code bei erfolgreichem Aufruf */
                    },
                    (error) => {
                      /* Code bei Fehler: z.B. Benutzer hat Berechtigung nicht zugelassen */
                    }
                  );
                  navigator.geolocation.clearWatch(watchID);
                }
            ]]>
        </code-block>

        <p>
            Über die Google Maps API lassen sich auch Standorte auf Karten anzeigen:
            <a href="https://developers.google.com/maps/?hl=de"/>.
        </p>
    </chapter>

    <chapter id="battery-status-api" title="Den Batteriestand eines Endgeräts auslesen">
        <p>
            Über die Battery Status API <a href="https://www.w3.org/TR/battery-status/"/> hat man die Möglichkeit,
            auf Batterie- bzw. Akkuinformationen des jeweiligen Endgeräts zuzugreifen und somit beispielsweise abhängig
            vom Ladestatus des Akkus eine Webseite entsprechend anzupassen. Die API definiert dazu das Interface
            <code>BatteryManager</code>, über welches der Zugriff auf verschiedene Akkuinformationen möglich ist.
            Zugriff auf eine Objektinstanz vom Typ <code>BatteryManager</code> erhält man über die Methode
            <code>getBattery()</code> des <code>navigator</code>-Objekts. Diese Methode gibt, aber nicht direkt das
            <code>BatteryManager</code>-Objekt, sondern ein <code>Promise</code>-Objekt, zurück. Ruft man auf diesem
            wiederum die Methode <code>then()</code> auf, gelangt man in der übergebenen Callback-Funktion an das
            <code>BatteryManager</code>-Objekt.
        </p>

        <table>
            <tr>
                <td>
                    Eigenschaft
                </td>
                <td>
                    Beschreibung
                </td>
                <td>
                    Event
                </td>
                <td>
                    Beschreibung
                </td>
            </tr>
            <tr>
                <td>
                    <code>
                        charging
                    </code>
                </td>
                <td>
                    Gibt an, ob die Batterie geladen wird oder nicht.
                </td>
                <td>
                    <code>
                        chargingchange
                    </code>
                </td>
                <td>
                    Wird ausgelöst, wenn das Endgerät seinen Ladestatus ändert, d.h., von ladend zu nicht ladend oder
                    von nicht ladend zu ladend.
                </td>
            </tr>
            <tr>
                <td>
                    <code>
                        chargingTime
                    </code>
                </td>
                <td>
                    Gibt die Zeit an, die es braucht, bis die Batterie vollständig geladen ist.
                </td>
                <td>
                    <code>
                        chargingtimechange
                    </code>
                </td>
                <td>
                    Wird ausgelöst, wenn sich die Zeit ändert, die es braucht, bis die Batterie den vollen Ladestatus
                    erreicht hat.
                </td>
            </tr>
            <tr>
                <td>
                    <code>
                        dischargingTime
                    </code>
                </td>
                <td>
                    Gibt die Zeit an, die es braucht, bis die Batterie vollständig entladen ist.
                </td>
                <td>
                    <code>
                        dischargingtimechange
                    </code>
                </td>
                <td>
                    Wird ausgelöst, wenn sich die Zeit ändert, die es braucht, bis die Batterie leer ist.
                </td>
            </tr>
            <tr>
                <td>
                    <code>
                        level
                    </code>
                </td>
                <td>
                    Gibt den Batteriestand als Fließkommazahl zwischen 0 (nicht geladen) und 1 (vollständig geladen) an.
                </td>
                <td>
                    <code>
                        levelchange
                    </code>
                </td>
                <td>
                    Wird ausgelöst, wenn sich der Batteriestand ändert.
                </td>
            </tr>
        </table>

        <code-block collapsed-title="worker.js" collapsible="true" lang="javascript">
            <![CDATA[
                navigator.getBattery().then(function (battery){
                  console.log(battery.level);
                  battery.addEventListener('chargingchange', console.log('chargingchange'));
                  battery.addEventListener('chargingtimechange', console.log('chargingtimechange'));
                  battery.addEventListener('dischargingtimechange', console.log('dischargingtimechange'));
                  battery.addEventListener('levelchange', console.log('levelchange'));  });
                });
            ]]>
        </code-block>
    </chapter>

    <chapter id="web-speech-api" title="Sprache ausgeben und Sprache erkennen">

    </chapter>

    <chapter id="web-animation-api" title="Animationen erstellen">

    </chapter>

    <chapter id="internationalization-api" title="Mehrsprachige Anwendungen entwickeln">

    </chapter>

    <chapter id="quellen" title="Quellen">
        <tip>
            <b>(BUCH)</b>
            978-3836256971, "JavaScript", Philip Ackermann, 2019
        </tip>
        <tip>
            <b>(WEBSEITE)</b>
            <a href="https://www.w3schools.com/js/js_cookies.asp"/>, 2023-08-10 16:00
        </tip>
        <tip>
            <b>(WEBSEITE)</b>
            <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie"/>, 2023-08-10 16:30
        </tip>
    </chapter>
</topic>