<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
        SYSTEM "https://resources.jetbrains.com/writerside/1.0/xhtml-entities.dtd">
<topic id="js-ajax"
       title="AJAX (Asynchonous JavaScript and XML)"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="https://resources.jetbrains.com/writerside/1.0/topic.v2.xsd">
    <show-structure depth="2" for="chapter,procedure"/>

    <chapter id="prinzip" title="Das Prinzip von Ajax">
        <p>
            AJAX (Asynchronous JavaScript and XML) ermöglicht es nämlich, statt eine Webseite komplett neu zu laden, nur
            einzelne Teile einer Webseite dynamisch mit Inhalten vom Server zu aktualisieren. Der Begriff Asynchronous
            JavaScript and XML ist eigentlich irreführend, weil nicht nur XML als Austauschformat verwendet werden kann.
        </p>

        <chapter id="prinzip-synchrone-kommunikation" title="Synchrone Kommunikation">
            <p>
                Bei der klassischen Kommunikation zwischen Client und Server schickt der Client (in der Regel der
                Browser) eine Anfrage (HTTP-Anfrage bzw. HTTP-Request) an den Server, der diese dann auswertet und eine
                entsprechende Antwort (HTTP-Antwort bzw. HTTP-Response) an den Client zurücksendet.
            </p>
            <p>
                In Bezug auf das Laden von Webseiten bedeutet dies, dass jedes Mal, wenn der Nutzer beispielsweise auf
                einen Link klickt oder ein Formular ausfüllt, eine entsprechende HTTP-Anfrage an den Server gesendet
                wird, welcher dann den Inhalt der neuen Webseite generiert und an den Client zurücksendet
            </p>

            <img alt="Beispiel Client/Server Kommunikation Abfrage/Antwort bei synchroner Kommunikation"
                 src="js-ajax-prinzip-synchron-a.png"/>

            <p>
                Weniger schön bei diesem Ablauf ist allerdings, dass der Client bzw. der Browser warten muss, während
                der Server die Anfrage auswertet und die Antwort vorbereitet. Als Nutzer merkt man dies insoweit, als
                man in dieser Zeit keine Möglichkeit mehr hat, mit der Webseite zu interagieren, sprich, es können
                während der Wartezeit keine weiteren Anfragen getätigt werden. Aus diesem Grund nennt man diese Art der
                Kommunikation, sprich das geordnete Wechselspiel zwischen Starten einer Anfrage und Warten auf die
                Antwort, auch synchrone Kommunikation.
            </p>

            <img alt="Beispiel Client/Server Kommunikation Suchanfrage/Suchergebnisse bei synchroner Kommunikation"
                 src="js-ajax-prinzip-synchron-b.png"/>

            <p>
                Beispiel einer Suchfunktion innerhalb einer Webseite: Über ein Suchformular gibt man dabei die Kriterien
                für die Suche an und schickt anschließend das Formular ab. Der Server wertet die Suchanfrage aus, führt
                in der Regel eine oder mehrere Datenbankanfragen aus und erstellt die Webseite, welche die Ergebnisse
                der Suche enthält. Während der Server dies tut, kann man als Nutzer nichts anderes machen, als auf die
                Ergebnisse zu warten. Erst wenn alle Suchergebnisse ermittelt wurden und die Antwort vom Server geladen
                wurde, kann der Nutzer weiter interagieren, beispielsweise um die Suchergebnisse in der Übersicht
                durchzugehen oder jeweils im Detail anzuschauen.
            </p>
        </chapter>

        <chapter id="prinzip-asynchrone-kommunikation" title="Asynchrone Kommunikation">
            <p>
                Mittels AJAX läuft die Kommunikation asynchron ab: zu Beginn wird auch hier wie bei der synchronen
                Kommunikation eine vollständige Webseite vom Server geladen bzw. stellt der Client eine Anfrage an den
                Server, der diese bearbeitet und eine entsprechende Antwort liefert. Im Unterschied zur synchronen
                Kommunikation ist es bei der asynchronen Kommunikation aber auch möglich, neue Anfragen an den Server zu
                senden, während man noch auf die Antwort bereits abgeschickter Anfragen wartet.
            </p>

            <img alt="Beispiel Client/Server Kommunikation Suchanfrage/Suchergebnisse bei asynchroner Kommunikation"
                 src="js-ajax-prinzip-asynchron-a.png"/>

            <p>
                Bezogen auf das Beispiel mit der Suche, würde nach Absenden des Suchformulars beispielsweise das
                Formular ausgeblendet, ein Fortschrittsbalken angezeigt und würden – nach abgeschlossener Suche – die
                Suchergebnisse dargestellt werden. Die anderen (fixen) Bestandteile der Webseite wie Kopfbereich,
                Navigation und Fußbereich werden nicht neu geladen.
            </p>
            <p>
                Das hat gleich mehrere Vorteile: Zum einen werden die Daten für die fixen Bestandteile nicht neu vom
                Server übertragen, was sich insgesamt positiv auf die Übertragungszeit auswirkt. Zum anderen hat man als
                Nutzer die Möglichkeit, weiterhin mit anderen Komponenten auf der Webseite zu interagieren.
                Beispielsweise könnten die Suchergebnisse Stück für Stück vom Server abgefragt werden anstatt auf einen
                Schlag. Der Nutzer könnte bereits einen Teil der Suchergebnisse anschauen, Detailansichten zu den
                Ergebnissen aufrufen etc., während nach und nach vom Server weitere Suchergebnisse abgefragt werden.
            </p>
            <p>
                Technisch gesehen, werden natürlich auch bei der asynchronen Kommunikation weiterhin HTTP-Anfragen
                versendet. Nur werden diese nicht direkt durch den Browser angestoßen, sondern über JavaScript-Aufrufe
                gesteuert. Während ohne Ajax (linke Seite im Diagramm) die HTTP-Anfragen direkt durch den Browser
                ausgeführt werden, geschieht dies bei Verwendung von Ajax (rechte Seite im Diagramm) durch
                entsprechenden JavaScript-Code. Auch das Verarbeiten der Antwort vom Server übernimmt der
                JavaScript-Code, beispielsweise um auf deren Basis die Benutzeroberfläche zu aktualisieren.
            </p>

            <img alt="Beispiel Client/Server Kommunikation HTTP-Anfrage/-Antwort bei asynchroner Kommunikation"
                 src="js-ajax-prinzip-asynchron-b.png"/>
        </chapter>

        <chapter id="prinzip-anwendungsfälle" title="Typische Anwendungsfälle für die Verwendung von Ajax">
            <table style="both">
                <tr>
                    <td>
                        Anwendungsfall
                    </td>
                    <td>
                        Beschreibung
                    </td>
                </tr>
                <tr>
                    <td>
                        Automatische Vervollständigung von Eingabefeldern
                    </td>
                    <td>
                        <p>
                            Die Idee dabei ist, dem Nutzer Eingabevorschläge in Form einer Auswahlliste anzuzeigen,
                            während dieser Text in das entsprechende Eingabefeld eingibt, und somit eine Vorselektion
                            möglicher Auswahlwerte vorzunehmen. Technisch gesehen, registriert man einen Event-Listener
                            für das change-Event des entsprechenden Eingabefeldes, sendet mithilfe von Ajax eine Anfrage
                            an den Server, die die aktuelle Eingabe enthält, und zeigt die vom Server zurückgegebenen
                            Werte, die auf diese Eingabe passen, innerhalb der Auswahlliste an.
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        Paginierung von großen Datensätzen
                    </td>
                    <td>
                        <p>
                            Ein anderes Beispiel ist die Paginierung (also das Aufteilen in einzelne Seiten) von
                            Datensätzen. Gibt es nämlich viele verschiedene Datensätze (beispielsweise eine Tabelle von
                            Nutzern), ist es sinnvoll, nicht alle Datensätze in einer langen Tabelle anzuzeigen, sondern
                            jeweils nur einen Teil der Daten mit der Option, zwischen einzelnen Teilen hin- und
                            herzuwechseln.
                        </p>
                        <p>
                            Umsetzen lässt sich das Beispiel, indem zunächst per Ajax nur ein Teil der Datensätze vom
                            Server geladen wird (sozusagen die »erste Seite«, ähnlich wie bei den Suchergebnissen eben).
                            Klickt der Nutzer nun auf den Link zu einer anderen Seite, werden entsprechend die
                            Datensätze für diese selektierte Seite vom Server geladen.
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        Newsticker
                    </td>
                    <td>
                        <p>
                            Newsticker, wie in Nachrichtenseiten oder Sportseiten, verwenden Ajax, um regelmäßig
                            Anfragen an den Server zu stellen und gegebenenfalls neue Meldungen anzuzeigen. Dazu
                            verwendet man auf Clientseite die Methode setInterval(), um in bestimmten Zeitabständen per
                            Ajax Anfragen an den Server zu stellen. Liefern die Anfragen dabei neue Meldungen, werden
                            diese entsprechend im Newsticker eingebaut.
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        Editierbare UI-Komponenten
                    </td>
                    <td>
                        <p>
                            Das Konzept von Ajax hat stark die Verbreitung der Webanwendungen vorangetrieben, also
                            solcher Webseiten, die sich wie klassische Desktopanwendungen »anfühlen«, dabei aber im
                            Browser ausgeführt werden. Eine der zahlreichen GUI-Komponenten, die in solchen Anwendungen
                            zum Einsatz kommen, sind Tabellen, bei denen sich einzelne Datensätze editieren lassen. In
                            der Regel kann man dabei per Doppelklick auf eine Tabellenzelle den Editiermodus starten und
                            den Wert in der Zelle anpassen. Im Hintergrund wird der entsprechende Datensatz dann per
                            Ajax mit der Datenbank auf dem Server abgeglichen.
                        </p>
                    </td>
                </tr>
            </table>

            <p>
                Darüber hinaus gibt es natürlich noch eine Menge weiterer Anwendungsfälle, in denen Ajax zum Einsatz
                kommt. Generell bietet sich Ajax immer dann an, wenn Sie dynamisch Daten vom Server laden oder dorthin
                senden möchten, ohne dabei die Webseite neu zu laden.
            </p>
        </chapter>

        <chapter id="prinzip-datenformate" title="Verwendete Datenformate">
            <p>
                Prinzipiell können beliebige Formate verwendet, folgende drei werden aber besonders häufig verwendet:
            </p>

            <list>
                <li>
                    <b>HTML</b>: Dieses Format bietet sich an, wenn Sie fertige GUI-Komponenten (auch: Widgets genannt,
                    beispielsweise Kalenderkomponenten oder Ähnliches) direkt vom Server nachladen und in die Webseite
                    einbauen möchten.
                </li>
                <li>
                    <b>XML (Extensible Markup Language)</b>: Dieses Format eignet sich, wenn Sie strukturiert
                    vorliegende Daten vom Server laden (beispielsweise einzelne Datensätze für eine Tabelle) und auf
                    Basis dieser Daten Inhalte auf der Webseite generieren möchten.
                </li>
                <li>
                    <b>JSON (JavaScript Object Notation)</b>: Dieses Format eignet sich wie das XML-Format immer dann,
                    wenn Sie Daten vom Server laden möchten, um anhand dieser Daten Inhalte auf der Webseite zu
                    generieren, ist aber um einiges schlanker als XML und lässt sich vergleichsweise einfach in
                    JavaScript-Anwendungen verarbeiten.
                </li>
            </list>
        </chapter>
    </chapter>

    <chapter id="xml" title="Das XML-Format">
        <tip>
            <a href="xml.topic"/>
        </tip>

        <p>
            Wenn XML-Daten per Ajax an einen Server geschickt werden oder umgekehrt, XML-Daten per Ajax von einem Server
            abgerufen werden, findet im Hintergrund jeweils eine Umwandlung der Daten statt. Werden dabei XML-Objekte
            (vom Typ Document) in Zeichenketten umgewandelt, spricht man vom <b>Serialisieren</b> der Daten. Das
            Umwandeln von Zeichenketten in XML-Objekte bezeichnet man dagegen als <b>Parsen</b>.
        </p>

        <p>
            Um XML-Objekte auf Basis einer Zeichenkette zu erstellen, die Daten im XML-Format enthält, kann das Objekt
            DOMParser verwendet werden. Dessen Methode<code>parseFormString()</code> kann man als erstes Argument die
            entsprechende Zeichenkette übergeben, als zweites Argument den MIME-Typ (in der Regel <code>text/xml</code>).
            Schon erhält man – vorausgesetzt, die übergebene Zeichenkette enthält gültiges XML – ein Objekt vom Typ
            Document, welches das geparste XML enthält.
        </p>

        <code-block collapsed-title="Parsen einer Zeichenkette in ein XML-Dokument" collapsible="true"
                    lang="javascript">
            <![CDATA[
            let xmlString = ( '<?xml version="1.0" encoding="ISO-8859-1"?>'
                + '<artists>'
                + '<artist name="Kyuss">'
                + '<albums>'
                + '<album>'
                + '<title>Wretchv/title>'
                + '<year>1991</year>'
                + '</album>'
                + '</albums>'
                + '</artist>'
                + '</artists>' );

            let domParser = new DOMParser();
            let xmlDOM = domParser.parseFromString(xmlString, 'text/xml');
            let firstArtist = xmlDOM.querySelector('artist');

            console.log(firstArtist.getAttribute('name')); // "Kyuss"
            console.log(firstArtist.querySelector('title').textContent); // "Wretch"
            console.log(firstArtist.querySelector('year').textContent); // 1991
            ]]>
        </code-block>

        <p>
            Fürs Serialisieren von XML-Daten bietet JavaScript das Helferobjekt XMLSerializer. Dieses Objekt stellt
            die Methode <code>serializeToString()</code> zur Verfügung, welcher, als Argument das XML-Objekt übergeben
            wurde. Als Rückgabewert erhält man das serialisierte XML-Objekt in Form einer Zeichenkette.
        </p>

        <code-block collapsed-title="Serialisieren eines XML-Dokuments in eine Zeichenkette" collapsible="true"
                    lang="javascript">
            let xmlSerializer = new XMLSerializer();
            let xmlStringSerialized = xmlSerializer.serializeToString(xmlDOM);
        </code-block>
    </chapter>

    <chapter id="json" title="Das JSON-Format">
        <tip>
            <a href="json.topic"/>
        </tip>

        <p>
            JSON (JavaScript Object Notation) ist ein – im Verhältnis zu XML – relativ junges Format, welches ebenfalls
            für den Austausch von Daten zwischen Anwendungen oder eben zwischen Client und Server zum Einsatz kommt. Es
            ist dabei vor allem deswegen sehr beliebt, weil es im Vergleich zu XML sehr leichtgewichtig ist, nicht so
            viel Overhead mitbringt und in JavaScript nativ unterstützt wird.
        </p>

        <table style="header-row">
            <tr>
                <td>
                    <code>
                        JSON.stringify()
                    </code>
                </td>
                <td>
                    <p>
                        Mithilfe der Methode <code>stringify()</code> des JSON-Objekts kann JavaScript-Objekte in eine
                        Zeichenkette im JSON-Format umgewandelt werden. Die Methode erwartet als erstes Argument ein
                        JavaScript-Objekt und liefert als Ergebnis die entsprechende Zeichenkette, welche das Objekt im
                        JSON-Format enthält.
                    </p>
                    <p>
                        Als zweites Argument kann man optional eine Funktion übergeben, über die sich gewisse Aspekte
                        beim Umwandeln steuern lassen: Diese Funktion wird während des Umwandelns für jede Eigenschaft
                        des JavaScript-Objekts aufgerufen. Ihr Rückgabewert bestimmt dann den Zielwert, sprich den Wert,
                        der für die jeweilige Eigenschaft in das umgewandelte JSON übernommen werden soll. Möchte man
                        die Werte nicht umwandeln, sondern so übernehmen, wie sie sind, kann man statt einer Funktion
                        auch einfach den Wert null übergeben.
                    </p>
                    <p>
                        Über das dritte Argument lässt sich zudem die Einrückung der geschweiften Klammern beeinflussen.
                    </p>
                </td>
            </tr>
            <tr>
                <td>
                    <code>
                        JSON.parse()
                    </code>
                </td>
                <td>
                    <p>
                        Die Methode <code>parse()</code> kann für das Umwandeln einer Zeichenkette im JSON-Format in
                        ein JavaScript-Objekt verwendet werden. Als erstes Argument erwartet die Methode die
                        entsprechende Zeichenkette. Über die optional als zweites Argument übergebene Funktion lässt
                        sich steuern, welcher Wert während des Umwandelns für das Zielobjekt verwendet werden soll.
                        Aufgerufen wird diese Funktion für jede Eigenschaft.
                    </p>
                </td>
            </tr>
        </table>

        <code-block collapsed-title="Beispiel" collapsible="true" lang="javascript">
            <![CDATA[
            let object = {
                "artists": [
                    { "name": "Kyuss", "albums": [ { /* ... */ } ] }
                    /* ... */
                ]
            }

            let string = JSON.stringify(
                object, // JavaScript-Objekt
                (key, value) => {    // Ersetzungsfunktion
                    return value;    // Rückgabewert bestimmt Zielwert
                },
                2                    // Einrückung
            );
            console.log(string);

            let objectParsed = JSON.parse(
                string,                       // JSON
                (key, value) => {             // Ersetzungsfunktion
                    return value;             // Rückgabewert bestimmt Zielwert
                }
            );

            console.log(objectParsed.artists);           // [Object, Object]
            console.log(objectParsed.artists.length);    // 2
            console.log(objectParsed.artists[0].name);   // "Kyuss"
            console.log(objectParsed.artists[1].name);   // "Ben Harper"
            ]]>
        </code-block>
    </chapter>

    <chapter id="abfragen" title="Anfragen per Ajax stellen">
        <chapter id="abfragen-xmlhttprequest" title="Das »XMLHttpRequest«-Objekt">
            <p>
                Die Basis für alle Arten von Ajax-Anfragen bildet das Objekt XMLHttpRequest, welches ursprünglich von
                Microsoft entwickelt und im Laufe der Zeit von den anderen Browserherstellern übernommen wurde.
                Mittlerweile arbeitet man sogar beim W3C an einer Standardisierung dieses Objekts (siehe
                <a href="https://www.w3.org/TR/XMLHttpRequest/"/>).
            </p>

            <p>
                Der Ablauf bei der Formulierung einer Ajax-Anfrage ist unter Verwendung des XMLHttpRequest-Objekts immer
                ähnlich und besteht aus den folgenden Schritten:
            </p>

            <table style="header-row">
                <tr>
                    <td>
                        Methode
                    </td>
                    <td>
                        Beschreibung
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            abort()
                        </code>
                    </td>
                    <td>
                        <p>
                            Bricht eine Anfrage ab.
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            getAllResponseHeaders()
                        </code>
                    </td>
                    <td>
                        <p>
                            Gibt alle Header der HTTP-Antwort als Zeichenkette zurück.
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            getResponseHeader(header)
                        </code>
                    </td>
                    <td>
                        <p>
                            Gibt für den Namen eines Headers den entsprechenden Wert zurück.
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            open(method, url, async, user, password)
                        </code>
                    </td>
                    <td>
                        <p>
                            Startet eine Anfrage. Übergeben werden dabei die zu verwendende HTTP-Methode (z. B. GET oder
                            POST), die URL, an welche die Anfrage gesendet werden soll, ein boolescher Wert, der angibt,
                            ob die Anfrage synchron (false) oder asynchron (true) stattfinden soll, und eventuell
                            Nutzernamen und Passwort für zugriffsgeschützte URLs.
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            overrideMimeType(mime)
                        </code>
                    </td>
                    <td>
                        <p>
                            Überschreibt den vom Server zurückgegebenen MIME-Typ.
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            send()
                        </code>
                    </td>
                    <td>
                        <p>
                            Sendet eine Anfrage.
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            send(data)
                        </code>
                    </td>
                    <td>
                        <p>
                            Sendet eine Anfrage und sendet die übergebenen Daten, beispielsweise Formulardaten.
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            setRequestHeader(header, value)
                        </code>
                    </td>
                    <td>
                        <p>
                            Setzt den Wert für den angegebenen Header.
                        </p>
                    </td>
                </tr>
            </table>

            <table style="header-row">
                <tr>
                    <td>
                        Eigenschaft
                    </td>
                    <td>
                        Beschreibung
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            onabort
                        </code>
                    </td>
                    <td>
                        <p>
                            Event-Handler, der aufgerufen wird, wenn eine Anfrage über die Methode <code>abort()</code>
                            abgebrochen wurde
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            onerror
                        </code>
                    </td>
                    <td>
                        <p>
                            Event-Handler, der aufgerufen wird, wenn ein Fehler aufgetreten ist
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            onload
                        </code>
                    </td>
                    <td>
                        <p>
                            Event-Handler, der aufgerufen wird, wenn die Anfrage erfolgreich ausgeführt wurde und die
                            Antwort bereitsteht
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            onloadend
                        </code>
                    </td>
                    <td>
                        <p>
                            Event-Handler, der aufgerufen wird, nachdem die Anfrage erfolgreich ausgeführt wurde
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            onloadstart
                        </code>
                    </td>
                    <td>
                        <p>
                            Event-Handler, der aufgerufen wird, nachdem die Anfrage gestartet wurde
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            onprogress
                        </code>
                    </td>
                    <td>
                        <p>
                            Event-Handler, der bei Fortschritt der Anfrage aufgerufen wird
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            onreadystatechange
                        </code>
                    </td>
                    <td>
                        <p>
                            Event-Handler, der bei Zustandsänderungen der Anfrage aufgerufen wird
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            ontimeout
                        </code>
                    </td>
                    <td>
                        <p>
                            Event-Handler, der aufgerufen wird, falls die Anfrage aufgrund eines Timeouts abgebrochen
                            wurde
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            readyState
                        </code>
                    </td>
                    <td>
                        <p>
                            Enthält den aktuellen Zustand der Anfrage codiert als Zahlenwert.
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            response
                        </code>
                    </td>
                    <td>
                        <p>
                            Enthält den »Körper« der Antwort, entweder vom Typ <code>ArrayBuffer</code>,
                            <code>Blob</code> oder <code>Document</code>, ein JSON-Objekt, eine Zeichenkette oder null
                            für den Fall, dass die Anfrage noch nicht abgeschlossen ist oder nicht erfolgreich war.
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            responseText
                        </code>
                    </td>
                    <td>
                        <p>
                            Enthält die Antwort als Zeichenkette oder den Wert null, falls die Anfrage noch nicht
                            abgeschlossen ist oder nicht erfolgreich war.
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            responseType
                        </code>
                    </td>
                    <td>
                        <p>
                            Über diese Eigenschaft kann bestimmt werden, welchen Datentyp die Antwort haben soll. Kann
                            einen von folgenden Werten haben (in Klammern steht dabei jeweils der Typ der Antwort).
                        </p>
                        <list type="bullet">
                            <li>
                                leere Zeichenkette (<code>String</code>)
                            </li>
                            <li>
                                <code>arraybuffer</code> (<code>ArrayBuffer</code>)
                            </li>
                            <li>
                                <code>blob</code> (<code>Blob</code>)
                            </li>
                            <li>
                                <code>document</code> (<code>Document</code>)
                            </li>
                            <li>
                                <code>json</code> (JavaScript-Objekt, welches aus der Antwort geparst wurde)
                            </li>
                            <li>
                                <code>text</code> (<code>String</code>)
                            </li>
                        </list>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            responseXML
                        </code>
                    </td>
                    <td>
                        <p>
                            Enthält die Antwort als Objekt vom Typ <code>Document</code>.
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            status
                        </code>
                    </td>
                    <td>
                        <p>
                            Enthält den HTTP-Statuscode der Anfrage (z.B. <code>200</code>).
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            statusText
                        </code>
                    </td>
                    <td>
                        <p>
                            Enthält neben dem HTTP-Statuscode auch die Statusmeldung (z.B. <code>200 OK</code>).
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            timeout
                        </code>
                    </td>
                    <td>
                        <p>
                            Über diese Eigenschaft kann die Anzahl an Millisekunden definiert werden, die eine Anfrage
                            dauern darf, bevor sie durch einen Timeout abgebrochen wird.
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            upload
                        </code>
                    </td>
                    <td>
                        <p>
                            Event-Handler, über den beim Hochladen von Daten der Status mitverfolgt werden kann.
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            withCredentials
                        </code>
                    </td>
                    <td>
                        <p>
                            Über diese Eigenschaft lässt sich definieren, ob Anfragen mit Credentials wie beispielsweise
                            Cookies oder Autorisierungs-Headern durchgeführt werden sollen.
                        </p>
                    </td>
                </tr>
            </table>

            <table style="header-row">
                <tr>
                    <td>
                        Event-Listener
                    </td>
                    <td>
                        Beschreibung
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            loadstart
                        </code>
                    </td>
                    <td>
                        <p>
                            Anfrage gestartet
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            progress
                        </code>
                    </td>
                    <td>
                        <p>
                            Fortschritt
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            abort
                        </code>
                    </td>
                    <td>
                        <p>
                            Anfrage abgebrochen
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            error
                        </code>
                    </td>
                    <td>
                        <p>
                            Fehler bei der Anfrage
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            load
                        </code>
                    </td>
                    <td>
                        <p>
                            Antwort geladen
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            timeout
                        </code>
                    </td>
                    <td>
                        <p>
                            Anfrage wegen Timeout abgebrochen
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            loadend
                        </code>
                    </td>
                    <td>
                        <p>
                            Anfrage beendet
                        </p>
                    </td>
                </tr>
            </table>

            <code-block collapsed-title="Beispiel" collapsible="true" lang="javascript">
                <![CDATA[
                request.addEventListener('loadstart', (event) => { /* ... */ });
                ]]>
            </code-block>
        </chapter>

        <chapter id="abfragen-html" title="HTML-Daten per Ajax laden">
            <tip>
                <a href="html.topic"/>
            </tip>

            <p>
                Nach erfolgreicher Anfrage (und erfolgreicher Antwort) kann innerhalb des entsprechenden Event-Handlers
                bzw. Event-Listeners für das <code>load</code>-Event die Eigenschaft <code>responseText</code> des
                Anfrageobjekts auszulesen. Diese enthält den »Körper« der vom Server zurückgesendeten Antwort als
                Zeichenkette (sprich die übertragenen Daten ohne Kopfdaten wie Header etc.). Außerdem sollten der Header
                Accept auf <code>text/html</code>gesetzt werden, damit nur Antworten vom Server akzeptiert werden, die
                auch HTML enthalten. Indem für die Eigenschaft <code>responseType</code> der Wert
                <code>'document'</code> gesetzt wird, wird die Antwort direkt in ein Objekt vom Typ<code>Document</code>
                geparst.
            </p>

            <code-block collapsed-title="Beispiel" collapsible="true" lang="javascript">
                <![CDATA[
                    'use strict';
                    let request = new XMLHttpRequest();
                    request.onload = (e) => {
                      if(request.status === 200) {
                        let html = request.responseText;
                      }
                    };
                    request.open('GET', 'content/snippet.html');
                    request.responseType = 'document';
                    request.setRequestHeader('Accept', 'text/html');
                    request.send();
                ]]>
            </code-block>
        </chapter>

        <chapter id="abfragen-xml" title="XML-Daten per Ajax laden">
            <tip>
                <a href="xml.topic"/>
            </tip>

            <p>
                Oft ist es sinnvoller, Daten nicht im HTML-Format vom Server zu laden, sondern das Erzeugen des
                HTML-Codes auf Clientseite zu übernehmen. Möchte man beispielsweise verschiedene Datensätze aus einer
                Datenbank auslesen und in einer HTML-Tabelle darstellen, ist es wenig sinnvoll, die HTML-Tabelle erst
                serverseitig zu generieren und dann an den Client zurückzusenden. Besser ist es, nur die einzelnen
                Datensätze vom Server zu holen – beispielsweise in Form eines XML-Dokuments – und die Generierung der
                HTML-Tabelle auf Clientseite durchzuführen. Dies gewährleistet eine saubere Trennung zwischen den Daten
                und dem HTML-Code.
            </p>

            <p>
                Prinzipiell erkennt der Browser anhand des vom Server in der HTTP-Antwort zurückgesendeten MIME-Typs,
                dass es sich bei dem zurückgesendeten Inhalt um Daten im XML-Format handelt. Der automatischen Erkennung
                kann aber ein wenig nachgeholfen werden, indem der Eigenschaft <code>repsonseType</code> der Wert
                <code>document</code> zugewiesen wird. Innerhalb des Event-Handlers/Event-Listeners steht dann das
                geparste XML über die Eigenschaft <code>responseXML</code> in Form eines Objekts vom Typ
                <code>Document</code> zur Verfügung. Außerdem sollte der Header Accept auf den Wert
                <code>text/xml</code> oder <code>application/xml</code>gesetzt werden, um nur Daten im XML-Format zu
                akzeptieren.
            </p>

            <code-block collapsed-title="Beispiel" collapsible="true" lang="javascript">
                <![CDATA[
                    'use strict';
                    let request = new XMLHttpRequest();
                    request.onload = (e) => {
                      if(request.status === 200) {
                        let xml = request.responseXML;
                      }
                    };
                    request.open('GET', 'content/data.xml');
                    request.responseType = 'document';
                    request.setRequestHeader('Accept', 'text/xml');
                    request.send(null);
                ]]>
            </code-block>
        </chapter>

        <chapter id="abfragen-json" title="JSON-Daten per Ajax laden">
            <tip>
                <a href="json.topic"/>
            </tip>

            <p>
                Das Format JSON eignet sich, sehr gut für die direkte Verwendung in JavaScript-Anwendungen.
            </p>

            <p>
                Beim Verarbeiten der Antwort vom Server innerhalb des <code>onload</code>-Event-Handlers sollte man, um
                an ein JSON-Objekt zu gelangen, dann die Eigenschaft <code>responseType</code> auslesen. Enthält diese
                den Wert <code>json</code>, kann direkt über die Eigenschaft <code>response</code> des Anfrageobjekts
                auf die Antwort bzw. das JSON-Objekt zugegriffen werden. Ist der Wert der Eigenschaft dagegen nicht
                <code>json</code> (d.h., der Browser unterstützt diesen Wert nicht), muss man einen kleinen Umweg gehen
                und den Inhalt der Eigenschaft <code>responseText</code> über die Methode <code>parse()</code> manuell
                in ein JSON-Objekt umwandeln.
            </p>

            <p>
                Als Wert für den <code>Accept</code>-Header sollte beim Abfragen von JSON-Daten
                <code>application/json</code> verwendet werden, um nur solche Daten vom Server zu akzeptieren, die auch
                wirklich vom Typ JSON sind.
            </p>

            <code-block collapsed-title="Beispiel" collapsible="true" lang="javascript">
                <![CDATA[
                    'use strict';
                    let request = new XMLHttpRequest();
                    request.onload = () => {
                      if(request.status === 200) {
                        let json;
                        if (request.responseType === 'json') {
                          json = request.response;
                        } else {
                          json = JSON.parse(request.responseText);
                        }
                      }
                    };
                    request.open('GET', 'data/content.json', true);
                    request.responseType = 'json';
                    request.setRequestHeader('Accept', 'application/json');
                    request.send();
                ]]>
            </code-block>
        </chapter>

        <chapter id="abfragen-daten-schicken" title="Daten per Ajax an den Server schicken">

        </chapter>

        <chapter id="abfragen-formulare-schicken" title="Formulare per Ajax abschicken">

        </chapter>

        <chapter id="abfragen-daten-von-anderen-domains-laden" title="Daten von anderen Domains laden">

        </chapter>

        <chapter id="abfragen-fetch-api" title="Die neuere Alternative zu »XMLHttpRequest«: die Fetch API">

        </chapter>
    </chapter>

    <chapter id="quellen" title="Quellen">

    </chapter>
</topic>