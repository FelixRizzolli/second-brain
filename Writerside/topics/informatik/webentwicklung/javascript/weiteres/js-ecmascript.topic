<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
        SYSTEM "https://resources.jetbrains.com/writerside/1.0/xhtml-entities.dtd">
<topic id="js-ecmascript"
       title="EcmaScript"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="https://resources.jetbrains.com/writerside/1.0/topic.v2.xsd">
    <show-structure depth="2" for="chapter,procedure"/>

    <chapter id="was-ist-ecmascript" title="Was ist EcmaScript?">
        <p>
            EcmaScript ist bekannt als Standard für JavaScript, der die Interoperabilität von Webseiten zwischen
            verschiedenen Webbrowsern gewährleisten soll. Der ECMAScript-Standard hat seit Version ES2015 eine Reihe von
            Neuerungen gebracht, die die Programmierung mit JavaScript an vielen Stellen erheblich erleichtern.
        </p>
    </chapter>

    <chapter id="ueberblick" title="Überblick">
        <table style="header-row">
            <tr>
                <td>
                    Feature
                </td>
                <td>
                    Beschreibung
                </td>
                <td>
                    Mehr
                </td>
            </tr>
            <tr>
                <td>
                    Schlüsselwort <code>let</code>
                </td>
                <td>
                    Deklaration von Variablen im Gültigkeitsbereich des jeweils lokalen Blocks.
                </td>
                <td>
                    <a href="js-sprachkern.topic#variablen">
                        Variablen, Konstanten und Typisierung
                    </a>
                </td>
            </tr>
            <tr>
                <td>
                    Schlüsselwort <code>const</code>
                </td>
                <td>
                    Deklaration von Konstanten
                </td>
                <td>
                    <a href="js-sprachkern.topic#variablen">
                        Variablen, Konstanten und Typisierung
                    </a>
                </td>
            </tr>
            <tr>
                <td>
                    Standardwerte für Parameter
                </td>
                <td>
                    Angabe von Standardwerten für Parameter
                </td>
                <td>
                    <a href="js-sprachkern.topic#funktionen-parameter-standardwerte">
                        Standardwerte für Parameter
                    </a>
                </td>
            </tr>
            <tr>
                <td>
                    Rest-Parameter
                </td>
                <td>
                    Zusammenfassen der optionalen Parameter einer Funktion
                </td>
                <td>
                    <a href="js-sprachkern.topic#funktionen-parameter-variable-anzahl-an-argumenten">
                        Funktionen mit einer variablen Anzahl an Argumenten: variadische Funktionen
                    </a>
                </td>
            </tr>
            <tr>
                <td>
                    Spread-Operator
                </td>
                <td>
                    Verteilen der Werte eines Arrays auf die Parameter einer Funktion
                </td>
                <td>
                    <a href="js-sprachkern.topic#funktionen-parameter-spread-operator">
                        Der Spread-Operator: Elemente aus einem Array als Argumente verwenden
                    </a>
                </td>
            </tr>
            <tr>
                <td>
                    Klassensyntax
                </td>
                <td>
                    Definition von »Klassen« zur Vereinfachung der pseudoklassischen Objektorientierung
                </td>
                <td>
                    <a href="js-oop.topic#grundlagen-objekte-erstellen-klassensyntax">
                        Objektorientierung mit Klassensyntax
                    </a>
                </td>
            </tr>
            <tr>
                <td>
                    Destructuring
                </td>
                <td>
                    Mehrfachzuweisungen von Objekteigenschaften zu Variablen oder von Arrays zu Variablen
                </td>
                <td>
                    <a href="#destructing">
                        Destructuring
                    </a>
                </td>
            </tr>
            <tr>
                <td>
                    <code>for-of</code>-Schleife
                </td>
                <td>
                    Iteration über iterierbare Objekte
                </td>
                <td>
                    <a href="#iteratoren-for-of">
                        Über Maps iterieren: for-of-Schleifen
                    </a>
                </td>
            </tr>
            <tr>
                <td>
                    Arrow Functions
                </td>
                <td>
                    Deklaration von Funktionen, die sich im Gegensatz zu »normal« definierten Funktionen auf den Kontext
                    beziehen, in dem sie definiert wurden, nicht zwangsweise auf den Kontext, in dem sie ausgeführt
                    werden
                </td>
                <td>
                    <a href="js-sprachkern.topic#funktionen-arrow-functions">
                        Arrow Functions
                    </a>
                </td>
            </tr>
            <tr>
                <td>
                    Datenstrukturen <code>Set</code> und <code>WeakSet</code>
                </td>
                <td>
                    Datenstruktur, in der Elemente nur einmal vorkommen dürfen
                </td>
                <td>
                    <a href="#sets">
                        ES2015 Sets
                    </a>
                </td>
            </tr>
            <tr>
                <td>
                    Datenstrukturen <code>Map</code> und <code>WeakMap</code>
                </td>
                <td>
                    Datenstruktur, um Schlüssel-Wert-Paare zu speichern
                </td>
                <td>
                    <a href="#maps">
                        ES2015 Maps
                    </a>
                </td>
            </tr>
            <tr>
                <td>
                    Typisierte Arrays
                </td>
                <td>
                    array-ähnliche Objekte, die den Zugriff auf binäre Rohdaten abstrahieren
                </td>
                <td></td>
            </tr>
            <tr>
                <td>
                    Iteratoren
                </td>
                <td>
                    Vereinfacht das Iterieren über Datenstrukturen wie Arrays, Sets und Maps.
                </td>
                <td>
                    <a href="#iteratoren">
                        ES2015 Iteratoren
                    </a>
                </td>
            </tr>
            <tr>
                <td>
                    Generatoren
                </td>
                <td>
                    Ermöglichen es, Funktionen an bestimmten Stellen anzuhalten und zu einem späteren Zeitpunkt wieder
                    fortzuführen.
                </td>
                <td>
                    <a href="#generatoren">
                        ES2015 Generatoren: Funktionen anhalten und fortsetzen
                    </a>
                </td>
            </tr>
            <tr>
                <td>
                    Proxies
                </td>
                <td>
                    Erlauben es, Zugriffe auf Objekte abzufangen.
                </td>
                <td>
                    <a href="#proxies">
                        ES2015 Proxies: Zugriff auf Objekte abfangen
                    </a>
                </td>
            </tr>
            <tr>
                <td>
                    Symbole
                </td>
                <td>
                    neuer primitiver Datentyp, der hauptsächlich als eindeutige Kennzeichnung von Objekteigenschaften
                    zum Einsatz kommt
                </td>
                <td>
                    <a href="#symbol">
                        ES2015 Symbole
                    </a>
                </td>
            </tr>
            <tr>
                <td>
                    Template-Strings
                </td>
                <td>
                    Erlauben u.a. eingebettete Ausdrücke innerhalb von Zeichenketten.
                </td>
                <td>
                    <a href="#template-string">
                        ES2015 Vorlagen für Zeichenketten
                    </a>
                </td>
            </tr>
            <tr>
                <td>
                    Module
                </td>
                <td>
                    Definition von Modulen
                </td>
                <td>
                    <a href="js-entwurfsmuster.topic#modules-native">
                        Entwurfsmuster: Native Module
                    </a>
                </td>
            </tr>
            <tr>
                <td>
                    Erweiterungen der API
                </td>
                <td>
                    Neue Methoden in <code>Array</code>, <code>Date</code>, <code>Math</code>, <code>Number</code>,
                    <code>Object</code>, <code>RegExp</code>, <code>String</code>
                </td>
                <td>
                    <a href="js-oop.topic#globale-objekte">
                        Globale Objekte
                    </a>
                </td>
            </tr>
            <tr>
                <td>
                    Exponentialoperator
                </td>
                <td>
                    Operator, über den sich Potenzen berechnen lassen
                </td>
                <td>
                    <a href="js-sprachkern.topic#operatoren">
                        Operatoren
                    </a>
                </td>
            </tr>
            <tr>
                <td>
                    String Padding
                </td>
                <td>
                    Auffüllen von Zeichenketten
                </td>
                <td>
                    <a href="js-oop.topic#globale-objekte-primitiver-datentypen-pad-start-und-end">
                        Die Methoden padStart() und padEnd()
                    </a>
                </td>
            </tr>
            <tr>
                <td>
                    Async Functions
                </td>
                <td>
                    Vereinfachung asynchroner Programmierung
                </td>
                <td>
                    <a href="#async">
                        ES2016 Async Functions
                    </a>
                </td>
            </tr>
        </table>
    </chapter>

    <chapter id="maps" title="ES2015 – Maps">
        <p>
            Maps bezeichnen in der Programmierung eine Datenstruktur, in der Schlüssel-Wert-Paare gespeichert werden
            können (auch Key/Value-Pairs genannt). Oder anders gesagt: Innerhalb einer Map können zu Schlüsseln einzelne
            Werte abgelegt werden, die dann über die Schlüssel abgerufen werden können. Die Schlüssel innerhalb einer
            Map müssen dabei eindeutig sein, Werte hingegen können mehrfach vorkommen. Die Konstruktorfunktion der
            Klasse Map erwartet ein Objekt als Argument, welches iterierbar ist. Unter einem iterierbaren Objekt
            versteht man ein Objekt, welches sein eigenes Iterationsverhalten definiert, sodass es sich beispielsweise
            direkt in einer Schleife als Eingabe verwenden lässt. Einige der Standardobjekte wie <code>String</code>,
            <code>Array</code>, <code>Map</code> und <code>Set</code> sind bereits standardmäßig iterierbar.
        </p>

        <img alt="ES2015 – Maps" src="js-professional-maps.png"/>

        <code-block lang="javascript">
            <![CDATA[
                'use strict';
                let numbersOfAlbums = new Map([
                  ['Kyuss', 4],
                  ['Tool', 6],
                  ['Monster Magnet', 8],
                  ['Ben Harper', 9],
                  ['Queens of the Stone Age', 6]
                ]);
                console.log(numbersOfAlbums.size);
            ]]>
        </code-block>

        <chapter id="maps-methoden-und-eigenschaften" title="Methoden und Eigenschaften">
            <table style="header-row">
                <tr>
                    <td>
                        Methode/Eigenschaft
                    </td>
                    <td>
                        Beschreibung
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            clear()
                        </code>
                    </td>
                    <td>
                        Löscht alle Schlüssel-Wert-Paare aus der Map.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            delete()
                        </code>
                    </td>
                    <td>
                        Löscht zu einem übergebenen Schlüssel den Wert aus der Map. Bei erfolgreichem Löschen gibt die
                        Methode <code>true</code> zurück, andernfalls <code>false</code>.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            get()
                        </code>
                    </td>
                    <td>
                        Liefert zu einem Schlüssel den assoziierten Wert. Gibt es den Schlüssel in der Map nicht, gibt
                        die Methode ein <code>undefined</code> zurück.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            has()
                        </code>
                    </td>
                    <td>
                        Prüft, ob es zu einem Schlüssel einen Wert in der Map gibt. Wenn ja, gibt die Methode ein
                        <code>true</code> zurück, ansonsten ein <code>false</code>.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            set()
                        </code>
                    </td>
                    <td>
                        Setzt zu einem Schlüssel den entsprechenden Wert. Ist der Schlüssel bereits in der Map
                        vorhanden, wird der damit assoziierte Wert überschrieben.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            size
                        </code>
                    </td>
                    <td>
                        Enthält die Anzahl an Schlüssel-Wert-Paaren in der Map.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            entries()
                        </code>
                    </td>
                    <td>
                        Liefert einen Iterator zurück, mithilfe dessen man über die Schlüssel-Wert-Paare der Map
                        iterieren kann.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            keys()
                        </code>
                    </td>
                    <td>
                        Analog zu <code>entries()</code> gibt diese Methode einen Iterator für die Schlüssel der Map
                        zurück.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            values()
                        </code>
                    </td>
                    <td>
                        Analog zu <code>entries()</code> gibt diese Methode einen Iterator für die Werte der Map zurück.
                    </td>
                </tr>
            </table>
        </chapter>

        <chapter id="maps-weak" title="Weak Maps">
            <p>
                Die durch diesen Typ repräsentierten Weak Maps sind prinzipiell ähnlich den normalen Maps, unterscheiden
                sich jedoch grundsätzlich in einem wesentlichen Punkt: Objekte, die als Schlüssel verwendet werden,
                können im Rahmen der Garbage Collection gelöscht werden, sofern diese Objekte (außerhalb der Weak Map)
                nicht mehr referenziert werden. Die Objekte in einer Weak Map werden sozusagen »schwach« (weak)
                referenziert (daher der Name Weak Map).
            </p>

            <p>
                Diese Eigenschaft von Weak Maps hat direkte Auswirkungen auf die API: Zum einen können als Schlüssel bei
                Weak Maps nur Objekte verwendet werden und nicht – wie es bei normalen Maps möglich ist – primitive
                Datentypen. Das heißt, auch Zeichenketten sind beispielsweise als Schlüssel in einer Weak Map nicht
                erlaubt.
            </p>

            <p>
                Zum anderen stehen die Methoden <code>keys()</code>, <code>values()</code> und <code>entries()</code>
                bei Weak Maps nicht zur Verfügung. Der Grund ist folgender: All diese Methoden würden Iteratoren
                zurückgeben, für die nicht garantiert wäre, dass der interne Zustand nach einer Garbage Collection noch
                stimmt. Objekte könnten bereits durch die Garbage Collection gelöscht worden sein, aber trotzdem noch in
                der internen Zählung des Iterators vorkommen.
            </p>

            <p>
                Aus ähnlichem Grund steht in Weak Maps ebenfalls nicht die Eigenschaft <code>size</code> zur Verfügung.
                Die restliche API unterscheidet sich aber nicht von den normalen Maps. Bis auf eine weitere Ausnahme:
                Die Methode <code>clear()</code> wurde zwischenzeitlich für Weak Maps wieder aus dem Standard entfernt.
            </p>

            <tip>
                Mehr zu Weak Maps:
                <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap"/>
            </tip>
        </chapter>
    </chapter>

    <chapter id="sets" title="ES2015 – Sets">
        <p>
            Unter einem Set (im Deutschen Menge) versteht man in der Programmierung eine Datenstruktur ähnlich einer
            Liste, in der Werte jedoch nur einmal vorkommen dürfen, sprich doppelte Werte nicht erlaubt sind. Um ein Set
            zu erstellen, verwendet man einfach die Konstruktorfunktion <code>Set</code>. Als Wert kann dabei wie schon
            bei Maps ein Array übergeben werden (bzw. ein iterierbares Objekt), welches die initialen Werte enthält, die
            dem Set hinzugefügt werden sollen.
        </p>

        <code-block lang="javascript">
            <![CDATA[
                let mySet = new Set([ 1, 1, 2 ]); // => Set(2) {1, 2}
            ]]>
        </code-block>

        <chapter id="sets-methoden-und-eigenschaften" title="Methoden und Eigenschaften">
            <table style="header-row">
                <tr>
                    <td>
                        Methode/Eigenschaft
                    </td>
                    <td>
                        Beschreibung
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            add()
                        </code>
                    </td>
                    <td>
                        Fügt ein Element dem Set hinzu.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            clear()
                        </code>
                    </td>
                    <td>
                        Löscht alle Elemente aus dem Set.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            delete()
                        </code>
                    </td>
                    <td>
                        Löscht das übergebene Element aus dem Set.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            has()
                        </code>
                    </td>
                    <td>
                        Überprüft, ob das übergebene Element im Set enthalten ist.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            entries()
                        </code>
                    </td>
                    <td>
                        Gibt einen Iterator zurück, der die Wert-Wert-Paare des Sets enthält. Die Reihenfolge der Paare
                        entspricht dabei der, in der sie dem Set hinzugefügt wurden. Der Grund, warum Wert-Wert-Paare
                        zurückgegeben werden, ist, damit Sets über die gleiche API wie die Methode
                        <code>entries()</code> von Map verfügen (bei der ja bekanntermaßen eben Schlüssel-Wert-Paare
                        zurückgegeben werden).
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            keys()
                        </code>
                    </td>
                    <td>
                        Gibt einen Iterator zurück, der die Werte des Sets enthält. Die Reihenfolge der Werte entspricht
                        dabei der, in der sie dem Set hinzugefügt wurden.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            values()
                        </code>
                    </td>
                    <td>
                        Gibt wie <code>keys()</code> einen Iterator zurück, der die Werte des Sets enthält. Die
                        Reihenfolge der Werte entspricht auch hier der, in der sie dem Set hinzugefügt wurden.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            size
                        </code>
                    </td>
                    <td>
                        Eigenschaft, welche die Anzahl an Elementen im Set repräsentiert
                    </td>
                </tr>
            </table>
        </chapter>

        <chapter id="sets-weak" title="Weak Sets">
            <p>
                Analog zu den Weak Maps für Maps gibt es für Sets die Weak Sets-Alternative, die durch den Typ WeakSet
                repräsentiert wird. Hierbei werden im Rahmen der Garbage Collection regelmäßig die Objekte aus dem Set
                gelöscht, die nicht mehr anderweitig referenziert werden. Auch für Weak Sets gilt wie schon für Weak
                Maps, dass sie nicht die Methoden <code>keys()</code>, <code>values()</code> und <code>entries()</code>
                bereitstellen, keine Eigenschaft <code>size</code> haben und in der aktuellen Arbeitsversion des
                ECMAScript-Standards auch nicht – wie ursprünglich vorgesehen – über die Methode <code>clear()</code>
                verfügen. Zudem gilt auch hier, dass keine primitiven Datentypen als Werte eines Weak Sets hinzugefügt
                werden können.
            </p>

            <tip>
                Mehr zu Weak Sets:
                <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet"/>
            </tip>
        </chapter>
    </chapter>

    <chapter id="iteratoren" title="ES2015 – Iteratoren">
        <img alt="ES2015 – Iteratoren" src="js-professional-iteratoren.png"/>

        <p>
            Datentypen wie <code>Map</code> und <code>Set</code> (und im übrigen auch <code>Array</code>) geben über die
            Methoden <code>keys()</code>, <code>values()</code> und <code>entries()</code> sogenannte Iteratoren zurück,
            die dann direkt in <code>for-of</code>-Schleifen als Eingabe verwendet werden können. Verallgemeinert
            gesagt, abstrahieren Iteratoren die Iteration über Datenstrukturen. Vereinfacht gesagt, handelt es sich
            dabei um Objekte, die eine Art Zeiger auf eine unterliegende Datenstruktur enthalten, der über Aufrufe der
            Methode <code>next()</code> am Iterator verschoben werden kann. Das jeweilige Element, auf das dann der
            Zeiger zeigt, wird dabei von <code>next()</code> zurückgegeben.
        </p>

        <code-block collapsed-title="Beispiel anhand eines Arrays" collapsible="true" lang="javascript">
            <![CDATA[
                'use strict';
                let artists = [ 'Deep Purple', 'Jimi Hendrix', 'The Doors', 'King Crimson' ];
                let iterator = artists.values();  // Erzeugen des Iterators
                let artist = iterator.next();     // erster Wert im Iterator
                console.log(artist);              // Ausgabe: {value: 'Deep Purple', done: false}
                artist = iterator.next();         // weiter im Iterator
                console.log(artist);              // Ausgabe: {value: 'Jimi Hendrix', done: false}
                artist = iterator.next();         // weiter im Iterator
                console.log(artist);              // Ausgabe: {value: 'The Doors', done: false}
                artist = iterator.next();         // weiter im Iterator
                console.log(artist);              // Ausgabe: {value: 'King Crimson', done: false}
                artist = iterator.next();         // weiter im Iterator
                console.log(artist);              // Ausgabe: {value: undefined, done: true}
            ]]>
        </code-block>

        <chapter id="iteratoren-erstellen" title="Einen Iterator erstellen">
            <code-block lang="javascript">
                <![CDATA[
                    let artists = [ 'Deep Purple', 'Jimi Hendrix', 'The Doors', 'King Crimson' ];
                    function createIterator(array) {
                      let counter = array.length-1;
                      return {
                        next: function() {
                          if (counter < 0) {
                            return { value: undefined, done: true };
                          } else {
                            return { value: array[counter--], done: false };
                          }
                        }
                      }
                    };
                    let iterator = createIterator(artists);
                    let artist = iterator.next(); // erster Wert im Iterator
                    console.log(artist);          // Ausgabe: {value: 'King Crimson', done: false}
                ]]>
            </code-block>

            <p>
                JavaScript bietet einem auch die Möglichkeit, eigene Iteratoren zu erstellen. Das Beispiel zeigt die
                Implementierung eines Iterators innerhalb der Funktion <code>createIterator()</code>, der die Elemente
                eines Arrays in umgekehrter Reihenfolge ausgibt. Die Funktion gibt das <code>Iterator</code>-Objekt
                zurück. Dessen Methode <code>next()</code> implementiert das Iterationsverhalten: Wenn die
                Zählervariable (bzw. Zeigervariable) <code>counter</code> größer oder gleich <code>0</code> ist, gibt
                <code>next()</code> ein Objekt zurück, dessen <code>done</code>-Eigenschaft den Wert <code>false</code>
                hat (weil der Iterator noch nicht am Ende bzw. in diesem Fall am Anfang des Arrays angekommen ist) und
                dessen <code>value</code>-Eigenschaft das entsprechende Element aus dem Array enthält, auf das die
                Zählervariable zeigt. Über den Dekrement-Operator <code>--</code> wird nach Ermitteln des jeweiligen
                Elements dann die Zählervariable direkt um eins heruntergezählt. Hat die Zählervariable den Wert
                <code>0</code> erreicht (d.h., der Iterator ist am Ende angekommen), gibt <code>next()</code> ein Objekt
                zurück, dessen <code>done</code>-Eigenschaft den Wert <code>true</code> und dessen
                <code>value</code>-Eigenschaft den Wert <code>undefined</code> hat.
            </p>
        </chapter>

        <chapter id="iteratoren-objekt" title="Ein iterierbares Objekt erstellen">
            <code-block lang="javascript">
                <![CDATA[
                    let artists = [ 'Deep Purple', 'Jimi Hendrix', 'The Doors', 'King Crimson'];
                    let arrayWrapper = { array: artists };

                    arrayWrapper[Symbol.iterator] = function() {
                      let array = this.array;
                      let counter = this.array.length-1;

                      return {
                        next: function(){
                          if (counter < 0) {
                            return { done: true };
                          } else {
                            return { value: array[counter--], done: false };
                          }
                        }
                      }
                    };
                ]]>
            </code-block>

            <p>
                Zunächst wird ein Objekt, welches als Container für das Array dient und das Objekt ist, welches gleich
                iterierbar gemacht wird, erstellt. Das Einzige, was anschließend noch gemacht werden muss, ist, am
                <code>Container</code>-Objekt die Eigenschaft <code>Symbol.iterator</code> zu definieren und als Wert
                dabei eine Funktion anzugeben, die einen Iterator zurückgibt. Der einzige Unterschied zum Iterator ist
                der, dass der Funktion (bzw. Methode) <code>Symbol.iterator</code> kein Parameter übergeben wird,
                sondern innerhalb der Funktion auf das im <code>Container</code>-Objekt gespeicherte Array zugegriffen
                wird.
            </p>

            <p>
                In JavaScript ist ein Objekt iterierbar (engl.: <i>iterable</i>), wenn es über eine interne Methode
                <code>Symbol.iterator</code> verfügt, die einen Iterator zurückgibt.
            </p>

            <img alt="Iterierbares Objekt" src="js-professional-iterierbares-objekt.png"/>
        </chapter>

        <chapter id="iteratoren-for-of" title="Über iterierbaren Objekten iterieren: »for-of«-Schleifen">
            <p>
                Die <code>for-of</code>-Schleife unterscheidet sich von der bereits länger zum Standard gehörenden
                <code>for-in</code>-Schleife darin, dass sie nicht über die Namen der Objekteigenschaften iteriert,
                sondern über die mit diesen Eigenschaften assoziierten Werte. Mit der <code>for-of</code>-Schleife kann
                über iterierbare Objekte iteriert werden. Beispiele sind: Arrays, Maps, Sets.
            </p>

            <code-block lang="javascript">
                <![CDATA[
                    let numbers = [ 18, 22, 26, 30, 34 ];
                    numbers.name = "Zahlenarray";

                    for (let i in numbers) {
                       console.log(i); // => 0, 1, 2, 3, 4, name
                    }
                    for (let i of numbers) {
                       console.log(i); // => 18, 22, 26, 30, 34
                    }
                ]]>
            </code-block>

            <p>
                Beispiele mit Maps:
            </p>

            <table style="header-row">
                <tr>
                    <td>
                        Schleife
                    </td>
                    <td>
                        Beschreibung
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            for(let i of map.keys())
                        </code>
                    </td>
                    <td>
                        Iteriert über die in der Map enthaltenen Schlüssel.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            for(let i of map.values())
                        </code>
                    </td>
                    <td>
                        Iteriert über die in der Map enthaltenen Werte.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            for(let i of map.entries())
                        </code>
                    </td>
                    <td>
                        Iteriert über die in der Map enthaltenen Einträge, wobei <code>i[0]</code> den Schlüssel und
                        <code>i[1]</code> den Wert des Eintrages erhält.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            for(let i of map)
                        </code>
                    </td>
                    <td>
                        Da der Iterator, der von <code>entries()</code> zurückgegeben wird, auch der Iterator ist, der
                        standardmäßig dem (iterierbaren) Objekt <code>Map</code> hinterlegt ist kann der Methodenaufruf
                        <code>entries()</code> weggelassen werden.
                    </td>
                </tr>
            </table>
        </chapter>
    </chapter>

    <chapter id="generatoren" title="ES2015 – Generatoren: Funktionen anhalten und fortsetzen">

    </chapter>

    <chapter id="proxies" title="ES2015 – Proxies: Zugriff auf Objekte abfangen">

    </chapter>

    <chapter id="async" title="Asynchrone Programmierung: Promises und Async Functions">

        <chapter id="asynchone-programmierung" title="Asynchrone Programmierung">

            <chapter id="callback-design-pattern" title="Das Callback-Entwurfsmuster">

            </chapter>

            <chapter id="async-return" title="Rückgabewerte von asynchronen Funktionen">

            </chapter>

            <chapter id="async-fehler-werfen" title="Fehler werfen in asynchronen Funktionen">

            </chapter>

            <chapter id="callback-ergebnisse-und-fehler-uebergeben" title="Ergebnisse und Fehler an Callback übergeben">

            </chapter>

            <chapter id="callback-probleme" title="Das Problem asynchroner Programmierung mit Callbacks">

            </chapter>
        </chapter>

        <chapter id="promises" title="ES2015 – Promises">

            <chapter id="promises-aufrufe-verketten" title="Promise-Aufrufe verketten">

            </chapter>

            <chapter id="promises-zustaende" title="Die Zustände von Promises">

            </chapter>
        </chapter>

        <chapter id="es2016-async" title="ES2016 – Async Functions">

        </chapter>
    </chapter>

    <chapter id="template-string" title="ES2015 – Vorlagen für Zeichenketten">

    </chapter>

    <chapter id="symbol" title="ES2015 – Symbole">

        <chapter id="symbol-registry" title="Die Symbol-Registry">

        </chapter>

        <chapter id="symbol-objekteigenschaften"
                 title="Symbole zur Definition eindeutiger Objekteigenschaften verwenden">

        </chapter>

        <chapter id="symbol-konstanten" title="Symbole zur Definition von Konstanten verwenden">

        </chapter>
    </chapter>


    <chapter id="destructing" title="Destructuring – Werte aus Arrays und Objekten extrahieren">

        <chapter id="destructing-array" title="Array-Destructuring">

        </chapter>

        <chapter id="destructing-object" title="Objekt-Destructuring">

        </chapter>

        <chapter id="rest-spread-properties" title="ES2018 – Rest- und Spread-Properties">

        </chapter>
    </chapter>

    <chapter id="optional-chaining-operator" title="ES2020 – Optional Chaining Operator">

    </chapter>

    <chapter id="nullish-coalescing-operator" title="ES2020 – Nullish Coalescing Operator">

    </chapter>

    <chapter id="es2020-zuweisungsoperatoren" title="ES2020 – Neue Zuweisungsoperatoren: &amp;&amp;=, ||= und ??=">

    </chapter>

    <chapter id="numeric-seperators" title="ES2021 – Numeric Seperators">

    </chapter>

    <chapter id="quellen" title="Quellen">
        <tip>
            <b>(BUCH)</b>
            978-3836256971, "JavaScript", Philip Ackermann, 2019
        </tip>
        <tip>
            <b>(WEBSEITE)</b>
            <a href="https://en.wikipedia.org/wiki/ECMAScript"/>, 2023-08-17, 18:30
        </tip>
        <tip>
            <b>(WEBSEITE)</b>
            <a href="https://www.w3schools.com/js/js_2020.asp"/>, 2023-08-20, 08:00
        </tip>
        <tip>
            <b>(WEBSEITE)</b>
            <a href="https://www.w3schools.com/js/js_2021.asp"/>, 2023-08-20, 08:30
        </tip>
    </chapter>
</topic>