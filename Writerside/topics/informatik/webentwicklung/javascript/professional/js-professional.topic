<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
        SYSTEM "https://resources.jetbrains.com/writerside/1.0/xhtml-entities.dtd">
<topic id="js-professional"
       title="Professioneller Entwicklungsprozess"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="https://resources.jetbrains.com/writerside/1.0/topic.v2.xsd">
    <show-structure depth="2" for="chapter,procedure"/>

    <!-- TODO: migrate from Confluence -->
    <chapter id="introduction" title="Einführung">
        <p>
            Zu der professionellen Software-Entwicklung gehört auch ein professioneller Entwicklungsprozess. Aspekte
            eines professionellen Entwicklungsprozesses wären:
        </p>

        <list type="bullet">
            <li>
                Automatisieren von sich wiederholenden Aufgaben
            </li>
            <li>
                Automatisches Testen von Quelltext
            </li>
            <li>
                Quelltextverwaltung mit einem Versionsverwaltungssystem
            </li>
            <li>
                die Minifizierung von Quelltext
            </li>
            <li>
                das Ermitteln der Codequalität
            </li>
            <li>
                das sogenannte Scaffolding (sprich das automatische Generieren von Projektgerüsten)
            </li>
            <li>
                das automatische Generieren von Dokumentation
            </li>
            <li>
                das Ermitteln der Testabdeckung (also wie viel Quelltext durch die automatisierten Tests abgedeckt wird)
            </li>
            <li>
                <p>
                    und weiterführende Konzepte des Testens wie:
                </p>

                <list type="bullet">
                    <li>
                        Mock-Objekte
                    </li>
                    <li>
                        Stubs
                    </li>
                    <li>
                        Spies
                    </li>
                    <li>
                        DOM-Tests
                    </li>
                    <li>
                        Funktionstests
                    </li>
                    <li>
                        und vieles mehr
                    </li>
                </list>
            </li>
        </list>
    </chapter>

    <chapter id="automatisierung" title="Aufgaben automatisieren">
        <p>
            Im JavaScript Umfeld sind Zwei Tools für die Automatisierung von Aufgaben sehr Stark verbreitet: Grunt und
            Gulp.
        </p>

        <chapter id="automatisierung-grunt" title="Grunt">
            <p>
                Bei Grunt <a href="http://gruntjs.com"/> handelt es sich um ein auf JavaScript basierendes Build-Tool,
                welches dem Entwickler Aufgaben abnimmt und automatisch ausführt. Die Aufgaben, die durch Grunt
                automatisiert erledigt werden sollen (auch Tasks genannt), werden pro Projekt in einer
                Konfigurationsdatei mit dem Namen <code>Gruntfile.js</code> definiert, welche in der Regel im
                Wurzelverzeichnis des jeweiligen Projekts liegt.
            </p>

            <tip>
                Hier zur Installationsanleitung: <a href="https://gruntjs.com/getting-started"/>
            </tip>

            <p>
                Grunt bietet eine wahre Fülle an vorhandenen Plugins, die unter <a href="http://gruntjs.com/plugins"/>
                eingesehen werden können. Es gibt Plugins für das Überprüfen von Codequalität, für das Minifizieren von
                JavaScript- oder CSS-Dateien, für das Generieren von Dokumentation und das Ausführen von automatisierten
                Tests und, für vieles, vieles mehr.
            </p>

            <table style="header-row">
                <tr>
                    <td>
                        Plugin
                    </td>
                    <td>
                        Beschreibung
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            grunt-contrib-jshint
                        </code>
                    </td>
                    <td>
                        Validierung von JavaScript-Code mithilfe von JSHint <a href="http://jshint.com"/>.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            grunt-contrib-uglify
                        </code>
                    </td>
                    <td>
                        Minifizierung von JavaScript-Code unter Verwendung von UglifyJS
                        (<a href="https://github.com/mishoo/UglifyJS"/> bzw.
                        <a href="https://github.com/mishoo/UglifyJS2"/>).
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            grunt-contrib-concat
                        </code>
                    </td>
                    <td>
                        Zusammenfügen von mehreren JavaScript-Dateien zu einer einzelnen JavaScript-Datei.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            grunt-contrib-cssmin
                        </code>
                    </td>
                    <td>
                        Minifizierung von CSS-Dateien.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            grunt-contrib-watch
                        </code>
                    </td>
                    <td>
                        Führt bestimmte Grunt-Tasks aus, sobald sich beobachtete Dateien ändern.
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            grunt-contrib-qunit
                        </code>
                    </td>
                    <td>
                        Ausführen von auf QUnit <a href="https://qunitjs.com/"/> basierenden Unit-Tests
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            grunt-contrib-yuidoc
                        </code>
                    </td>
                    <td>
                        Generierung von Dokumentation unter Verwendung von YUIDoc
                        <a href="http://yui.github.io/yuidoc/"/>
                    </td>
                </tr>
                <tr>
                    <td>
                        <code>
                            grunt-mocha-test
                        </code>
                    </td>
                    <td>
                        Ausführen von auf mocha <a href="https://mochajs.org/"/> basierenden serverseitigen Unit-Tests.
                    </td>
                </tr>
            </table>

            <p>
                Je größer ein Projekt wird, desto größer wird mit der Zeit auch die Konfigurationsdatei für Grunt,
                weswegen kritische Stimmen Grunt daher auch als zu konfigurationslastig ansehen.
            </p>
        </chapter>

        <chapter id="automatisierung-gulp" title="Gulp">
            <p>
                Die etwas jüngere Alternative zu Grunt heißt Gulp <a href="http://gulpjs.com"/>. Konfiguriert wird Gulp
                wie Grunt über eine JavaScript-Konfigurationsdatei, allerdings mit dem Namen <code>gulpfile.js</code>.
                Gulp ist im Vergleich zu Grunt deutlich weniger konfigurationslastig und verfolgt insgesamt einen
                programmatischen Ansatz.
            </p>

            <tip>
                Hier zur Installationsanleitung: <a href="https://gulpjs.com/docs/en/getting-started/quick-start"/>
            </tip>
        </chapter>
    </chapter>

    <chapter id="testautomation" title="Quelltext automatisiert testen">
        <p>
            Je mehr Quelltext erstellt wird bzw. je komplexer der Quelltext ist, desto schwieriger und aufwendiger ist
            es, zu überprüfen, ob der Quelltext das macht, was er auch machen soll. Automatisierte Tests, insbesondere
            sogenannte Unit-Tests, können einem dabei helfen, Quelltext automatisch auszuführen und bestimmte Kriterien
            zu formulieren, die der getestete Quelltext erfüllen soll.
        </p>

        <tip>
            Das Prinzip von automatisierten Tests: <a href="swe-pk-testen.topic#automatisiert"/>
        </tip>

        <tip>
            Das Prinzip der testgetriebenen Entwicklung: <a href="swe-pk-testen.topic#tdd"/>
        </tip>

        <chapter id="testautomation-qunit" title="QUnit">
            <p>
                QUnit <a href="http://qunitjs.com"/> wurde ursprünglich von John Resig als Teil der jQuery-Bibliothek
                entwickelt und hatte hauptsächlich das Ziel, den internen Code von jQuery zu testen. Im Jahre 2008 wurde
                es dann ein eigenständiges Projekt – immer noch stark an jQuery gekoppelt, aber zumindest war es fortan
                möglich, eigenen, auf der jQuery-Bibliothek basierenden Code testen zu können. Ein Jahr später, im Jahre
                2009, wurden die Abhängigkeiten zu jQuery vollständig aufgelöst, sodass QUnit heute für das Testen
                beliebigen JavaScript-Codes einsetzbar ist.
            </p>

            <tip>
                Hier zur Installationsanleitung: <a href="https://qunitjs.com/intro/"/>
            </tip>
        </chapter>

        <chapter id="testautomation-mocha" title="mocha">
            <p>
                Bei mocha <a href="http://mochajs.org"/> handelt es sich um ein Testframework, welches sich unabhängig
                von der verwendeten Laufzeitumgebung einsetzen lässt.
            </p>

            <tip>
                Hier zur Installationsanleitung: <a href="https://mochajs.org/#installation"/>
            </tip>
        </chapter>
    </chapter>

    <chapter id="versionsverwaltung" title="Versionsverwaltung des Quelltextes">
        <p>
            Früher oder später muss man sich Gedanken darüber machen, wie der Quelltext in einer Form gespeichert wird,
            dass zum einen ein Backup vorhanden ist, und – wenn mit mehreren Entwicklern an einem Projekt gearbeitet
            wird – wie der Quelltext zwischen den Entwicklern auf einem aktuellen Stand gehalten und Änderungen des
            einen Entwicklers für die anderen sichtbar und zugreifbar gemacht werden. Kurz: Man muss sich Gedanken um
            die Versionsverwaltung machen. Allerdings muss man hier nicht das Rad neu erfinden: Es stehen verschiedene
            sogenannte Versionsverwaltungssysteme zur Verfügung, die genau die eben genannten Anforderungen erfüllen.
        </p>

        <p>
            Eines der bekanntesten Versionsverwaltungssysteme ist GIT.
        </p>

        <tip>
            Mehr zu Versionsverwaltungssysteme: <a href="swe-vcs.topic"/>
        </tip>

        <tip>
            Mehr zu GIT: <a href="swe-vcs-git.topic"/>
        </tip>
    </chapter>

    <chapter id="debugging" title="Den Code debuggen">

        <chapter id="debugging-console" title="Das »console«-Objekt">

        </chapter>

        <chapter id="debugging-breakpoints" title="Haltepunkte">

        </chapter>

        <chapter id="debugging-commandline" title="Mit der Kommandozeile arbeiten">

        </chapter>

        <chapter id="debugging-documentation" title="Dokumentationen fürs Debugging">

        </chapter>
    </chapter>

    <chapter id="quellen" title="Quellen">
        <tip>
            <b>(BUCH)</b>
            978-3836256971, "JavaScript", Philip Ackermann, 2019
        </tip>
        <tip>
            <b>(BUCH)</b>
            978-3836256872, "Professionell entwickeln mit JavaScrip", Philip Ackermann, 2018
        </tip>
        <tip>
            <b>(YOUTUBE)</b>
            <a href="https://www.youtube.com/watch?v=gTVpBbFWry8"/>, 2023-08-11 07:30
        </tip>
    </chapter>
</topic>