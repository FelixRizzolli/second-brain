<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
        SYSTEM "https://resources.jetbrains.com/writerside/1.0/xhtml-entities.dtd">
<topic xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="https://resources.jetbrains.com/writerside/1.0/topic.v2.xsd"
       title="Betriebssysteme" id="betriebssysteme">
    <show-structure for="chapter,procedure" depth="2"/>

    <chapter title="Was ist ein Betriebssystem?" id="was-ist-ein-betriebssystem">
        <p>
            Damit Anwendungsprogramme auf Computern laufen können, ist ein Betriebssystem erforderlich. Im Einzelnen
            erfüllen Betriebssysteme vor allem die folgenden Aufgaben:
        </p>
        <list>
            <li>
                <b>Prozessmanagement.</b> Die Ressourcen des Computersystems müssen zwischen den verschiedenen laufenden
                Programmen und Systemaufgaben verteilt werden. Zu diesem Zweck werden die einzelnen Aufgaben als
                sogenannte Prozesse ausgeführt, die vom Betriebssystem als übergeordnetem Steuerprozess verwaltet
                werden.
            </li>
            <li>
                <b>Speichermanagement.</b> Das Speichermanagement sorgt dafür, dass immer die gerade benötigten
                Speicherinhalte zur Verfügung stehen, ohne dass die Programmierer der Anwendungssoftware sich sonderlich
                darum kümmern müssten.
            </li>
            <li>
                <b>Steuerung und Abstraktion der Hardware.</b> Computersysteme sind hochgradig modular aufgebaut; jede
                Aufgabe kann durch viele verschiedene Geräte unterschiedlicher Hersteller erledigt werden.
                Betriebssysteme lösen dieses Problem durch den Einsatz der sogenannten Gerätetreiber, die die
                Steuerlogik für bestimmte Hardware enthalten. Vor dem Programmierer werden die konkreten Einzelheiten
                bestimmter Geräte verborgen, weil es vollkommen unzumutbar wäre, beim Schreiben eines
                Anwendungsprogramms auf die Besonderheiten Hunderter möglicher Geräte einzugehen.
            </li>
            <li>
                <b>Ein- und Ausgabesteuerung.</b> Betriebssysteme steuern die Zusammenarbeit mit vielen verschiedenen
                Ein- und Ausgabekanälen wie Tastatur und Bildschirm, Datenträgern oder Netzwerken.
            </li>
            <li>
                <b>Dateiverwaltung.</b> Die Logik der Dateiverwaltung wird in Form sogenannter Dateisysteme vom
                Betriebssystem zur Verfügung gestellt, damit alle Programme auf dieselbe Art und Weise darauf zugreifen.
            </li>
            <li>
                <p>
                    <b>Bereitstellen der Benutzeroberfläche.</b> Das Betriebssystem selbst und alle Programme müssen mit
                    dem Benutzer kommunizieren, um nach dessen Wünschen Aufgaben zu erledigen. Es existieren zwei Arten
                    von Benutzeroberflächen:
                </p>
                <list>
                    <li>
                        Die Konsole ermöglicht das dialogbasierte Arbeiten; Benutzer geben per Tastatur Befehle ein und
                        erhalten
                        Antworten.
                    </li>
                    <li>
                        Die grafische Benutzeroberfläche ermöglicht dagegen die intuitive Erledigung von Aufgaben über
                        das Aktivieren von Schaltflächen, Menüs und Symbolen mit der Maus.
                    </li>
                </list>
            </li>
        </list>
    </chapter>

    <chapter title="Entwicklung der Betriebssysteme" id="entwicklung-der-betriebssysteme">
        <p>
            Die allerersten Computersysteme der 40er- und 50er-Jahre des letzten Jahrhunderts wurden über Schalter und
            Steckverbindungen programmiert. Dem einzigen Programm, das zu einer bestimmten Zeit auf dem Computer lief,
            standen sämtliche Ressourcen ungeteilt zur Verfügung. Diese Ressourcen waren den Programmierern unmittelbar
            bekannt, es musste keine Abstraktion der Hardwareressourcen stattfinden. Solche Rechner besaßen überhaupt
            kein Betriebssystem.
        </p>
        <p>
            Als die Lochkarten Einzug in die Rechenzentren hielten, war es üblich, dass ein Programmierer dem Operator
            den mithilfe eines mechanischen Geräts gestanzten Kartenstapel übergab. Die Programmierer selbst bekamen den
            eigentlichen Computer möglicherweise nicht einmal zu Gesicht, weil nur die mit weißen Kitteln bekleideten
            Operatoren das »Allerheiligste« betreten durften. Der Operator war dafür verantwortlich, den Inhalt des
            Lochkartenstapels in den Computer einzulesen, und händigte dem Programmierer einen Stapel Endlospapier mit
            den Ergebnissen aus, falls das Programm keine Fehler enthielt.
        </p>
        <p>
            Erst in den 60er-Jahren wurden bestimmte häufig verwendete Programmteile oder Hilfsmittel wie Interpreter
            für höhere Programmiersprachen auf Magnetbändern statt auf Lochkarten abgespeichert. In der ersten Zeit
            waren wieder die Operatoren dafür zuständig, das richtige Band einzulesen, um die Programmlochkarten eines
            bestimmten Programmierers korrekt zu verarbeiten.
        </p>
        <p>
            Allmählich wurden übergeordnete Steuerprogramme eingeführt, die in der Lage waren, auf Lochkarten mit
            speziellen Metabefehlen zu reagieren, die nicht zum Programm selbst gehörten, sondern organisatorische
            Informationen enthielten. Auf diese Weise konnten einige der Aufgaben von Operatoren automatisiert werden,
            sodass die Steuerprogramme als Operating Systems bezeichnet wurden – noch heute das englische Wort für
            Betriebssystem. Diese allerersten Systeme ermöglichten die automatisierte Abarbeitung mehrerer
            Lochkartenstapel; diese Form der Verarbeitung wird deshalb als Stapelverarbeitung (Batch-Processing)
            bezeichnet. Dieses Verfahren kommt auch heute noch zum Einsatz, obwohl es sich längst nicht mehr um einen
            Stapel von Lochkarten, sondern um einen Stapel von Befehlen handelt.
        </p>
        <p>
            »Richtige« Betriebssysteme, wie sie bis heute verwendet werden, wurden allerdings erst eingeführt, als die
            Dialogverarbeitung entwickelt wurde. Seit Mitte der 60er-Jahre wurden immer mehr Rechenzentren mit Terminals
            ausgestattet. Ein Terminal (wegen seiner fehlenden eigenen Rechenfähigkeiten auch »dummes Terminal« – dumb
            terminal – genannt) ist eine Ein- und Ausgabeeinheit, die direkt am Arbeitsplatz eines Programmierers steht
            und mit dem eigentlichen Computer verbunden ist.
        </p>
        <p>
            Das Betriebssystem muss die Eingabe des Benutzers in den Computer transportieren und die Antwort des
            Computers an das Terminal zurückmelden. Die besondere Herausforderung für die Entwickler der frühen
            Betriebssysteme bestand darin, die Benutzer mehrerer Terminals zeitgleich zu bedienen. Die damaligen
            Computersysteme waren nämlich erheblich zu selten und zu teuer, um einem einzelnen Benutzer sämtliche
            Ressourcen zu überlassen.
        </p>
        <p>
            Aus dieser Anforderung entwickelte sich das sogenannte Timesharing-Verfahren, das die Anfragen mehrerer
            Benutzer scheinbar gleichzeitig verarbeitet, indem es die Rechenzeit in kleine Einheiten (Zeitscheiben,
            Time Slices) unterteilt und den Anforderungen der einzelnen Benutzer der Reihe nach zuweist. Aus diesem
            grundsätzlichen Prinzip entwickelte sich beispielsweise das moderne Multitasking, das die Ausführung
            mehrerer Programme auf demselben Rechner ermöglicht. Außerdem wurden allmählich Mechanismen eingeführt, um
            die Arbeit verschiedener Benutzer im Speicher des Rechners voneinander zu trennen. Die Grundlagen der
            Zugriffsrechte, der persönlichen Anmeldung und des Speicher- und Ressourcenmanagements wurden damit
            entwickelt.
        </p>
        <p>
            Die ersten Timesharing-Betriebssysteme wurden für einzelne Computer und ihre Anwender in Universitäten und
            anderen großen Institutionen hergestellt. Eines der wenigen frühen Beispiele, die relativ bekannt geworden
            sind, ist das am MIT (Massachusetts Institute of Technology) entwickelte ITS (Incompatible Timesharing
            System) – es wurde von Richard M. Stallman mitentwickelt, dem Begründer der Idee der freien Software. Einige
            der Fähigkeiten von ITS wurden später in Unix aufgenommen.
        </p>
        <p>
            Der erste Versuch, ein kommerzielles Timesharing-System zu schreiben, erfolgte Ende der 60er-Jahre: Die Bell
            Laboratories, das Entwicklungszentrum der US-Telefongesellschaft AT&amp;T, arbeiteten mit einigen anderen
            Firmen an einem System namens MULTICS. Die Idee war, viele Hundert Terminals an einem für damalige
            Verhältnisse recht mächtigen Rechner anzuschließen. Leider wurde MULTICS erst viel später fertiggestellt,
            als es kaum noch jemanden interessierte.
        </p>

        <chapter title="Die Geschichte von Unix" id="die-geschichte-von-unix">
            <p>
                Einige Ideen von MULTICS inspirierten jedoch Ken Thompson von den Bell Labs dazu, mit der Arbeit an
                einem eigenen Betriebssystem zu beginnen. Anfangs war es als Einzelplatzsystem geplant und wurde auf
                einem PDP-7-Kleincomputer von Digital Equipment (DEC) entwickelt, der, verglichen mit der für MULTICS
                verwendeten Maschine, nicht besonders leistungsfähig war. Thompson und sein späterer Mitstreiter Dennis
                Ritchie nannten ihr Betriebssystem in einer Anspielung auf MULTICS Unics; nach einiger Zeit wurde daraus
                Unix. Die ursprünglich nicht geplante Mehrbenutzerfähigkeit wurde übrigens sehr schnell nachgerüstet,
                nachdem die ersten Versionen von Unix gut funktionierten.
            </p>
            <p>
                Eines der wichtigsten Designmerkmale des Betriebssystems Unix ist seine Modularität: Jeder (als
                eigenständiges Programm realisierte) Befehl und jeder Bestandteil des Systems kann einzeln ausgetauscht
                werden, ohne das Gesamtsystem ändern zu müssen. Unix wurde zunächst in der Maschinensprache der PDP-7
                programmiert. Ab 1971 entwickelten Dennis Ritchie und Brian Kernighan dann die Programmiersprache C, in
                der Unix schließlich neu geschrieben wurde. Da C-Compiler bald für verschiedene Computersysteme
                verfügbar waren, fand Unix schnell Verbreitung.
            </p>
            <p>
                Eine kommerzielle Verbreitung von Unix war anfangs nicht möglich. Da AT&amp;T in den 70er-Jahren noch
                das US-Telekommunikationsmonopol innehatte, durfte das Unternehmen keine Geschäfte in anderen Branchen
                wie etwa dem Computerbereich tätigen. Deshalb wurden Lizenzen für den Unix-Quellcode unter sehr lockeren
                Bedingungen an Universitäten vergeben. Das ist der Grund, warum die Grundlagen des Betriebssystemaufbaus
                bis heute vornehmlich am Beispiel von Unix und seinen Nachfolgesystemen gelehrt werden.
            </p>
            <p>
                Die aktivste aller Universitäten, die den Unix-Quellcode erhielten, war die University of California in
                Berkeley. Die dortigen Programmierer erweiterten das ursprüngliche Unix und brachten schließlich eine
                eigene Version heraus, die Berkeley System Distribution (BSD). Als AT&amp;T schließlich in den
                80er-Jahren die Lizenz erhielt, Unix kommerziell zu vertreiben, hatten sich die AT&amp;T-Version,
                genannt System V, und die BSD bereits erheblich auseinanderentwickelt. Zudem wurde die Berkeley
                University verpflichtet, sämtliche Bestandteile des AT&amp;T-Unix aus der BSD zu entfernen.
            </p>
            <p>
                Seitdem ist jede kommerzielle und jede freie Unix-Version eine mehr oder weniger starke Mischung aus
                BSD- und System-V-Features. Allerdings haben System V und BSD wieder zahlreiche Fähigkeiten voneinander
                übernommen, sodass es nicht immer ganz leicht ist, sie auseinanderzuhalten.
            </p>
            <p>
                Heute existiert eine Vielzahl unterschiedlicher Unix-kompatibler Betriebssysteme. Dazu gehören oder
                gehörten kommerzielle Systeme wie Sun Solaris, IBM AIX, HP UX und freie Varianten wie etwa Linux oder
                FreeBSD. Eine Sonderstellung nimmt Apples Betriebssystem macOS (vormals Mac OS X, zwischenzeitlich nur
                OS X) ein: Es basiert auf einer Version der BSD, der Betriebssystemkern Darwin ist Open-Source-Software
                und läuft auf verschiedenen Plattformen. Die grafische Benutzeroberfläche Aqua ist dagegen eine
                kommerzielle Eigenproduktion von Apple und funktioniert nur auf Macs mit PowerPC-, Intel-Prozessoren
                oder den Hauseigenen ARM-Prozessoren.
            </p>
            <p>
                Die Mindestanforderung dessen, was ein Unix-System leisten muss, ist in einem Standard namens POSIX
                (Portable Operating System Interface)festgeschrieben. Allerdings werden von einem »richtigen« Unix heute
                auch einige weitere Quasi-standards verlangt, die nicht im POSIX-Standard festgelegt sind. Am
                wichtigsten ist dieser Standard für Programmierer. Möchte man als Programmierer ein Programm
                POSIX-konform schreiben, kann davon ausgegangen werden, dass es sich unter jeder beliebigen Unix-Version
                kompilieren lässt.
            </p>
            <p>
                Anfang der 90er-Jahre sah es übrigens bereits fast so aus, als würde Unix nicht mehr lange überleben:
                Die verschiedenen Varianten entwickelten sich zunehmend auseinander. Auf dem Desktop dominierte
                Microsoft Windows, während Server für die immer häufiger eingesetzten PC-Netzwerke vor allem unter
                Novell NetWare betrieben wurden.
            </p>
            <p>
                Zwei wichtige Umstände haben Unix gerettet und machen es heute, über 40 Jahre nach seiner Entwicklung,
                zu einem der gefragtesten Betriebssystemkonzepte: Der eine Grund ist die immense Ausbreitung des
                Internets, dessen wichtigste Konzepte unter Unix entwickelt wurden. Der zweite Anlass für die
                Verbreitung von Unix ist die Erfolgsgeschichte des freien Betriebssystems Linux, das 1991 von dem
                finnischen Informatikstudenten Linus Torvalds entwickelt wurde und inzwischen das Betriebssystem mit dem
                größten jährlichen Wachstum ist.
            </p>
        </chapter>

        <chapter title="PC-Betriebssysteme" id="pc-betriebssysteme">
            <p>
                Eine völlig andere Entwicklungslinie im Bereich der Betriebssysteme begann mit der Entwicklung der
                Personal Computer ab Mitte der 70er-Jahre. Auf das Timesharing und den Mehrbenutzerbetrieb wurde bei den
                ersten Versionen von PC-Betriebssystemen zugunsten der Performance-steigerung zunächst völlig
                verzichtet.
            </p>
            <p>
                Der erste weitverbreitete PC war der von Steve Wozniak und Steve Jobs 1977 entwickelte Apple II. Er
                erlaubte es, an einer wenig komfortablen Konsole BASIC- und Systembefehle einzutippen. Wurde einem
                Befehl eine Zeilennummer vorangestellt, dann wurde er Teil eines im Arbeitsspeicher abgelegten
                Programms, das beispielsweise mithilfe von RUN gestartet und über LIST auf dem Bildschirm angezeigt
                werden konnte. Befehle ohne Zeilennummer wurden dagegen unmittelbar ausgeführt.
            </p>
            <p>
                Dieses Konzept wurde in den 80er-Jahren von unzähligen Homecomputern wie dem Commodore C64, dem Atari
                800XL oder dem Sinclair ZX81 und ZX Spectrum nachgeahmt. Diese in das ROM eingebauten BASIC-Editoren und
                -Interpreter lassen sich allerdings nicht als vollwertige Betriebssysteme bezeichnen.
            </p>
            <p>
                Das erste »richtige« Betriebssystem für Personal Computer wurde von Gary Kildall entwickelt. Es hieß
                CP/M (Control Program for Microcomputers). Im Vergleich zu den bereits weit fortgeschrittenen
                Betriebssystemen für Großrechner und Kleincomputer war es ziemlich primitiv, hatte aber mehrere
                Vorteile: Es lief auf zwei verschiedenen, zu jener Zeit weitverbreiteten Prozessorplattformen, dem Intel
                8080 und dem Zilog Z80. Außerdem besaß es eine Dateiverwaltungsfunktion für Diskettenlaufwerke und
                konnte über verschiedene Konsolenbefehle gesteuert werden.
            </p>

            <chapter title="DOS und Windows" id="dos-und-windows">
                <p>
                    1981 kam dann der IBM-PC auf den Markt, der bald zum erfolgreichsten Personal Computer wurde. IBM
                    wollte ein CP/M-ähnliches Betriebssystem für diesen Rechner haben. Gary Kildall war jedoch nicht
                    bereit, IBMs Verschwiegenheitserklärungen zu unterschreiben. Deshalb wandte sich IBM an die junge
                    Firma Microsoft, die in Seattle arbeitete und Programmiersprachen-Pakete für verschiedene PCs
                    produzierte. Bill Gates, der die Firma 1975 mit seinem Schulfreund Paul Allen gegründet hatte, fand
                    bei einem Unternehmen namens Seattle Computer Products einen halb fertigen CP/M-Nachbau namens QDOS
                    – Quick and Dirty Operating System. Angeblich kaufte Bill Gates alle Rechte an diesem System für
                    50.000 US$. Microsoft verbesserte das System und lieferte es als MS-DOS (Microsoft Disk Operating
                    System) an IBM. Eine leicht modifizierte Fassung wurde unter dem Namen IBM PC DOS mit jedem IBM-PC
                    ausgeliefert. Die meisten später erschienenen kompatiblen Geräte enthielten dann ab Werk das
                    eigentliche MS-DOS. Auf diese Weise entstand das bis heute andauernde Kerngeschäft von Microsoft,
                    denn weltweit wird noch immer fast jeder neue PC mit einem Microsoft-Betriebssystem ausgeliefert.
                </p>
                <p>
                    CP/M, MS-DOS und einige andere Versuche besaßen allesamt nur eine Konsole, keine grafische
                    Benutzeroberfläche. Dabei war diese bereits ab 1963 als Designstudie von Douglas Engelbart
                    entwickelt worden. Im Forschungszentrum Xerox PARC wurde sie etwa Mitte der 70er-Jahre
                    fertiggestellt. Allerdings waren die Manager von Xerox nicht in der Lage, die Entwicklungen der
                    PARC-Forscher zu verstehen und zur Marktreife zu bringen. Erst Anfang der 80er-Jahre besichtigte
                    Steve Jobs von Apple das PARC und verliebte sich auf den ersten Blick in die grafische Oberfläche.
                    Daraufhin erschien im Jahr 1983 der teure Flop Apple Lisa; 1984 kam schließlich der Macintosh auf
                    den Markt. Beide waren mit Maus und grafischer Oberfläche ausgestattet.
                </p>
                <p>
                    Auf den IBM-PCs hielt die grafische Benutzeroberfläche erst Jahre später Einzug. Da der Macintosh
                    einen gewissen, wenn auch anfangs noch keinen überwältigenden Erfolg hatte, beschloss Bill Gates,
                    dass auch der PC ein Graphical User Interface (GUI) erhalten sollte. 1990 erschien schließlich die
                    erste brauchbare Version von Microsoft Windows; zunächst als grafischer Aufsatz für MS-DOS.
                </p>
                <p>
                    Ebenfalls im Jahr 1990 wurde der Prozessor Intel 80386 eingeführt. Es handelte sich um den ersten
                    32-Bit-Prozessor der Intel-Baureihe. Der IBM PC/AT und kompatible Geräte anderer Hersteller wurden
                    bald damit ausgestattet. Ärgerlicherweise war MS-DOS jedoch ein reines 16-Bit-Betriebssystem, das
                    bestimmte eingebaute Fähigkeiten des 386er wie Speicherschutz, Multitasking und die Adressierung von
                    mehr Arbeitsspeicher nicht nutzen konnte.
                </p>
                <p>
                    In dieser Situation wurde bei IBM ein neues Betriebssystem konzipiert. Das 32-Bit-System OS/2 sollte
                    zusammen mit dem neuartigen PC-System PS/2 verkauft werden. Dieses Computersystem sollte durch
                    patentierte, inkompatible Schnittstellen die Hersteller IBM-kompatibler PCs ausbooten. Die
                    Programmierung von OS/2 wurde zunächst in Zusammenarbeit mit Microsoft in Angriff genommen.
                    Schließlich gerieten die beiden Firmen jedoch in Streit, weil IBM Windows nicht unterstützen wollte
                    und voll auf OS/2 setzte. Letztlich setzte sich Windows als wichtigstes PC-Betriebssystem durch.
                    Dennoch besaß OS/2, dessen bisher letzte Version Warp 4 im Jahr 1996 erschien, einige hervorragende
                    Konzepte.
                </p>
                <p>
                    Microsoft blieb dagegen noch jahrelang bei DOS als Betriebssystem und Windows als grafischer
                    Erweiterung, wobei DOS jedoch allmählich zum Windows-Starter verkam und Windows – zumindest
                    teilweise – mit 32-Bit-Fähigkeiten ausgestattet wurde. Parallel entwickelte Microsoft ein völlig
                    neues Betriebssystem namens Windows NT (New Technology). Als Chefentwickler konnte Microsoft David
                    Cutler gewinnen, der das Betriebssystem VMS für die legendären VAX-Rechner von DEC entwickelt hatte.
                    1993 erschien die erste Version, die aufgrund der Windows-3.0-Benutzeroberfläche als Windows NT 3.0
                    bezeichnet wurde.
                </p>
                <p>
                    1995 kam Windows 95 auf den Markt, die Privatkunden-Version eines 32-Bit-Windows-Systems mit
                    modernisierter, stärker von Mac OS beeinflusster grafischer Oberfläche. Unter der Oberfläche war es
                    noch immer ein DOS-Betriebssystem, das die Windows-Umgebung startete. Allerdings waren die meisten
                    32-Bit-Errungenschaften nun auch in Windows 95 verfügbar, beispielsweise auch die sehnsüchtig
                    erwarteten langen Dateinamen. 1996 wurde Windows NT 4.0 vorgestellt, das die neue Oberfläche von
                    Windows 95 auch in der NT-Welt einführte.
                </p>
                <p>
                    Erst das 2001 eingeführte Windows XP brachte schließlich auch in der Privatkunden-Welt den Umstieg
                    auf NT-Technologie. Das System wurde in einer Home- und einer Professional-Version angeboten.
                </p>
                <p>
                    Zuvor waren noch zwei Nachfolger von Windows 95 namens Windows 98 und Windows Me (Millennium
                    Edition) erschienen; das ursprünglich Windows NT 5.0 genannte System kam 1999 als Windows 2000 auf
                    den Markt.
                </p>
                <p>
                    Anfang 2007 stellte Microsoft mit Windows Vista endlich den seit Langem entwickelten XP-Nachfolger
                    bereit. Das System wurde in sieben verschiedenen Versionen verkauft, vom minimalen Vista Home Basic
                    über mehrere Home- und Business-Varianten bis hin zum voll ausgestatteten Vista Ultimate.
                </p>
                <p>
                    Im Oktober 2009 erschien Windows 7, und 2012 wurde Windows 8 vorgestellt – beide ebenfalls in
                    verschiedenen Editionen. In Windows 8 wurde erstmals versucht, eine einheitliche Bedienoberfläche
                    für PCs, Tablets und Smartphones zu etablieren; unter anderem wurde der Desktop durch ein
                    erweitertes Startmenü mit konfigurierbaren rechteckigen Kacheln ersetzt. Viele Benutzer hielten
                    diesen ersten Versuch für nicht sonderlich gelungen, sodass das bald darauf erschienene Windows 8.1
                    einige der Änderungen wieder rückgängig machte: Genau wie bei Windows 10 wird hier nach dem Start
                    erst einmal wieder der klassische Desktop angezeigt, und eine durch die Windows-8-Kacheln erweiterte
                    Version des Startmenüs erscheint erst nach Klick auf die Start-Schaltfläche.
                </p>
            </chapter>

            <chapter title="Linux" id="linux">
                <p>
                    Der 386er-PC brachte nicht nur der Windows-Familie den Durchbruch, sondern war auch der Anlass für
                    Linus Torvalds, das Betriebssystem Linux zu entwickeln. Er war ein wenig enttäuscht von den
                    eingeschränkten Möglichkeiten des zu Lehrzwecken entwickelten abgespeckten Unix-Systems Minix und
                    wollte auf keinen Fall Windows benutzen. Aus diesem Grund begann er mit der Entwicklung seines
                    eigenen Systems.
                </p>
                <p>
                    Das Betriebssystem Linux ist ein voll ausgestattetes POSIX-konformes Unix-Betriebssystem, dessen
                    Kernel allerdings von seinem Erfinder Linus Torvalds vollkommen neu entwickelt wurde. Seit seiner
                    ursprünglichen Entwicklung im Jahr 1991 wurde der Linux-Kernel durch die Mitarbeit zahlloser
                    Freiwilliger immer weiter ausgebaut. Heute unterstützt er beinahe jede erdenkliche Hardware und
                    läuft nicht etwa nur auf der Intel-PC-Architektur, sondern wurde auf viele verschiedene Plattformen
                    portiert, beispielsweise PowerPC, Alpha, Sun SPARC oder diverse IBM-Großrechner. In Form von Google
                    Android läuft eine Variante auch auf zahllosen Smartphones und Tablets.
                </p>
                <p>
                    Selbstverständlich besteht ein Unix-System wie Linux aber nicht nur aus dem Kernel. Um damit
                    arbeiten zu können, wird eine Benutzeroberfläche in Form einer Shell oder eines grafischen Desktops
                    benötigt (alle aktuellen Linux-Distributionen bieten beides). Ein weiterer wichtiger Bestandteil
                    eines Unix-Systems sind die zahlreichen Systemprogramme. Die Linux-Versionen dieser Programme sind
                    kompatibel mit den entsprechenden Befehlen kommerzieller Unix-Versionen, entstammen aber
                    größtenteils dem GNU-Projekt (<a href="http://www.gnu.org">http://www.gnu.org</a>). Diese Abkürzung
                    steht für GNU’s Not Unix; es handelt sich um ein rekursives Akronym, in dem der erste Buchstabe
                    immer wieder für den Namen des Ganzen steht – eine beliebte Form der Unterhaltung in der Unix- und
                    Open-Source-Szene. Aus diesem Grund müsste ein vollständiges Linux-System aus Kernel und
                    Dienstprogrammen korrekterweise als GNU/Linux bezeichnet werden, aber daran hält sich nur die
                    Distribution Debian.
                </p>
                <p>
                    Das GNU-Projekt wurde 1984 von Richard Stallman ins Leben gerufen und setzte sich zum Ziel, freie
                    Versionen sämtlicher Unix-Systemprogramme zu entwickeln. Deshalb gründete Stallman gleichzeitig die
                    Free Software Foundation (FSF,<a href="http://www.fsf.org">http://www.fsf.org</a>). Als Linus
                    Torvalds mit der Arbeit an Linux begann, existierte bereits ein C-Compiler (der GNU C Compiler oder
                    GCC); auch die meisten Standardbefehle waren bereits verfügbar. Die meisten GNU-Varianten der
                    Unix-Programme sind inzwischen sogar leistungsfähiger als die ursprünglichen Versionen. Lediglich
                    der lange geplante GNU-Kernel Hurd ist bis heute nicht als finale Version erschienen, zumal er durch
                    die Entwicklung von Linux im Grunde überflüssig wurde.
                </p>
                <p>
                    Freie Software hat nicht nur etwas damit zu tun, dass die Programme kostenlos erhältlich sind,
                    sondern auch damit, dass man den Quellcode erhält und damit fast alles machen darf, was man möchte.
                    Deshalb lautet ein Motto der Free Software Foundation »Free software is a matter of liberty, not
                    price« (»Freie Software ist eine Frage der Freiheit, nicht des Preises«). Kommerzielle
                    Softwarelizenzen enthalten nämlich in der Regel eine Reihe von Einschränkungen und erlauben im
                    Grunde nichts weiter, als die Software für ihren offiziellen Anwendungszweck einzusetzen. Die FSF
                    hat dafür eine eigene Softwarelizenz ausgearbeitet, die vor allem verhindern soll, dass kommerzielle
                    Softwareentwickler freie Softwareprojekte an sich binden und die ursprüngliche Freiheit
                    beeinträchtigen. Unter dieser Lizenz, der GNU General Public License (GPL), wird übrigens auch Linux
                    selbst verbreitet.
                </p>
                <p>
                    Zu Beginn seiner Entstehung war Linux vor allem im Kreis der Entwickler verbreitet, die daran
                    arbeiteten. Es war schwierig, den Linux-Kernel zu installieren und die GNU-Versionen aller
                    erforderlichen Systemprogramme zu beschaffen und miteinander zu koordinieren. In den ersten Jahren
                    wurde Linux deshalb vornehmlich von Informatikern und interessierten Studenten weitergereicht, da
                    die Universitäten bereits über Internetanbindungen verfügten, als der Rest der Welt noch nichts
                    damit zu tun hatte.
                </p>
                <p>
                    Einige der Studenten, die mit Linux arbeiteten, begannen allmählich, den Kernel und die
                    Systemprogramme zusammenzustellen und Installationsprogramme für diese Betriebssystempakete zu
                    schreiben. Aus diesen ersten Bemühungen entstanden allmählich verschiedene Linux-Distributionen, die
                    anfangs auf Disketten, später auf CD-ROMs, noch später auf DVDs und in den letzten Jahren vorwiegend
                    als Download verbreitet wurden, oft zusammen mit mehr oder weniger ausführlichen gedruckten
                    Dokumentationen. Firmen wurden gegründet, die solche Distributionen erstellten und zu
                    vergleichsweise günstigen Preisen verkauften.
                </p>
                <p>
                    Der Kauf einer Distribution hat nichts mit dem Erwerb kommerzieller Software gemeinsam: die
                    Software, die man erhält, darf auf beliebig vielen Rechnern installieren und an allen Bekannten
                    weitergegeben werden. Die Distributoren erhalten das Geld nicht für die Software selbst oder für ein
                    Nutzungsrecht daran, sondern lediglich für ihre Arbeit an Installationsprogrammen und
                    Dokumentationen. Eine Distribution kann allerdings einzelne kommerzielle Programme enthalten, für
                    die andere Bedingungen gelten. Hierbei ist die Beschreibung, die der Distributor mitliefert, zu
                    beachten.
                </p>
                <p>
                    Heute ist eine Reihe verschiedener Distributionen erhältlich, die sich bezüglich ihres Umfangs,
                    ihres Anwendungsschwerpunkts und ihres Preises unterscheiden.
                </p>
            </chapter>
        </chapter>
    </chapter>

    <chapter title="Aufgaben und Konzepte" id="aufgaben-und-konzepte">
        <chapter title="Zusammengefasst: allgemeiner Aufbau von Betriebssystemen"
                 id="zusammengefasst-allgemeiner-aufbau-von-betriebssystemen">
            <p>
                Jedes Betriebssystem besitzt gewisse Grundbestandteile, denn alle Systeme müssen Computer verwalten, die
                bestimmte Gemeinsamkeiten aufweisen. Beinahe jedes neuere Betriebssystem besteht aus dem Kernel, den
                mehr oder weniger fest zu diesem gehörenden Gerätetreiber, den Systemprogrammen, einer Schnittstelle für
                Anwendungsprogramme und einer Benutzeroberfläche.
            </p>

            <chapter title="Der Kernel" id="der-kernel">
                <p>
                    Der Kernel (das englische Wort für Kern, beispielsweise ein Obstkern) ist das grundlegende
                    Computerprogramm, das unmittelbar auf dem Prozessor des Rechners ausgeführt wird. Er läuft bis zum
                    Herunterfahren des Systems permanent im Hintergrund und steuert alle anderen
                    Betriebssystemkomponenten sowie den Start und den Ablauf der Anwendungsprogramme. Der Kernel
                    initialisiert die Zusammenarbeit mit der Hardware, indem er die Treiber lädt und koordiniert. Aus
                    einer technischen Perspektive kann man sich vorstellen, dass der Kernel das einzige echte Programm
                    ist, das permanent ausgeführt wird, während alle anderen Programme, die später geladen werden, nur
                    Unterprogramme sind, die vom Kernel aufgerufen werden und die Kontrolle durch einen Rücksprung
                    wieder abgeben.
                </p>
                <p>
                    Es gibt unterschiedlich konzipierte Kernels. Das ältere Kernel-Konzept ist der sogenannte
                    monolithische Kernel, der so viele Funktionen wie möglich selbst ausführt. Moderner ist das Konzept
                    des Mikrokernels, der so wenig wie möglich selbst tut und die meisten Aufgaben an Prozesse
                    delegiert, die im Benutzermodus laufen wie gewöhnliche Anwendungsprogramme.
                </p>
                <p>
                    Da Mikrokernels kleine und elegante Programme sind und die einzelnen Teile des Betriebssystems nur
                    bei Bedarf im Speicher halten, müssten Betriebssysteme auf Mikrokernel-Basis theoretisch schneller
                    und effizienter laufen als Systeme mit monolithischen Kernels. Allerdings wird dabei oft vergessen,
                    dass der ständige Wechsel zwischen Benutzer- und Kernel-Modus Zeit und Ressourcen verbraucht.
                    Außerdem können auch monolithische Kernel inzwischen häufig von einem der entscheidenden Vorteile
                    des Mikrokernels profitieren: Die meisten Gerätetreiber sind modular, können also je nach Bedarf
                    geladen und wieder aus dem Speicher entfernt werden. Dies ist besonders wichtig für
                    hot-plugging-fähige Schnittstellen wie USB, FireWire oder Bluetooth.
                </p>
                <p>
                    Ein weiterer Fortschritt ist das Threading-Modell, das in immer mehr Betriebssystemen zum Einsatz
                    kommt. Die schwerfälligen Prozesse werden durch eine leichtgewichtige Alternative namens Threads
                    ergänzt, was die Arbeit des Kernels weiter beschleunigt.
                </p>
                <p>
                    Anfang der 90er-Jahre schienen die Mikrokernel sich allmählich durchzusetzen, es wurden um diese
                    Zeit kaum noch völlig neue Betriebssysteme auf der Basis eines monolithischen Kernels konzipiert.
                    Eine wichtige Ausnahme ist Linux – sein Kernel ist bis heute monolithisch, verwendet aber modulare
                    Gerätetreiber und inzwischen auch Threads. Andrew Tanenbaum, der Entwickler von Minix und Autor
                    mehrerer brillanter Fachbücher über Betriebssysteme und andere Informatikthemen, verfasste aus
                    diesem Grund in der Minix-Newsgroup einen berühmt gewordenen Beitrag mit dem Titel »Linux is
                    obsolete« (»Linux ist überholt«). Inzwischen gehört Linux allerdings zu denjenigen Systemen, die in
                    seinem Lehrbuch »Moderne Betriebssysteme« als Anschauungsbeispiele dienen.
                </p>
                <p>
                    Ein wichtiges Betriebssystem mit Mikrokernel, und zwar dem bekannten Mach-Mikrokernel, ist macOS.
                    Die meisten anderen Unix-Systeme besitzen dagegen wie Linux einen monolithischen Kernel. In gewisser
                    Weise lässt sich der Kernel von Windows NT und seinen Nachfolgern auch als Mikrokernel beschreiben.
                </p>
                <p>
                    Wenn ein Computer eingeschaltet wird, führt das BIOS des Rechners zunächst einige Überprüfungen
                    durch und übergibt die Kontrolle anschließend dem Bootloader eines Betriebssystems. Der Bootloader
                    ermöglicht entweder die Auswahl mehrerer Betriebssysteme, die auf den Datenträgern des Rechners
                    installiert sind, oder startet unmittelbar ein bestimmtes System. Das Booten (kurz für Bootstrapping
                    – »die Stiefel schnüren«) eines Betriebssystems bedeutet zunächst, dass der Kernel geladen und
                    ausgeführt wird. Dieser erledigt alle weiteren erforderlichen Aufgaben.
                </p>
                <p>
                    Wichtig ist es, die bei den meisten Betriebssystemen (insbesondere Unix und Windows) zu beobachtende
                    Trennung zwischen Kernelmodus und Benutzermodus zu verstehen. Ein Prozess, der im Kernelmodus läuft,
                    besitzt gewisse Privilegien, die im Benutzermodus nicht vorhanden sind. Bei den meisten Computern
                    werden für die beiden Modi unterschiedliche Betriebsmodi des Prozessors selbst verwendet.
                    Beispielsweise besitzen Intel-Prozessoren und damit kompatible Prozessoren seit dem 386er vier
                    verschiedene Modi, die sich durch einen unterschiedlich starken Schutz vor Interrupts, das heißt
                    Unterbrechungsanforderungen durch Hardware oder bestimmte Programmschritte, unterscheiden. Für
                    gewöhnlich wird der Modus mit dem stärksten Schutz als Kernelmodus und der mit dem geringsten als
                    Benutzermodus verwendet.
                </p>
                <p>
                    Prozesse im Kernelmodus erledigen wichtige Betriebssystemaufgaben, die nicht durch Prozesse im
                    Benutzermodus unterbrochen werden dürfen. Beispielsweise sorgen sie für die eigentliche Verarbeitung
                    von Hardware-Interrupts, das Öffnen und Schließen von Dateien oder die Speicherverwaltung. Auch wenn
                    ein Prozess im Kernelmodus nicht von außen unterbrochen werden kann, kann er freiwillig die
                    Kontrolle an einen anderen Prozess abgeben. In der Regel ruft er den Task Scheduler auf, der
                    ebenfalls im Kernelmodus läuft und für die Verteilung der Rechenzeit an die verschiedenen Prozesse
                    zuständig ist.
                </p>
                <p>
                    Ein Prozess im Benutzermodus kann jederzeit unterbrochen werden, etwa durch einen
                    Hardware-Interrupt, durch einen aufwachenden Kernelprozess oder dadurch, dass er selbst einen Befehl
                    aufruft, der nur im Kernel-Modus ausgeführt werden kann. Letzteres sind die sogenannten
                    Systemaufrufe (System Calls), die es Programmierern ermöglichen, die eingebauten Funktionen des
                    Betriebssystems zu nutzen.
                </p>
                <p>
                    Mikrokernel-basierte Betriebssysteme versuchen, so gut wie alle Aufgaben im Benutzermodus
                    auszuführen. Der Kernel selbst nimmt im Wesentlichen nur noch die Prozessverwaltung vor; selbst das
                    Speichermanagement und die Ein-/Ausgabekontrolle finden im Benutzermodus statt. Auf diese Weise kann
                    ein Mikrokernel-System zwar flexibler auf Anforderungen reagieren, muss dafür aber häufiger zwischen
                    Kernel- und Benutzermodus hin- und herschalten, was zusätzliche Performance kostet.
                </p>
                <p>
                    Windows NT und seine Nachfolger (einschließlich Vista, Windows 7, 8 und 10) verwenden einen
                    Mittelweg zwischen Mikrokernel-System und monolithischem Kernel-System: Gewisse Teile wurden aus dem
                    Kernel ausgelagert und bilden sogenannte Subsysteme, die im Benutzermodus laufen und verschiedene
                    Teilfunktionen anbieten, die kernelartige Aufgaben erledigen. Andere Teile des Betriebssystems
                    laufen dagegen im Kernel-Modus.
                </p>
                <p>
                    Es gibt in der Praxis keine Betriebssysteme mehr, die keine richtige Trennung zwischen Kernel- und
                    Benutzermodus durchführen. Die letzten waren MS-DOS in Kombination mit Windows 3.11, der letzten
                    Windows-Version, die kein vollständiges Betriebssystem war, und Mac OS bis zur Version 9 (das
                    aktuelle macOS ist dagegen eine völlige Neuentwicklung, die von dem UNIX-System NeXTSTEP abstammt).
                </p>
                <p>
                    Der auffälligste Unterschied zwischen einem modernen System und solchen altmodischen
                    Betriebssystemen besteht darin, dass Letztere nur das veraltete kooperative Multitasking verwenden –
                    ein Prozess entscheidet selbst, wann er die Kontrolle an das Betriebssystem zurückgeben möchte.
                    Stürzt ein Programm ab, das in einem solchen Prozess läuft, dann ist sehr wahrscheinlich das gesamte
                    Betriebssystem instabil geworden. Das in modernen Systemen eingesetzte präemptive Multitasking
                    entscheidet dagegen selbst, wie lange Prozesse im Benutzermodus die Rechenzeit behalten dürfen, und
                    entzieht ihnen diese bei Bedarf wieder.
                </p>
                <p>
                    Außerdem besitzen veraltete Betriebssysteme kein richtiges Speichermanagement; Prozesse können
                    gegenseitig auf ihre Speicherbereiche zugreifen und diese versehentlich überschreiben.
                </p>
            </chapter>

            <chapter title="Gerätetreiber" id="geraetetreiber">
                <p>
                    Die Gerätetreiber (Device Drivers) sind spezielle kleine Programme, die sich um die Steuerung
                    einzelner Hardwarekomponenten kümmern. In manchen Betriebssystemen sind Treiber ein fester
                    Bestandteil des Kernels, während sie in den meisten neueren Systemen als Module vorliegen, die sich
                    bei Bedarf laden und wieder aus dem Speicher entfernen lassen.
                </p>
                <p>
                    Es ist eine der schwierigsten Aufgaben für Programmierer, Gerätetreiber zu schreiben. Der Treiber
                    bildet die Schnittstelle zwischen Betriebssystem und Hardware. Er muss die allgemeinen Anforderungen
                    des Betriebssystems an eine bestimmte Geräteklasse in die spezifische Sequenz von Steuerbefehlen
                    umsetzen, die das Gerät eines bestimmten Herstellers versteht, und umgekehrt die Antworten des
                    Geräts wieder in eine allgemein verständliche Form bringen.
                </p>
                <p>
                    Aus der Sicht von Treibern lassen sich zwei grundsätzliche Arten von Geräten unterscheiden:
                    Zeichengeräte (Character Devices oder kurz Char Devices) tauschen Daten mit ihrer Umgebung als
                    sequenzielle Datenströme aus. Die Daten werden also Zeichen für Zeichen nacheinander ausgelesen.
                    Typische Beispiele sind die Tastatur, ein Drucker oder ein Bandlaufwerk. Blockgeräte (Block Devices)
                    stellen sich dagegen ähnlich dar wie der Arbeitsspeicher: Der Zugriff auf den Inhalt des Geräts kann
                    in beliebiger Reihenfolge blockweise erfolgen. Zu den Blockgeräten zählen vornehmlich die meisten
                    Laufwerke wie die Festplatte oder ein CD-ROM-Laufwerk, aber auch zum Beispiel Grafikkarten.
                </p>
                <p>
                    Damit ein Treiber für ein bestimmtes Gerät geschrieben werden kann, muss der Hersteller die
                    Schnittstellen dieses Geräts veröffentlichen. Einige Hersteller wollen dies nicht und bieten
                    stattdessen lieber selbst Treiber für die wichtigsten Betriebssysteme an. Bevor ein bestimmtes Gerät
                    angeschafft wird, muss also sichergestellt werden, dass ein Treiber fürs Betriebssystem verfügbar
                    ist.
                </p>
            </chapter>

            <chapter title="Systemprogramme" id="systemprogramme">
                <p>
                    Diejenigen Bestandteile des Betriebssystems, die nicht zum Kernel gehören, liegen in der Regel als
                    unabhängige Programme vor, die willkürlich geladen, ausgeführt und wieder beendet werden können. Bei
                    einem Betriebssystem mit Konsolen-Oberfläche muss man die Namen dieser Programme kennen, weil sie
                    durch Eingabe ihres Namens aufgerufen werden. In einer grafischen Benutzeroberfläche werden sie
                    dagegen hinter den Kulissen automatisch aufgerufen, wenn beispielsweise das Symbol des Programms per
                    Doppelklick ausgewählt wird.
                </p>
                <p>
                    Verschiedene Betriebssysteme verfügen über unterschiedlich mächtige Systemprogramme. Unix-Systeme
                    sind mit besonders leistungsfähigen Systemprogrammen ausgestattet, weshalb Unix-Benutzer häufiger
                    als die Anwender anderer Betriebssysteme die Konsole verwenden, obwohl auch Unix-Systeme inzwischen
                    mit sehr überzeugenden grafischen Oberflächen ausgestattet sind.
                </p>
                <p>
                    Bei einem Unix-System kann jede beliebige Verwaltungsaufgabe über die Konsole erledigt werden,
                    während unter Windows einige Werkzeuge nur unter der grafischen Oberfläche zur Verfügung stehen. Aus
                    diesem Grund können Unix-Rechner auch von fern über ein Netzwerk bedient werden. Die Konsole kann
                    über eine Terminal-Emulation zur Verfügung gestellt werden, ein Programm auf einem anderen Rechner
                    übernimmt also die Funktion eines Terminals. Das einzige System, bei dem Systemprogramme nicht ohne
                    Weiteres direkt aufgerufen werden konnten, weil es überhaupt keine Konsole besaß, war das veraltete
                    Mac OS bis einschließlich Version 9.
                </p>
                <p>
                    Typische Systemprogramme sind beispielsweise Befehle zur Manipulation von Dateien und
                    Verzeichnissen, etwa für das Umbenennen, Löschen oder Kopieren. Außerdem gehören allerlei
                    Steuerungs- und Analysewerkzeuge dazu.
                </p>
                <p>
                    Systemprogramme sind übrigens nicht zu verwechseln mit Systemaufrufen. Letztere werden von Prozessen
                    in Gang gesetzt, die auf Dienstleistungen des Kernels zugreifen müssen. Viele Systemprogramme
                    verwenden letztlich Systemaufrufe, um ihre Aufgabe zu erfüllen, aber nicht alle. Ebenso wenig
                    sollten Systemprogramme mit den einfachen Anwendungsprogrammen durcheinander gebracht werden, die
                    mit vielen Betriebssystemen geliefert werden. Ein einfacher Taschenrechner, ein Texteditor oder ein
                    MP3-Player ist kein Systemprogramm, sondern eine Anwendung.
                </p>
            </chapter>

            <chapter title="Die Schnittstelle für Anwendungsprogramme" id="die-schnittstelle-fuer-anwendungsprogramme">
                <p>
                    Jedes Betriebssystem bietet Anwendungsprogrammen die Möglichkeit, seine Dienstleistungen in Anspruch
                    zu nehmen. Dies ermöglicht es Programmierern, bestimmte aufwendige und hardwareabhängige Aufgaben an
                    das Betriebssystem zu delegieren. Bei den meisten aktuellen Systemen bleibt ihnen auch gar nichts
                    anderes übrig, weil der direkte Zugriff auf die Hardware durch Anwendungsprogramme verhindert wird.
                    Um eine Funktion des Betriebssystems zu verwenden, muss ein Programm einen Systemaufruf (System
                    Call) durchführen. Das Betriebssystem reagiert darauf, indem es den aktuellen Prozess unterbricht,
                    den geforderten Systembefehl im Kernelmodus ausführt und dessen Ergebnis an den aufrufenden Prozess
                    zurückliefert.
                </p>
                <p>
                    Unix-Systeme bieten nur verhältnismäßig wenige, dafür aber sehr mächtige Systemaufrufe an. Einige
                    von ihnen sind auf Dateien und andere Ein- und Ausgabekanäle bezogen, beispielsweise
                    <code>create()</code> zum Erzeugen einer neuen Datei,<code>open()</code> zum Öffnen,
                    <code>read()</code> zum Lesen, <code>write()</code> zum Schreiben oder<code>close()</code> zum
                    Schließen. Andere Systemaufrufe beschäftigen sich mit der Prozessverwaltung; zum Beispiel erzeugt
                    <code>fork()</code> einen neuen Prozess als Kopie des bestehenden, <code>kill()</code> sendet
                    Signale an Prozesse, und <code>shmget()</code> fordert das Shared Memory (gemeinsame
                    Speicherbereiche, die sich mehrere Prozesse zum Datenaustausch teilen) an.
                </p>
                <p>
                    Neben den eigentlichen Systemaufrufen basiert jedes Betriebssystem auf der Bibliothek der
                    Programmiersprache, in der es geschrieben wurde. Nach wie vor werden die meisten Betriebssysteme zu
                    großen Teilen in der Programmiersprache C geschrieben (nur einige sehr hardwarenahe Teile des
                    Kernels werden in Assembler verfasst). Aus diesem Grund basiert die Arbeitsweise vieler
                    Systembereiche auf Funktionen der C-Standardbibliothek. Unix, Windows und viele andere Systeme
                    behandeln vieles aus der Sicht von Anwendungsprogrammierern recht ähnlich, weil es mithilfe der
                    entsprechenden Bibliotheksroutinen realisiert wurde.
                </p>
                <p>
                    Ein Beispiel soll an dieser Stelle genügen, um einen Eindruck vom Einfluss der C-Standardbibliothek
                    zu geben: Fast alle Betriebssysteme speichern Datum und Uhrzeit als die Anzahl der Sekunden seit
                    dem <code>01. Januar 1970, 00:00 Uhr UTC</code>. Dieses Datum wird als <code>EPOCH</code>
                    bezeichnet, weil es als der »epochemachende« Erfindungszeitpunkt von Unix gilt. Diese Art der
                    Speicherung von Datum und Uhrzeit ist in der C-Bibliotheksdatei<code>time.h</code> definiert.
                </p>
                <p>
                    Unter Windows gibt es eine äußerst umfangreiche Betriebssystemschnittstelle, die Win32 API. Sie
                    besteht aus Tausenden von Befehlen, von denen allerdings nicht alle echte Systemaufrufe sind. Viele
                    von ihnen sind Bibliotheksfunktionen, die beispielsweise den Zugriff auf die Bestandteile der
                    grafischen Benutzeroberfläche ermöglichen. Win32 steht übrigens für 32-Bit-Windows, in Abgrenzung zu
                    dem längst untergegangenen 16-Bit-Windows, dessen letzte Version Windows 3.11 war. Alle
                    Privatkunden-Versionen seit Windows 95 und alle professionellen Versionen seit der ersten NT-Version
                    gehören zur Win32-Familie; Windows XP, Windows Vista, Windows 7, 8 und 10 sowie die zugehörigen
                    Server-Versionen sind auch in 64-Bit-Versionen für neuere Generationen der Intel- und
                    AMD-Prozessoren verfügbar.
                </p>
            </chapter>

            <chapter title="Die Benutzeroberfläche" id="die-benutzeroberflaeche">
                <p>
                    Es gibt zwei grundlegende Arten von Benutzeroberflächen: die Konsole oder Kommandozeile und die
                    grafische Oberfläche. Beide dienen dazu, mit dem Betriebssystem zu kommunizieren, und stellen ihre
                    Ein- und Ausgabefähigkeiten auch Anwendungsprogrammen zur Verfügung.
                </p>
                <p>
                    Eine Kommandozeilenoberfläche wird (in Abgrenzung zum Kernel) auch Shell genannt. Um zu ermitteln,
                    welche Befehle, von der Shell unterstützt werden, hält die, Windows-Konsole einen Befehl namens
                    <code>help</code> bereit, der eine Liste aller Befehle mit einer kurzen Beschreibung anzeigt.
                    <code>help BEFEHL</code> zeigt dagegen eine ausführliche Beschreibung eines einzelnen Befehls an.
                    Unter Unix heißt die entsprechende Anweisung <code>man BEFEHL</code>. Das hat übrigens nichts mit
                    dem dummen Klischee zu tun, dass Unix »nur was für Männer« sei – <code>man</code> ist einfach die
                    Abkürzung für Englisch: manual, also Handbuch.
                </p>
                <p>
                    Die unter Windows verwendete Konsole entspricht noch heute weitgehend der Benutzeroberfläche von
                    MS-DOS. Die Befehle, die eingegeben werden können, sind fast alle kompatibel mit den alten
                    DOS-Befehlen. Allerdings wurde inzwischen eine Reihe von Komfortfunktionen eingebaut, die die Arbeit
                    mit der Windows-Kommandozeile erleichtern.
                </p>
                <p>
                    Unix-Shells sind allerdings im Vergleich zur Windows-Shell erheblich komfortabler. Das liegt
                    natürlich zum Teil daran, dass die zugrunde liegenden Systembefehle, die aufgerufen werden können,
                    mächtiger sind als die Windows-Konsolenbefehle. Aber auch die Shell selbst hat mehr Bequemlichkeit
                    zu bieten als unter Windows. Beispielsweise wird unter Unix schon seit Langem die
                    Eingabevervollständigung angeboten – wenn Befehle oder Dateinamen eingegeben werden, kann die
                    Tabulator-Taste gedrückt werden, um einen begonnenen Namen zu ergänzen, falls er bereits eindeutig
                    ist. Microsoft hat dieses Feature erst unter Windows 2000 eingeführt.
                </p>
                <p>
                    Grafische Benutzeroberflächen gibt es inzwischen für jedes Betriebssystem, und auch unter Linux und
                    anderen Unix-Systemen ist es heutzutage üblich, dass gleich das GUI gestartet wird, wenn der Rechner
                    bootet. In einer grafischen Oberfläche werden die einzelnen Programme und Dokumente in Fenstern
                    dargestellt, die frei über den Bildschirm verschoben, vergrößert und verkleinert und in einer
                    beliebigen Stapelreihenfolge angeordnet werden können. Mit einer Maus wird ein Zeiger über diese
                    Oberfläche bewegt und es können Menübefehle ausgewählt, Schaltflächen angeklickt oder Symbole
                    verschoben werden.
                </p>
                <p>
                    Unter Linux kann eine von vielen verschiedenen grafischen Oberflächen ausgesucht werden. Die
                    grundlegenden Grafikfähigkeiten werden von einer Komponente namens XWindow-Server oder kurz X-Server
                    bereitgestellt, darauf aufbauend läuft ein Window-Manager oder ein moderner, voll ausgestatteter
                    Desktop. Die beiden häufigsten Desktops sind KDE und GNOME.
                </p>
                <p>
                    Windows und macOS lassen einem dagegen keine Wahl bei der Entscheidung für ein bestimmtes GUI, weil
                    es ein fester Bestandteil des Betriebssystems selbst ist. Selbst einige der elementarsten Programme
                    sind so geschrieben, dass sie diese eine Oberfläche voraussetzen. Beide Hersteller haben ihre
                    grafischen Oberflächen in der neuesten Version ihrer Betriebssysteme modernisiert; macOS verwendet
                    eine elegante Oberfläche namens Aqua, die Windows-10-Oberfläche (seit Windows 8 verfügbar) wird
                    Metro genannt.
                </p>
                <p>
                    Für macOS ist auch ein X-Server verfügbar, sodass der reichhaltige Bestand X-basierter Software, der
                    für andere Unix-Versionen vorhanden ist, bei Bedarf auch unter macOS zur Verfügung steht. Bis Mac
                    OS X 10.5 wurde die Software offiziell von Apple selbst angeboten und danach als Community Edition
                    weitergeführt. Unter
                    <a href="http://xquartz.macosforge.org/landing/">http://xquartz.macosforge.org/landing/</a> kann die
                    Software heruntergeladen werden. Auch für Windows gibt es übrigens verschiedene X-Server von
                    Drittanbietern.
                </p>
            </chapter>
        </chapter>

        <chapter title="Prozessverwaltung" id="prozessverwaltung">
            <p>
                Jedes moderne Betriebssystem ist in der Lage, scheinbar mehrere Aufgaben gleichzeitig auszuführen. Diese
                Fähigkeit wird allgemein als Multitasking bezeichnet. Es geht dabei nicht nur um den bequemen
                Nebeneffekt, dass mehrere Anwendungsprogramme geöffnet sein können und zwischen ihnen hin- und
                hergeschaltet werden kann, sondern vor allem um Aufgaben, die das Betriebssystem im Hintergrund
                erledigen muss, während nur eines dieser Programme verwendet wird.
            </p>
            <p>
                Jede der einzelnen gleichzeitig stattfindenden Aufgaben wird unter den meisten Betriebssystemen durch
                einen Prozess realisiert. Einem Prozess stehen aus seiner eigenen Sicht alle Ressourcen des Rechners
                exklusiv zur Verfügung: die gesamte ungeteilte Rechenzeit des Prozessors, der vollständige
                Arbeitsspeicher und der alleinige Zugriff auf sämtliche Ein- und Ausgabekanäle. Es ist Sache des
                Betriebssystems, die Ressourcen hinter den Kulissen zu verteilen. Ein Prozess, der auf eine Ressource
                wartet, muss in einen Wartezustand versetzt und später wieder aufgerufen werden.
            </p>
            <p>
                Dieser Service eines Betriebssystems erleichtert es Anwendungsprogrammierern, sich auf ihre eigentlichen
                Aufgaben zu konzentrieren. Wenn eine Bedingung eintritt, für die ein bestimmter Prozess nicht zuständig
                ist, übernimmt das System automatisch die Kontrolle, legt den Prozess schlafen, löst das anstehende
                Problem und ruft den Prozess anschließend wieder auf.
            </p>

            <chapter title="Das Unix-Prozessmodell" id="das-unix-prozessmodell">
                <p>
                    Besonders gut verständlich ist das Prozessverwaltungssystem von Unix. Für Unix-Prozesse gelten die
                    folgenden Aussagen:
                </p>

                <list>
                    <li>
                        Jeder Prozess ist durch eine eindeutige ganzzahlige Nummer gekennzeichnet, seine Prozess-ID
                        (PID).
                    </li>
                    <li>
                        Der erste Prozess, der auf dem Rechner gestartet wird, heißt <code>init</code>, hat die PID 1
                        und erzeugt alle anderen Prozesse direkt oder indirekt.
                    </li>
                    <li>
                        Jeder Prozess läuft entweder im Kernelmodus oder im Benutzermodus, und zwar ein für alle Mal.
                        Keiner kann den Modus nachträglich wechseln. Ein Anwendungsprogramm kann niemals selbst einen
                        Prozess starten, der im Kernelmodus läuft – dafür gibt es Systemaufrufe.
                    </li>
                    <li>
                        Ein neuer Prozess wird durch einen speziellen Systemaufruf namens <code>fork()</code> erzeugt.
                        Dieser Systemaufruf erzeugt eine identische Kopie des Prozesses, der ihn gestartet hat – der
                        neue Prozess kann sich sogar daran »erinnern«, <code>fork()</code> aufgerufen zu haben.
                        Lediglich die PID ist eine andere. In der Regel wird der neue Prozess anschließend für eine neue
                        Aufgabe eingesetzt.
                    </li>
                    <li>
                        Jeder Prozess besitzt einen Parent-Prozess. Dabei handelt es sich um denjenigen Prozess, der ihn
                        aufgerufen hat. Wenn der Parent-Prozess vor dem Child-Prozess beendet wird, wird das Child dem
                        Ur-Prozess <code>init</code>zugewiesen. Auf diese Weise wird sichergestellt, dass Prozesse auch
                        weiterhin einen Parent-Prozess besitzen.
                    </li>
                    <li>
                        Wird ein Child-Prozess dagegen beendet, wird er nicht komplett aus dem Speicher und aus der
                        Prozesstabelle entfernt, sondern bleibt mit dem speziellen Status <code>defunct</code> (außer
                        Betrieb) als sogenannter Zombie-Prozess bestehen. In diesem Zustand bleiben die Zombies, bis der
                        Parent-Prozess den Systemaufruf<code>waitpid()</code> durchführt; dies wird als Reaping (Ernte)
                        bezeichnet. Auf diese Weise kann der Parent den Exit-Status seiner Child-Prozesse untersuchen.
                    </li>
                    <li>
                        Jeder Prozess reagiert auf eine Reihe verschiedener Signale. Diese Signale sind durchnummeriert,
                        in der Praxis werden jedoch symbolische Namen für diese Signale verwendet, die irgendwo in der
                        Betriebssystembibliothek definiert sind. Signale werden mithilfe des Systemaufrufs
                        <code>kill()</code> an einen Prozess gesandt. Der etwas seltsame Name rührt daher, dass das
                        Standardsignal den Prozess auffordert, sich zu beenden, falls kein anderes Signal angegeben
                        wird. Wichtige Signale sind etwa folgende: <code>SIGTERM</code> beendet den Prozess normal,
                        <code>SIGKILL</code> erzwingt einen sofortigen Abbruch, <code>SIGHUP</code> (Hangup) weist
                        darauf hin, dass eine Verbindung unterbrochen wurde (etwa eine Netzwerkverbindung), und
                        <code>SIGALRM</code> zeigt an, dass ein Timer-Alarm ausgelöst wurde, den Programmierer wiederum
                        verwenden können, um einen Prozess nach einer definierten Zeit wieder zu wecken.
                    </li>
                    <li>
                        Ein Prozess kann jederzeit selbst die Kontrolle abgeben, indem er den Systemaufruf
                        <code>pause()</code> durchführt. In diesem Fall kann er durch ein Signal wieder geweckt werden.
                    </li>
                    <li>
                        Prozesse im Benutzermodus können auch von außen unterbrochen und später wieder aufgenommen
                        werden.
                    </li>
                </list>

                <p>
                    Wenn ein Prozess unterbrochen wird, muss der Systemzustand, der derzeit herrscht, gespeichert
                    werden, um ihn bei Wiederaufnahme erneut herzustellen. Dazu gehören vor allem die Inhalte der
                    Prozessorregister und der Flags sowie eine Liste aller geöffneten Dateien. Wenn ein Prozess
                    weiterläuft, findet er die Systemumgebung also genau so vor, wie er sie verlassen hat.
                </p>
                <p>
                    Neben der Prozess-ID besitzt jeder Prozess in einem Unix-System eine User-ID (UID) und eine Group-ID
                    (GID). Diese beiden Informationen sind für die Systemsicherheit wichtig: Die User-ID kennzeichnet
                    den Benutzer, dem der Prozess gehört, die Group-ID die Benutzergruppe. Ein Benutzer ist entweder
                    eine bestimmte Person oder eine vom Betriebssystem definierte Einheit; einer Gruppe können beliebig
                    viele Benutzer angehören. Ein Prozess reagiert nur auf Signale, die von einem anderen Prozess mit
                    derselben UID und GID aus versandt wurden. Die einzige Ausnahme sind die UID und GID 0, die dem
                    Superuser root vorbehalten sind. Dieser spezielle Benutzer darf auf einem Unix-System alles, also
                    auch jeden Prozess beenden, unterbrechen oder anderweitig steuern.
                </p>
                <p>
                    Mithilfe des Befehls ps kann auf einer Unix-Konsole angezeigt werden, welche Prozesse gerade laufen.
                    Angezeigt werden die PID, die UID, die GID und der Pfad des Prozesses. Der Pfad ist die genaue
                    Ortsangabe der Programmdatei, die in dem entsprechenden Prozess ausgeführt wird.
                </p>
                <p>
                    Windows verwendet ein etwas komplexeres Prozessmodell. Vor allem wird ein neuer Prozess durch einen
                    Systemaufruf namens<code>CreateProcess()</code> erzeugt, der keine exakte Kopie des aufrufenden
                    Prozesses erzeugt, sondern einen »leeren« Prozess, dem anschließend eine Aufgabe zugewiesen werden
                    muss. Außerdem ist jeder Prozess im Benutzermodus mit einer numerischen Priorität ausgestattet.
                    Diese entscheidet im Zweifelsfall, welcher Prozess Vorrang hat. Die Liste der laufenden Prozesse
                    wird auf der Registerkarte Prozesse des Task-Managers angezeigt. Hier besteht auch die Möglichkeit,
                    abgestürzte Prozesse zwangsweise zu beenden.
                </p>
                <p>
                    Prozesse haben den Vorteil, dass sie vollkommen voneinander abgeschirmt laufen können: Sie besitzen
                    getrennte Speicherbereiche und können einander nicht in die Quere kommen. Manchmal kann dieser
                    Vorteil jedoch auch ein Nachteil sein, denn mitunter müssen Prozesse miteinander kommunizieren. Eine
                    einfache, aber auf wenige »Wörter« beschränkte Möglichkeit ist die bereits erwähnte Verwendung von
                    Signalen.
                </p>
                <p>
                    Eine andere Option besteht in der Verwendung sogenannter Pipes, die die Ausgabe eines Programms und
                    damit eines Prozesses mit der Eingabe eines anderen verknüpfen. Pipes werden in den Konsolen von
                    Unix und Windows häufig eingesetzt, um die Ausgabe eines Programms durch ein anderes zu filtern,
                    können aber auch aus Programmen heraus geöffnet werden.
                </p>
                <p>
                    Die effizienteste Möglichkeit der Kommunikation zwischen Prozessen heißt Inter Process Communication
                    oder System V IPC. Obwohl sie mit System V eingeführt wurde und nicht zum POSIX-Standard gehört, ist
                    sie inzwischen in fast allen Unix-Varianten verfügbar, zum Beispiel auch unter Linux. Im
                    Wesentlichen verwendet die IPC zwei verschiedene Mechanismen: In sogenannte
                    Nachrichtenwarteschlangen (Message Queues) kann ein Prozess schreiben; ein anderer kann sequenziell
                    daraus lesen. Gemeinsame Speicherbereiche (Shared Memory) sind dagegen einfacher zu handhaben: Was
                    ein Prozess in diesem Speicherbereich ablegt, können andere beliebig oft lesen oder ändern.
                </p>
                <p>
                    Eine eingeschränkte Form der Verständigung zwischen Prozessen findet schließlich durch Semaphore
                    statt. Dabei handelt es sich im Grunde um einen Zähler in einem gemeinsamen Speicherbereich, der von
                    verschiedenen Prozessen reserviert beziehungsweise freigegeben werden kann. Beim Reservieren wird
                    der Zähler um 1 heruntergezählt, sofern er noch größer als 0 ist, beim Freigeben wird 1 bis zu einem
                    festgelegten Maximalwert addiert. So können mehrere Prozesse beispielsweise eine beschränkte Anzahl
                    von Ressourcen gemeinsam nutzen.
                </p>
            </chapter>

            <chapter title="Deadlocks" id="deadlocks">
                <p>
                    Eines der Probleme, die bei der Verwendung mehrerer Prozesse auftreten können, ist eine Situation,
                    in der mehrere Prozesse im Wartezustand gefangen bleiben, weil sie aufeinander oder auf dieselben
                    Ressourcen gewartet haben. Das Wettrennen um den Zugriff auf Ressourcen wird als Race Condition
                    bezeichnet. Zu einem Deadlock (Verklemmung) kommt es, wenn eine solche Race Condition unentschieden
                    ausgeht. Beispielsweise könnten zwei Prozesse in einen Deadlock geraten, weil sie den Zugriff auf
                    ein und dieselbe Datei zu sperren versuchen, um anderweitige Änderungen dieser Datei zu verhindern.
                    Ein Deadlock führt mindestens zum Absturz der betroffenen Prozesse, möglicherweise sogar zum Absturz
                    des gesamten Systems.
                </p>
                <p>
                    Ein gutes Betriebssystemdesign vermeidet Deadlocks durch eine Reihe von Verfahren. Insbesondere
                    reicht das normale Verfahren zum Sperren von Ressourcen nicht immer aus, um Deadlocks zu vermeiden.
                    Das gewöhnliche Sperren einer Datei oder einer Hardwareressource überprüft zunächst, ob die
                    Ressource nicht anderweitig gesperrt ist. Falls sie gesperrt ist, wird der Prozess blockiert und
                    wartet, bis die andere Sperre gelöst ist. Anschließend sperrt der aktuelle Prozess selbst die
                    Ressource, sodass andere Prozesse, die sie ihrerseits sperren möchten, wiederum warten müssen.
                </p>
                <p>
                    Anstelle dieses Modells sollte eine mehrstufige Anmeldung für die Verwendung von Ressourcen
                    eingesetzt werden:
                </p>

                <list>
                    <li>
                        Ein Prozess, der eine bestimmte Ressource benötigt, versucht nicht einfach, eine Sperre für
                        diese Ressource zu errichten, sondern überprüft zunächst, ob sie nicht bereits gesperrt ist.
                        Falls doch, gibt er die Kontrolle ab, um nicht aktiv auf das Ende der Sperre warten zu müssen,
                        was Ressourcen kosten würde. Er sollte nach einer gewissen Zeit erneut überprüfen, ob die
                        Ressource noch gesperrt ist.
                    </li>
                    <li>
                        Wenn die Ressource frei ist, errichtet der Prozess eine Sperre, die andere Prozesse daran
                        hindert, diese Ressource zu verwenden.
                    </li>
                    <li>
                        Nachdem der Prozess die Ressource nicht mehr benötigt, löst er die Sperre und gibt die Ressource
                        dadurch wieder frei.
                    </li>
                </list>
            </chapter>

            <chapter title="Threads" id="threads">
                <p>
                    Einige Prozesse müssen gemeinsam dasselbe Problem bearbeiten und ununterbrochen miteinander
                    kommunizieren. Dies gilt insbesondere für Prozesse, die nebeneinander im gleichen Anwendungsprogramm
                    laufen. IPC oder andere Methoden der Prozesskommunikation sind zwar möglich, verschwenden aber auf
                    die Dauer Systemressourcen. Interessanter ist eine Prozessvariante, bei der sich mehrere Abläufe von
                    vornherein dieselben Ressourcen teilen.
                </p>
                <p>
                    Zu diesem Zweck werden in vielen Betriebssystemen die leichtgewichtigen und schnell zu wechselnden
                    Threads verwendet. Diese besitzen innerhalb desselben übergeordneten Prozesses keine voneinander
                    getrennten Speicherbereiche, sondern greifen auf dieselbe Stelle des Speichers zu. Windows
                    unterstützt Threads bereits seit den ersten Versionen von Windows NT, in Unix-Systemen wurden sie
                    erst später eingeführt. Zuletzt wurden sie unter Linux nachgerüstet; seit dem Kernel 2.4 können sie
                    als stabil bezeichnet werden.
                </p>
                <p>
                    Threads übernehmen häufig Aufgaben, die parallel innerhalb desselben Programms ausgeführt werden
                    müssen. Besonders anschaulich lässt sich dies anhand eines in Echtzeit laufenden 3D-Computerspiels
                    erläutern: Eingaben zur Steuerung der eigenen Spielfigur müssen gleichzeitig entgegengenommen
                    werden, die Umgebung muss ständig neu gezeichnet werden, und es müssen permanente Zustandskontrollen
                    stattfinden. Es wäre für einen Programmierer ein Ärgernis, wenn er sich selbst Gedanken darüber
                    machen müsste, in welcher Reihenfolge die einzelnen Schritte wann stattfinden sollen. Werden die
                    verschiedenen Aufgaben dagegen in Threads verpackt, führt der Prozessor sie abwechselnd in kurzen
                    Zeitintervallen aus.
                </p>
            </chapter>
        </chapter>

        <chapter title="Speicherverwaltung" id="speicherverwaltung">
            <p>
                Eine der wichtigsten Aufgaben eines Betriebssystems besteht in der Verwaltung des fast immer zu kleinen
                Arbeitsspeichers. So gut wie alle aktuellen Betriebssysteme verwenden eine echte virtuelle
                Speicheradressierung, bei der die von den Programmen angesprochenen Speicheradressen nicht identisch mit
                den Hardwareadressen des RAM-Speichers sein müssen.
            </p>
            <p>
                Genau wie Gerätetreiber und Prozessmanagement entbindet das Speichermanagement einen Programmierer von
                einer recht frustrierenden Aufgabe, nämlich von der Verteilung des Arbeitsspeichers an die einzelnen
                Prozesse beziehungsweise Programme. Da eine richtig funktionierende Speicherverwaltung jedem Programm
                vorgaukelt, ihm stünde der gesamte Arbeitsspeicher zur Verfügung, muss man sich beim Programmieren nicht
                mehr viele Sorgen machen, ob der Arbeitsspeicher reicht.
            </p>
            <p>
                In der Regel wird der virtuelle Speicherraum vom Betriebssystem in sogenannte Segmente unterteilt. Bei
                modernen Computersystemen beherrscht bereits der Prozessor selbst die Speichersegmentierung und kann
                dadurch mehr Speicher adressieren, als im physikalischen RAM zur Verfügung steht. Zu diesem Zweck
                enthalten aktuelle Prozessoren ein Bauteil namens Memory Management Unit (MMU). Spricht ein Programm
                eine bestimmte Speicheradresse an, dann nimmt die MMU sie entgegen und rechnet sie in die aktuell
                zugeordnete physikalische Speicheradresse um.
            </p>
            <p>
                Aus der Sicht des Speichermanagements im Betriebssystem wird der Speicher in einzelne Seiten unterteilt,
                die durch das sogenannte Paging auf die Festplatte ausgelagert werden, wenn ein Programm sie gerade
                nicht benötigt, und in den Arbeitsspeicher zurückgeholt werden, wenn es sie wieder braucht. Die Datei,
                in der sich die ausgelagerten Speicherseiten befinden, wird als Auslagerungsdatei (Page File)
                bezeichnet. Unix-Systeme verwenden häufig keine einzelne Datei dafür, sondern eine Plattenpartition
                eines speziellen Typs, die als Swap-Partition bezeichnet wird.
            </p>
            <p>
                Die MMU unterhält zu diesem Zweck eine Seitentabelle, die zu jedem Zeitpunkt darüber Auskunft gibt,
                welche virtuelle Speicherseite sich gerade wo befindet, sei es im Arbeitsspeicher oder in der
                Auslagerungsdatei. Dass eine Speicherseite benötigt wird, die zurzeit ausgelagert ist, wird dabei durch
                einen Page Fault (Seitenfehler) zum Ausdruck gebracht.
            </p>
            <p>
                Da das Speichermanagement auf den Fähigkeiten der zugrunde liegenden Hardware aufbaut, funktioniert es
                unter Windows und Linux, sofern sie auf Intel-Rechnern oder Kompatiblen laufen, recht ähnlich. Auf einem
                solchen x86-System ist eine Speicheradresse 32 Bit lang – es handelt sich schließlich um einen
                32-Bit-Prozessor. Allerdings werden nicht einfach die verfügbaren physikalischen Speicheradressen
                durchnummeriert. Stattdessen ist die Adresse in drei Bereiche unterteilt:
            </p>

            <list>
                <li>
                    Die zehn obersten Bits (31 bis 22) geben den Eintrag im Page Directory (Seitenverzeichnis) an,
                    verweisen also auf eine Adresse in einem Speicherbereich, der eine Liste von Seitentabellen enthält.
                </li>
                <li>
                    Die nächsten zehn Bits (21 bis 12) enthalten die Nummer des Eintrags in der genannten Page Table
                    (Seitentabelle). Dieser Eintrag verweist auf eine einzelne Speicherseite.
                </li>
                <li>
                    Die letzten zwölf Bits (11 bis 0) geben schließlich den Offset an, also das konkrete Byte innerhalb
                    der Speicherseite. Dies führt dazu, dass eine Speicherseite eine Größe von 212 oder 4.096 Byte
                    besitzt.
                </li>
            </list>

            <img src="hardware_speichermanagement.png" alt="Hardware Speichermanagement" width="600"/>

            <p>
                Auf diese Struktur der Hardware baut die Speicherverwaltung des Betriebssystems auf. Jedes Programm kann
                dynamisch mehr Speicher anfordern und erhält ihn, indem zurzeit nicht benötigte Speicherseiten
                ausgelagert werden. Es kommt daher bei einem modernen System nicht oft vor, dass eine Anwendung wegen
                Speichermangels abgebrochen werden muss oder gar nicht erst startet. Allerdings wird ein Rechner, der zu
                wenig physikalischen Arbeitsspeicher besitzt, zu langsam, weil er mehr mit dem Paging beschäftigt ist
                als mit der eigentlichen Arbeit.
            </p>
            <p>
                Da es inzwischen mehr 64- als 32-Bit-Architekturen gibt und sich dies bereits seit Jahren abzeichnete,
                wurde auch die Speicherverwaltung entsprechend angepasst. Beispielsweise verwendet Linux schon seit
                Kernel 2.2 intern ein dreistufiges Paging-Modell: Das Page Directory zeigt nicht gleich auf eine Page
                Table, sondern zunächst auf ein weiteres Verzeichnis, genannt Middle Directory. Da unter
                32-Bit-Architekturen keine Verwendung dafür besteht, wird der Middle-Directory-Eintrag im Page Directory
                dadurch stillgelegt, dass er immer den Wert 0 besitzt, also immer auf dasselbe vermeintliche Middle
                Directory zeigt. Da praktisch alle Linux-Versionen auf 64-Bit-Prozessoren laufen beziehungsweise in
                entsprechenden Versionen verfügbar sind, ermöglicht dieses Vorgehen die Verwendung desselben
                Speicherverwaltungsmodells für alle Linux-Versionen.
            </p>
        </chapter>

        <chapter title="Dateisysteme" id="dateisysteme">
            <p>
                Eine der wichtigsten Aufgaben eines Betriebssystems ist die Verwaltung von Dateien. Eine Datei ist eine
                benannte Einheit, die auf einem Datenträger gespeichert wird. Die meisten Betriebssysteme sprechen nicht
                direkt die Hardwaresektoren eines Datenträgers an, sondern unterteilen den Datenträger logisch in
                größere Abschnitte, die als Zuordnungseinheiten (Cluster) bezeichnet werden. Dies hat den Vorteil, dass
                das System sich nicht weiter um die tatsächliche Größe des Datenträgers kümmern muss.
            </p>
            <p>
                Ein gewisser Nachteil besteht dagegen darin, dass jede Datei mindestens eine ganze Zuordnungseinheit
                belegt und dass eine neue belegt wird, wenn die Datei auch nur um ein Byte zu groß ist – das Verfahren
                ist vergleichbar mit einem Parkhaus, in dem für »angefangene Stunden« bezahlt werden muss: 61 Minuten
                werden dort bereits als zwei Stunden gewertet. Einige moderne Dateisysteme wie das Linux-eigene ext3
                oder ext4 speichern die »überstehenden« Stücke von Dateien, die keine ganze Zuordnungseinheit mehr
                füllen, deshalb zusammen in einer gemeinsamen Zuordnungseinheit.
            </p>
            <p>
                Die unterschiedlichen Betriebssysteme verwenden verschiedene Modelle, um Daten auf einem Datenträger
                abzulegen. Ein solches Modell wird als Dateisystem bezeichnet. Da die meisten Betriebssysteme mit
                mehreren Dateisystemen umgehen können, verwenden sie eine zweistufige Dateiverwaltung: Das eigentliche
                Dateisystem greift auf den Treiber für das Laufwerk zu und organisiert die Daten auf dem eigentlichen
                Datenträger, während ein virtuelles Dateisystem den Zugriff des Betriebssystems auf die verschiedenen
                tatsächlichen Dateisysteme und Datenträgerarten vereinheitlicht. Unter Unix geht die Abstraktion von
                Dateien so weit, dass selbst der Zugriff auf Geräte über Special Files (Spezialdateien) oder
                Gerätedateien erfolgt, die normalerweise im Verzeichnis <code>/dev</code> liegen.
            </p>
            <p>
                Als Benutzer eines Betriebssystems wird man vornehmlich mit dem virtuellen Dateisystem konfrontiert.
                Hier wird vor allem geklärt, wie die einzelnen Datenträger und Partitionen angesprochen werden, wie
                Verzeichnisse organisiert sind, welche Zeichen in Dateinamen erlaubt sind, wie lang diese Namen sein
                dürfen etc.
            </p>
            <p>
                Das virtuelle Dateisystem, das alle Unix-Systeme miteinander gemeinsam haben, unterstützt außerdem
                verschiedene Sicherheitsaspekte, insbesondere die Zugriffsrechte für einzelne Benutzer und Gruppen.
                Windows bietet ähnliche Fähigkeiten, allerdings nur für das Dateisystem NTFS.
            </p>

            <note>
                <p><b>»Verzeichnis« oder »Ordner«?</b></p>
                <p>
                    Die symbolische Darstellung (das Icon) eines Verzeichnisses auf dem Desktop des GUIs eine Aktenmappe
                    (englisch: folder) zeigt, was in den deutschen Versionen als Ordner lokalisiert wurde. In
                    Wirklichkeit sind im Dateisystem immer Verzeichnisse (englisch: directories) zu finden. Sie sind die
                    Ordnungs- und Organisationseinheiten des Dateisystems.
                </p>
            </note>

            <chapter title="Das virtuelle Unix-Dateisystem" id="das-virtuelle-unix-dateisystem">
                <p>
                    Die in diesem Buch näher besprochenen Unix-Systeme Linux und macOS haben mit allen anderen
                    Unix-Systemen dasselbe virtuelle Dateisystem gemeinsam. Konkrete Dateisysteme gibt es unter Unix
                    dagegen unzählige. Beispielsweise unterstützt macOS das klassische Apple-Dateisystem HFS+, das
                    Unix-Dateisystem UFS, das CD-ROM-Dateisystem ISO 9660 und andere, während Linux mit seinem eigenen
                    Dateisystem ext3 oder ext4, btrfs, den Windows-Dateisystemen FAT und NTFS sowie mit weiteren
                    zusammenarbeitet.
                </p>
                <p>
                    Die Gemeinsamkeiten der Unix-Dateisysteme betreffen die Art und Weise, wie Dateien, Verzeichnisse
                    und Datenträger organisiert sind. Außerdem sind die Zugriffsrechte für alle unter Unix unterstützten
                    Dateisysteme verfügbar.
                </p>
                <p>
                    Auf einem Unix-Rechner existiert nur ein einziger Verzeichnisbaum, unabhängig davon, auf wie viele
                    konkrete Datenträger er verteilt ist. Die Wurzel des gesamten Baums wird als / bezeichnet. Unterhalb
                    dieses obersten Verzeichnisses liegen einzelne Dateien und Unterverzeichnisse; jedes von ihnen kann
                    wiederum in Unterverzeichnisse unterteilt sein.
                </p>
                <p>
                    Die meisten Verzeichnisse, die direkt unterhalb der Wurzel des Unix-Dateisystems liegen, haben
                    spezielle Aufgaben, die in allen gängigen Unix-Systemen identisch oder zumindest ähnlich sind:
                </p>

                <table>
                    <tr>
                        <td>Verzeichnis</td>
                        <td>Bedeutung</td>
                    </tr>
                    <tr>
                        <td><code>bin</code></td>
                        <td>
                            (binaries) enthält die Systemprogramme.
                        </td>
                    </tr>
                    <tr>
                        <td><code>sbin</code></td>
                        <td>
                            (start binaries) enthält Initialisierungsprogramme, die beim Systemstart aufgerufen werden.
                        </td>
                    </tr>
                    <tr>
                        <td><code>dev</code></td>
                        <td>
                            (devices) enthält Gerätedateien, also Dateien, die auf die einzelnen Hardwarekomponenten
                            verweisen. Der Vorteil dieser Methode ist, dass sich der Zugriff auf Geräte genau wie bei
                            einzelnen Dateien über Benutzerrechte regeln lässt.
                        </td>
                    </tr>
                    <tr>
                        <td><code>usr</code></td>
                        <td>
                            (user) enthält die wichtigsten Anwendungsprogramme.
                        </td>
                    </tr>
                    <tr>
                        <td><code>opt</code></td>
                        <td>
                            (optional) enthält zusätzliche Anwendungen, die nicht ganz so häufig benötigt werden.
                        </td>
                    </tr>
                    <tr>
                        <td><code>etc</code></td>
                        <td>
                            enthält allerlei Konfigurationsdateien.
                        </td>
                    </tr>
                    <tr>
                        <td><code>var</code></td>
                        <td>
                            enthält variable Daten, vor allen Dingen Log-Dateien, in die Systemmeldungen eingetragen
                            werden.
                        </td>
                    </tr>
                    <tr>
                        <td><code>home</code></td>
                        <td>
                            enthält für jeden Benutzer, der im System angemeldet ist, ein Home-Verzeichnis. Hier werden
                            alle Anwendungsdaten dieses Benutzers abgelegt. Zusätzlich werden die persönlichen
                            Einstellungen dieses Benutzers für die verschiedenen Anwendungs- und Systemprogramme
                            gespeichert. Unter macOS heißt dieses Verzeichnis übrigens Users.
                        </td>
                    </tr>
                    <tr>
                        <td><code>root</code></td>
                        <td>
                            ist das spezielle Home-Verzeichnis des Superusers. Es liegt nicht im Verzeichnis home wie
                            die anderen Benutzerverzeichnisse. home könnte nämlich so eingerichtet werden, dass es auf
                            einem anderen physikalischen Datenträger oder einer anderen Partition liegt als der Rest des
                            Betriebssystems. Möglicherweise steht es also nicht zur Verfügung, wenn ein Fehler auftritt,
                            den root beheben muss.
                        </td>
                    </tr>
                </table>

                <p>
                    Der Pfad zu einer Datei wird von der Wurzel aus angegeben, indem die Namen der entsprechenden Ordner
                    jeweils durch einen Slash voneinander getrennt werden. Die folgende Pfadangabe wäre beispielsweise
                    der Pfad einer Datei in meinem Home-Verzeichnis:
                    <code>/home/felixrizzolli/fachinformatiker/betriebssysteme.txt</code>.
                </p>
                <p>
                    Da jedes Programm ein Arbeitsverzeichnis besitzt, in dem es mit der Suche nach Dateien beginnt, kann
                    ein Pfad auch relativ angegeben werden, also vom aktuellen Verzeichnis aus. Angenommen, eine
                    Anwendung hat das Arbeitsverzeichnis <code>/home/user</code> und möchte auf die Datei
                    <code>info.txt</code> in <code>/home/felixrizzolli</code> zugreifen. Der Pfad dieser Datei kann
                    entweder absolut als <code>/home/felixrizzolli/info.txt</code> oder relativ (von
                    <code>/home/user</code> aus) als <code>../felixrizzolli/info.txt</code> angegeben werden. Die Angabe
                    <code>..</code>spricht jeweils das übergeordnete Verzeichnis an; untergeordnete Verzeichnisse werden
                    einfach mit ihrem Namen angegeben.
                </p>
                <p>
                    »Geschwister«-Verzeichnisse, also nebengeordnete – in diesem Fall <code>user</code> und
                    <code>felixrizzolli</code> –, können einander nie direkt ansprechen, sondern müssen mithilfe von
                    <code>..</code>-Angaben so weit nach oben wandern, bis ein gemeinsamer Vorfahr gefunden wurde. Im
                    Falle von user und <code>felixrizzolli</code> muss man nicht weit nach oben gehen; <code>home</code>
                    ist bereits der Elternordner beider.
                </p>
                <p>
                    Eine Abkürzung für das Home-Verzeichnis des aktuell angemeldeten Benutzers ist die Tilde
                    (<code>~</code>). Es kann durch Angabe der Tilde von überall aus ins Home-Verzeichnis gewechselt
                    werden. Auf dem PC wird eine Tilde übrigens mithilfe der Tastenkombination (Alt_Gr) + (+) erzeugt,
                    auf dem Mac muss zunächst (Alt) + (N) und anschließend die Leertaste gedrückt werden: Das Zeichen
                    funktioniert wie ein Akzent und kann auf ein n gesetzt werden.
                </p>
                <p>
                    Im Übrigen sollte bedenkt werden, dass Unix bei Datei- und Verzeichnisnamen zwischen Groß- und
                    Kleinschreibung unterscheidet. Die Namen <code>hallo.txt</code>, <code>Hallo.Txt</code> und
                    <code>HALLO.TXT</code> bezeichnen drei verschiedene Dateien, die alle im gleichen Verzeichnis liegen
                    könnten. Aus Gründen der Kompatibilität mit alten Macintosh-Anwendungen ist dies ein wichtiger
                    Unterschied zwischen macOS und anderen Unix-Varianten: Auf HFS+-Partitionen unterscheidet macOS
                    nicht zwischen Groß- und Kleinschreibung, auf UFS-Partitionen dagegen schon.
                </p>
                <p>
                    Ein Dateiname, der mit einem Punkt (<code>.</code>) beginnt, wird in der normalen Verzeichnisansicht
                    standardmäßig ausgeblendet (versteckt). Ein wirkliches Verstecken ist auf diese Weise nicht möglich;
                    effektiver ist die Verwendung von Zugriffsrechten.
                </p>
                <p>
                    Intern werden Dateien auf dem Datenträger nicht durch ihren Namen dargestellt, sondern durch eine
                    ganzzahlige Nummer namens <code>inode</code>. Die Einträge in einem Verzeichnis sind Verweise auf
                    solche <code>inodes</code>. Interessanterweise können mehrere Verzeichniseinträge auf dieselbe
                    <code>inode</code> zeigen. Ein Verzeichniseintrag wird deshalb auch als Hard Link bezeichnet, der
                    fest auf eine bestimmte <code>inode</code> verweist. Eine Datei wird auf einem Unix-System erst
                    gelöscht, wenn alle Einträge im Verzeichnisbaum entfernt wurden, die auf die entsprechende
                    <code>inode</code> zeigen.
                </p>
                <p>
                    Im Gegensatz zu den Hard Links werden auch symbolische Links oder Symlinks unterstützt, die nicht
                    direkt auf eine <code>inode</code> zeigen, sondern auf einen anderen Verzeichniseintrag. Anders als
                    die Hard Links können Symlinks auch auf Verzeichnisse verweisen sowie auf Dateien, die auf einem
                    anderen physikalischen Datenträger liegen.
                </p>
                <p>
                    Die verschiedenen Datenträger und Partitionen können übrigens an einer beliebigen Stelle im
                    Verzeichnisbaum eingehängt werden. Dieser Vorgang wird als Mounten bezeichnet. Solange ein
                    Datenträger nicht gemountet ist, können die Verzeichnisse und Dateien, die darauf liegen, nicht
                    angesprochen werden. Das Mounten geschieht entweder manuell durch Eingabe des Kommandos
                    <code>mount</code> oder aber automatisch beim Booten durch einen Eintrag in eine
                    Konfigurationsdatei.
                </p>
                <p>
                    Eine weitere wichtige Eigenschaft der Dateien unter Unix sind die Benutzerrechte. Jede Datei gehört
                    einem bestimmten Benutzer und einer bestimmten Gruppe (berechtigte Benutzer können diese
                    Besitzverhältnisse ändern). Da ein Benutzer beliebig vielen Gruppen angehören kann, lassen sich die
                    Rechte an bestimmten Dateien sehr effizient über das Gruppenzugriffsrecht ändern.
                </p>
                <p>
                    Der Verzeichniseintrag einer Datei enthält die Zugriffsrechte für den Besitzer, für die Gruppe und
                    für alle anderen Benutzer. Die drei möglichen Zugriffsrechte sind Lesen (<code>r</code> für read),
                    Schreiben (<code>w</code> für write) und Ausführen (<code>x</code> für execute). Ein typischer
                    Verzeichniseintrag enthält beispielsweise die folgende Angabe von Zugriffsrechten:
                    <code>-rwxr-xr-x</code>
                </p>
                <p>
                    Die erste Stelle gibt den Dateityp an: <code>–</code> für eine gewöhnliche Datei, <code>d</code>
                    für ein Verzeichnis oder <code>l</code> für einen Symlink. Die neun folgenden Informationen zeigen
                    in Dreiergruppen die Zugriffsrechte an – drei Stellen für den Eigentümer, drei für die Gruppe und
                    drei für alle anderen Benutzer. Ein Buchstabe steht dafür, dass ein Zugriffsrecht gewährt wird, ein
                    Strich bedeutet, dass es nicht gewährt wird. Im vorliegenden Fall darf der Eigentümer die Datei
                    lesen, schreiben (dazu gehören auch Löschen und Umbenennen) und ausführen. Die Gruppe und der Rest
                    der Welt dürfen nur lesen und ausführen. Das Recht der Ausführung ist nur für Programme und für
                    Verzeichnisse sinnvoll (Letztere lassen sich ansonsten nicht als Arbeitsverzeichnis auswählen).
                </p>
                <p>
                    Intern werden die Zugriffsrechte als dreistellige Oktalzahl gespeichert. Die erste Stelle enthält
                    die Benutzerrechte des Eigentümers, die zweite die der Gruppe und die dritte die der anderen
                    Benutzer. Der Wert jeder Stelle ist die Summe aus den gewährten Benutzerrechten: <code>4</code>
                    steht für Lesen, <code>2</code> für Schreiben und <code>1</code> für Ausführen. Das Zugriffsrecht
                    <code>rwxr-xr-x</code> lässt sich also als <code>0755</code> darstellen (die vorangestellte
                    <code>0</code> steht für eine Oktalzahl). Eine einfache Textdatei könnte dagegen beispielsweise die
                    Zugriffsrechte <code>0640</code> aufweisen, was <code>rw-r-----</code> entspricht – der Eigentümer
                    darf die Datei lesen und schreiben, die Gruppe darf sie lesen, und alle anderen dürfen gar nichts.
                </p>
            </chapter>

            <chapter title="Das virtuelle Windows-Dateisystem" id="das-virtuelle-windows-dateisystem">
                <p>
                    Windows-Dateisysteme unterscheiden sich durch mehrere Merkmale von Unix-Dateisystemen. Insbesondere
                    ist auffallend, dass es keine gemeinsame Wurzel für alle Dateisysteme gibt, sondern dass jeder
                    Datenträger beziehungsweise jede Partition einen eigenen Verzeichnisbaum bildet. Die einzelnen
                    Partitionen werden durch Laufwerksbuchstaben bezeichnet; die automatisch gewählte Reihenfolge
                    gehorcht traditionell einigen seltsamen Regeln:
                </p>

                <list>
                    <li>
                        <code>A</code>: ist das erste Diskettenlaufwerk, das es kaum noch gibt.
                    </li>
                    <li>
                        <code>B</code>: ist das zweite Diskettenlaufwerk, das erst recht kein Mensch mehr einsetzt.
                    </li>
                    <li>
                        <code>C</code>: ist die erste Partition auf der ersten physikalischen Platte (bei einem
                        EIDE-System der Primary Master).
                    </li>
                    <li>
                        <code>D</code>: ist die erste Partition auf der zweiten physikalischen Platte (dem Primary
                        Slave). Falls das zweite EIDE-Gerät ein CD-ROM- oder DVD-Laufwerk ist, bekommt es einen höheren
                        Buchstaben, und es geht zunächst mit den anderen Festplatten weiter.
                    </li>
                    <li>
                        Die weiteren Buchstaben werden jeweils der ersten Partition der folgenden Platten zugewiesen,
                        falls weitere vorhanden sind.
                    </li>
                    <li>
                        Nun folgen Platte für Platte sämtliche restlichen Partitionen.
                    </li>
                    <li>
                        Als Nächstes werden die CD-ROM- und DVD-Laufwerke in ihrer eigenen Anschlussreihenfolge
                        berücksichtigt.
                    </li>
                    <li>
                        Wenn Netzwerkressourcen als virtuelle Laufwerke eingebunden werden, ist der Laufwerksbuchstabe
                        frei wählbar, sofern er nicht bereits belegt ist.
                    </li>
                </list>

                <p>
                    Windows-Versionen ab Vista bezeichnen dagegen automatisch die Partition, auf der sich das
                    Betriebssystem befindet, als<code>C:</code>. Auch andere Abweichungen von der genannten Reihenfolge
                    sind möglich, beispielsweise dann, wenn nachträglich die Partitionierung geändert oder ein
                    zusätzliches Laufwerk eingebaut wird. Unter Windows 10 und früheren Systemen der Windows-NT-Familie
                    können Sie die Zuordnung ohnehin mithilfe der Datenträgerverwaltung (Verwaltung • Computerverwaltung
                    • Datenträgerverwaltung) ändern. Bei den Privatkunden-Versionen bis Windows Me war die freie Wahl
                    der Laufwerksreihenfolge dagegen nur eingeschränkt möglich.
                </p>
                <p>
                    Pfade werden unter Windows so ähnlich angegeben wie bei Unix. Das Trennzeichen zwischen den
                    Verzeichnisnamen sowie zwischen Verzeichnis und Datei ist allerdings der Backslash (<code>\</code>),
                    der umgekehrte Schrägstrich. Die Wurzel innerhalb eines bestimmten Laufwerks ist ein einzelner
                    Backslash, während ein vollständiger absoluter Pfad mit dem Laufwerksbuchstaben beginnt. Das jeweils
                    übergeordnete Verzeichnis wird auch unter Windows durch zwei Punkte (<code>..</code>) angegeben.
                </p>
                <p>
                    Hier sieht man einen Auszug aus einem Windows-Verzeichnisbaum einer Festplatte mit dem
                    Laufwerksbuchstaben <code>D:</code>
                </p>

                <code-block>
                    [D:]
                    |
                    +-- [dokumente]
                    |
                    +-- [fachinfo8]
                    | |
                    | +-- betriebssysteme.doc
                    |
                    +-- [sonstige]
                </code-block>

                <p>
                    Soll die Datei betriebssysteme.doc absolut angesprochen werden, muss der vollständige Pfad
                    <code>D:\dokumente\fachinfo8\betriebssysteme.doc</code> angegeben werden. Befindet man sich dagegen
                    bereits auf Laufwerk <code>D:</code>, und zwar in einem beliebigen Verzeichnis, kann auch
                    <code>\dokumente\fachinfo8\betriebssysteme.doc</code> geschrieben werden. Ein relativer Zugriff aus
                    dem Verzeichnis sonstige auf betriebssysteme.doc erfolgt über
                    <code>..\fachinfo8\betriebssysteme.doc</code>.
                </p>
                <p>
                    Das Konzept des Home-Verzeichnisses wird unter Windows bei Weitem nicht so konsequent verfolgt wie
                    in Unix-Systemen. Zwar existiert unter Windows Vista auf der Systempartition ein Verzeichnis namens
                    Users (in deutschen XP-Versionen heißt es dagegen Dokumente und Einstellungen), das für jeden
                    Benutzer ein Unterverzeichnis enthält. In diesem Verzeichnis befindet sich beispielsweise das
                    Unterverzeichnis Eigene Dateien, in dem standardmäßig die Dateien gespeichert werden sollten, die
                    der Benutzer in Anwendungsprogrammen anlegt. Konfigurationsdaten werden dagegen nicht an dieser
                    Stelle abgespeichert – die meisten befinden sich ohnehin nicht in Dateien, sondern in der
                    Windows-Registry, die im nächsten Kapitel behandelt wird.
                </p>
                <p>
                    Zwar unterstützen nicht alle Windows-Dateisysteme die Verwaltung von Benutzerrechten, aber für jede
                    Datei können vier verschiedene Attribute eingestellt werden: Das Attribut <code>r</code> steht für
                    read only, also schreibgeschützt; <code>s</code> bezeichnet Systemdateien, die einen noch stärkeren
                    Schutz genießen als schreibgeschützte. <code>h</code> oder hidden ist das Attribut für versteckte
                    Dateien, die in der normalen Windows-Grundkonfiguration nicht angezeigt werden. <code>a</code>
                    schließlich ist das Archivattribut, das immer dann gesetzt wird, wenn die Datei seit dem letzten
                    Systemstart geändert wurde. Archivieren muss man also nur diejenigen Dateien, bei denen
                    <code>a</code> gesetzt ist.
                </p>
                <p>
                    Dateinamen können unter Windows bis zu <code>255</code> Zeichen lang sein; zwischen Groß- und
                    Kleinschreibung wird nicht unterschieden. Allerdings werden die Dateien genau mit der Groß- und
                    Kleinbuchstabenkombination gespeichert, die angegeben wurden. Eine Reihe von Zeichen ist in
                    Dateinamen nicht zulässig, vor allem <code>:</code>, <code>\</code>,<code>/</code>, <code>?</code>,
                    <code>*</code>, <code>&lt;</code>, <code>&gt;</code> und <code>|</code>. Alle diese Zeichen besitzen
                    in Pfadangaben oder auf der Windows-Konsole besondere Bedeutungen.
                </p>
                <p>
                    Ein wesentlicher Bestandteil des Dateinamens ist unter Windows die Dateierweiterung oder -endung
                    (Extension). Dieses Anhängsel, das durch einen Punkt vom restlichen Dateinamen getrennt wird und
                    traditionell drei Buchstaben lang war, zeigt nämlich den Dateityp an: Wird unter Windows auf ein
                    Datei-Icon doppelt geklickt, wird die Datei mit demjenigen Programm geöffnet, mit dem diese Endung
                    verknüpft ist. Beispielsweise bezeichnet die Erweiterung <code>.txt</code> eine einfache Textdatei,
                    <code>.jpg</code> ist eine Bilddatei im JPEG-Format, und <code>.exe</code> kennzeichnet ein
                    ausführbares Programm.
                </p>
                <p>
                    Unglücklicherweise wird die Dateiendung in allen Windows-Versionen seit Windows 95 standardmäßig
                    ausgeblendet, obwohl sie im Grunde ein normaler Bestandteil des Dateinamens ist. Dateitypen können
                    also nur noch an den mehr oder weniger aussagefähigen Datei-Icons erkennt werden. Dies lässt sich
                    allerdings in den Ordneroptionen ändern und sollte eine der ersten Handlungen nach Inbetriebnahme
                    einer neuen Windows-Installation sein.
                </p>
                <p>
                    Bei alten Windows-Versionen bis 3.11 waren Dateinamen auf acht Zeichen für den eigentlichen Namen
                    und drei Zeichen für die Erweiterung begrenzt. Aus Gründen der Kompatibilität erzeugte Windows
                    hinter den Kulissen noch lange Zeit für jeden Dateinamen, der länger ist, einen passenden Kurznamen.
                    Dieser besteht aus folgenden Bestandteilen: den ersten fünf bis sechs Zeichen des eigentlichen
                    Namens ohne Leerzeichen, einer Tilde und einer Nummer (um den Fall abzudecken, dass mehrere Dateien
                    im gleichen Verzeichnis denselben Kurznamen erhalten würden) sowie der auf drei Zeichen gekürzten
                    Erweiterung. Aus <code>Der Name ist zu lang.doc</code> wurde nach diesem Schema
                    <code>DERNAM~1.DOC</code>.
                </p>
            </chapter>
        </chapter>
    </chapter>

    <chapter title="Quellen" id="quellen">
        <tip>
            <b>(BUCH)</b>
            978-3836254663, IT-Handbuch für Fachinformatiker, Sascha Kersken, Rheinwerk Verlag GmbH, 2017
        </tip>
    </chapter>
</topic>