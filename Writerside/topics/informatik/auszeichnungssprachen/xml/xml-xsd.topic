<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
        SYSTEM "https://resources.jetbrains.com/writerside/1.0/xhtml-entities.dtd">
<topic xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="https://resources.jetbrains.com/writerside/1.0/topic.v2.xsd"
       title="XML - XSD (XML Schema Definition)" id="xml-xsd">
    <show-structure for="chapter,procedure" depth="2"/>

    <chapter title="Grundlegendes zu XML Schema Definition" id="grundlagen">
        <p>
            Ein XML Schema Definition ist eine alternative Möglichkeit zur Definition von Standards für XML-Dokumente
            und wird mit der Dateiendung <path>.xsd</path> gespeichert. Gegenüber DTDs besitzt dieses Format vor allem
            folgende Vorteile:
        </p>

        <list>
            <li>
                Die zulässigen Inhalte für Elemente und Attribute können wesentlich genauer angegeben werden.
            </li>
            <li>
                Das Format ist selbst XML-basiert, verwendet also keine separate Syntax wie DTDs, sondern besteht aus
                wohlgeformten XML-Dokumenten und kann mittels <a href="xml-dom.topic">XML DOM</a> manipuliert oder
                mittels <a href="xml-xslt.topic">XSLT</a> transformiert werden.
            </li>
            <li>
                XML Schemas unterstützen Datentypen.
            </li>
        </list>

        <p>
            Grundsätzlich wird jedes Element mithilfe einer <code>&lt;xs:element&gt;</code>-Deklaration angegeben.
            Elemente, die nur einfachen Textinhalt und keine verschachtelten Elemente oder Attribute besitzen, benötigen
            im Schema das Attribut <code>type</code>, das den zulässigen Typ des Inhalts angibt. Einige zulässige Typen
            sind <code>"xs:string"</code> für beliebigen Text, <code>"xs:integer"</code> für ganze Zahlen oder
            <code>"xs:language"</code> für eine ISO-Sprachangabe wie <code>en</code> (Englisch) oder <code>de</code>
            (Deutsch). Diese und andere Inhaltstypen können sowohl für Elemente als auch für Attribute verwendet werden.
        </p>
        <p>
            Elemente, die verschachtelte Elemente, gemischten Inhalt oder Attribute enthalten dürfen, benötigen zur
            Angabe dieser Komponenten einen <code>&lt;xs:complexType&gt;</code>-Block. Für verschachtelte Elemente steht
            innerhalb dieses Blocks entweder ein einzelnes Element, eine durch einen
            <code>&lt;xs:sequence&gt;</code>-Abschnitt umschlossene Liste aufeinanderfolgender Elemente oder eine durch
            <code>&lt;xs:choice&gt;</code> umhüllte Aufzählung von Alternativen.
        </p>
        <p>
            XML Schemas sind erweiterbar, da sie in XML geschrieben werden. Mit einer erweiterbaren Schemadefinition
            kann ein Schema in einem anderen Schema wiederverwendet werden, es können eigene Datentypen neben den
            Standarddatentypen definiert werden, es kann auf mehrere Schemas im selben Schemadokument referenziert
            werden.
        </p>

        <chapter title="Sichere Datenkommunikation" id="grundlagen-sicherheit">
            <p>
                Bei der Übermittlung von Daten von einem Sender an einen Empfänger ist es wichtig, dass beide Teile die
                gleichen "Erwartungen" an den Inhalt haben. Mit XML-Schemata kann der Sender die Daten in einer Weise
                beschreiben, die der Empfänger versteht. Ein Datum wie: <code>"03-11-2004"</code> wird in einigen
                Ländern als 3. November und in anderen Ländern als 11. März interpretiert werden. Ein XML-Element mit
                einem Datentyp wie diesem: <code>&lt;date type="date"&gt;2004-03-11&lt;/date&gt;</code> gewährleistet
                jedoch ein gegenseitiges Verständnis des Inhalts, da der XML-Datentyp <code>"date"</code> das Format
                <code>"JJJJ-MM-TT"</code> erfordert.
            </p>
        </chapter>

        <chapter title="Wohlgeformt ist nicht genug!" id="grundlagen-wohlgeformt">
            <p>
                Ein wohlgeformtes XML-Dokument ist ein Dokument, das den XML-Syntaxregeln entspricht, wie:
            </p>

            <list>
                <li>es muss mit der XML-Deklaration beginnen</li>
                <li>es muss ein einziges Wurzelelement haben</li>
                <li>Start-Tags müssen passende End-Tags haben</li>
                <li>bei den Elementen wird zwischen Groß- und Kleinschreibung unterschieden</li>
                <li>alle Elemente müssen geschlossen sein</li>
                <li>alle Elemente müssen ordnungsgemäß verschachtelt sein</li>
                <li>alle Attributwerte müssen in Anführungszeichen gesetzt werden</li>
                <li>Entitäten müssen für Sonderzeichen verwendet werden</li>
            </list>

            <p>
                Auch wenn Dokumente wohlgeformt sind, können sie dennoch Fehler enthalten, und diese Fehler können
                schwerwiegende Folgen haben. Man stelle sich folgende Situation vor: Es werden 5 Bruttolaserdrucker,
                statt 5 Laserdrucker bestellt. Mit XML-Schemata können die meisten dieser Fehler von der
                Validierungssoftware erkannt werden.
            </p>
        </chapter>
    </chapter>

    <chapter title="Einfache Elemente" id="simple">
        <p>
            Ein einfaches Element ist ein XML-Element, das nur Text enthalten kann. Es kann keine anderen Elemente oder
            Attribute enthalten. Die Einschränkung "nur Text" ist jedoch ziemlich irreführend. Der Text kann von vielen
            verschiedenen Typen sein. Er kann einer der Typen sein, die in der XML-Schema-Definition enthalten sind
            (boolean, string, date usw.), oder er kann ein benutzerdefinierter Typ sein, der selbst festgelegt wurde. Es
            können auch Einschränkungen (Facetten) zu einem Datentyp hinzugefügt werden, um seinen Inhalt zu begrenzen,
            oder es kann verlangt werden, dass die Daten einem bestimmten Muster entsprechen.
        </p>

        <chapter title="Elementattribute" id="simple-attribut">
            <code-block lang="xml">
                <![CDATA[
                <xs:element name="color" type="xs:string" default="red"/>
                ]]>
            </code-block>

            <table>
                <tr>
                    <td>Attribut</td>
                    <td>Beschreibung</td>
                </tr>
                <tr>
                    <td><code>name</code></td>
                    <td>
                        Mit diesem Attribut wird der Name des neuen Elementes definiert.
                    </td>
                </tr>
                <tr>
                    <td><code>type</code></td>
                    <td>
                        Mit diesem Attribut wird der Datentyp des neuen Elementes definiert. Beispiele hierfür währen:
                        <code>xs:string</code>, <code>xs:decimal</code>, <code>xs:integer</code>,
                        <code>xs:boolean</code>, <code>xs:date</code>, <code>xs:time</code>.
                    </td>
                </tr>
                <tr>
                    <td><code>default</code></td>
                    <td>
                        Ein Standardwert wird dem Element automatisch zugewiesen, wenn kein anderer Wert angegeben wird.
                        Das Attribut default kann nicht zusammen mit <code>fixed</code> in derselben Elementdefinition
                        verwendet werden.
                    </td>
                </tr>
                <tr>
                    <td><code>fixed</code></td>
                    <td>
                        Hiermit wird dem Element automatisch ein fester Wert zugewiesen, und es kann kein anderer Wert
                        angegeben werden. Das Attribut default kann nicht zusammen mit <code>fixed</code> in derselben
                        Elementdefinition verwendet werden.
                    </td>
                </tr>
            </table>
        </chapter>

        <chapter title="Das schema-Element" id="simple-schema">
            <p>
                Das <code>schema</code>-Element ist das Wurzelelement jeder XSD. Es kann mehrere Attribute enthalten:
            </p>

            <table>
                <tr>
                    <td>Attribut</td>
                    <td>Beispiel</td>
                    <td>Beschreibung</td>
                </tr>
                <tr>
                    <td><code>xmlns</code></td>
                    <td><code>xmlns="https://www.example.com"</code></td>
                    <td>
                        Gibt an, dass der Standard-Namespace <code>"https://www.example.com"</code> ist.
                    </td>
                </tr>
                <tr>
                    <td><code>xmlns:xs</code></td>
                    <td><code>xmlns:xs="http://www.w3.org/2001/XMLSchema"</code></td>
                    <td>
                        Gibt an, dass die im Schema verwendeten Elemente und Datentypen aus dem Namespace
                        <code>"http://www.w3.org/2001/XMLSchema"</code> stammen. Er gibt auch an, dass den Elementen und
                        Datentypen, die aus dem Namensraum <code>"http://www.w3.org/2001/XMLSchema"</code> stammen, das
                        Präfix <code>xs:</code> vorangestellt werden sollte.
                    </td>
                </tr>
                <tr>
                    <td><code>targetNamespace</code></td>
                    <td><code>targetNamespace="https://www.example.com"</code></td>
                    <td>
                        Gibt an, dass die in diesem Schema definierten Elemente (<code>note</code>, <code>to</code>,
                        <code>from</code>, <code>heading</code>, <code>body</code>.) aus dem Namensraum
                        <code>"https://www.example.com"</code> stammen.
                    </td>
                </tr>
                <tr>
                    <td><code>elementFromDefault</code></td>
                    <td><code>elementFormDefault="qualified"</code></td>
                    <td>
                        Gibt an, dass alle vom XML-Instanzdokument verwendeten Elemente, die in diesem Schema deklariert
                        wurden, Namespace-qualifiziert sein müssen.
                    </td>
                </tr>
            </table>
        </chapter>
    </chapter>

    <chapter title="Komplexe Elemente" id="komplex">
        <p>
            Ein komplexes Element ist ein XML-Element, das andere Elemente und/oder Attribute enthält. Es gibt vier
            Arten von komplexen Elementen (wovon jedes der Elemente Attribute enthalten kann):
        </p>

        <list>
            <li>leere Elemente</li>
            <li>Elemente, die nur andere Elemente enthalten</li>
            <li>Elemente, die nur Text enthalten</li>
            <li>Elemente, die sowohl andere Elemente als auch Text enthalten</li>
        </list>

        <code-block lang="xml">
            <![CDATA[
            <employee>
                <firstname>John</firstname>
                <lastname>Smith</lastname>
            </employee>
            ]]>
        </code-block>

        <p>
            Das Element <code>employee</code> kann direkt deklariert werden, indem das Element benannt wird, etwa so:
        </p>

        <code-block lang="xml">
            <![CDATA[
            <xs:element name="employee">
                <xs:complexType>
                    <xs:sequence>
                        <xs:element name="firstname" type="xs:string"/>
                        <xs:element name="lastname" type="xs:string"/>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
            ]]>
        </code-block>

        <p>
            Das Element <code>employee</code> kann ein <code>type</code>-Attribut haben, das auf den Namen des zu
            verwendenden komplexen Typs verweist. Somit kann der Typ auch wiederverwendet werden:
        </p>

        <code-block lang="xml">
            <![CDATA[
            <xs:element name="employee" type="personinfo"/>
            <xs:element name="student" type="personinfo"/>
            <xs:element name="member" type="personinfo"/>

            <xs:complexType name="personinfo">
                <xs:sequence>
                    <xs:element name="firstname" type="xs:string"/>
                    <xs:element name="lastname" type="xs:string"/>
                </xs:sequence>
            </xs:complexType>
            ]]>
        </code-block>

        <p>
            Ein komplexer Typ kann auch auf einem bestehenden komplexen Typ aufbauen und einige Elemente hinzufügen,
            etwa so:
        </p>

        <code-block lang="xml">
            <![CDATA[
            <xs:element name="employee" type="fullpersoninfo"/>

            <xs:complexType name="personinfo">
                <xs:sequence>
                    <xs:element name="firstname" type="xs:string"/>
                    <xs:element name="lastname" type="xs:string"/>
                </xs:sequence>
            </xs:complexType>

            <xs:complexType name="fullpersoninfo">
                <xs:complexContent>
                    <xs:extension base="personinfo">
                        <xs:sequence>
                            <xs:element name="address" type="xs:string"/>
                            <xs:element name="city" type="xs:string"/>
                            <xs:element name="country" type="xs:string"/>
                        </xs:sequence>
                    </xs:extension>
                </xs:complexContent>
            </xs:complexType>
            ]]>
        </code-block>

        <chapter title="Komplexe Elemente welche nur Attribute enthalten" id="komplex-attribut">


            <code-block lang="xml">
                <![CDATA[
                <product prodid="1345" />
                ]]>
            </code-block>

            <chapter title="Beispiel (1)" id="komplex-attribut-beispiel1">
                <code-block lang="xml">
                    <![CDATA[
                    <xs:element name="product">
                        <xs:complexType>
                            <xs:complexContent>
                                <xs:restriction base="xs:integer">
                                    <xs:attribute name="prodid" type="xs:positiveInteger"/>
                                </xs:restriction>
                            </xs:complexContent>
                        </xs:complexType>
                    </xs:element>
                    ]]>
                </code-block>
            </chapter>

            <chapter title="Beispiel (2)" id="komplex-attribut-beispiel2">
                <code-block lang="xml">
                    <![CDATA[
                    <xs:element name="product">
                        <xs:complexType>
                            <xs:attribute name="prodid" type="xs:positiveInteger"/>
                        </xs:complexType>
                    </xs:element>
                    ]]>
                </code-block>

                <p>
                    Im Beispiel (1) wird ein komplexer Typ mit einem komplexen Inhalt definiert. Das Element
                    <code>complexContent</code> signalisiert, dass beabsichtigt wird, das Inhaltsmodell eines komplexen
                    Typs einzuschränken oder zu erweitern, und die Einschränkung von integer deklariert ein Attribut,
                    führt aber keinen Elementinhalt ein. Es ist somit möglich die Deklaration wie im obigen Beispiel (2)
                    kompakter zu schreiben.
                </p>
            </chapter>

            <chapter title="Beispiel (3)" id="komplex-attribut-beispiel3">
                <code-block lang="xml">
                    <![CDATA[
                    <xs:element name="product" type="prodtype"/>

                    <xs:complexType name="prodtype">
                        <xs:attribute name="prodid" type="xs:positiveInteger"/>
                    </xs:complexType>
                    ]]>
                </code-block>

                <p>
                    Es besteht auch die Möglichkeit, das <code>complexType</code> Element auszulagern und ein Name zu
                    geben. Damit kann es auch für andere Elemente verwendet werden und gestaltet das XSD-Dokument
                    übersichtlicher.
                </p>
            </chapter>
        </chapter>

        <chapter title="Komplexe Elemente welche nur Elemente enthalten" id="komplex-element">
            <code-block lang="xml">
                <![CDATA[
                <person>
                    <firstname>John</firstname>
                    <lastname>Smith</lastname>
                </person>
                ]]>
            </code-block>

            <p>
                Mit dem <code>&lt;xs:sequence&gt;</code> Tag wird definiert, dass die im XSD definierten Elemente im
                XML-Dokument in der definierten Reihenfolge erscheinen müssen.
            </p>

            <chapter title="Beispiel (1)" id="komplex-element-beispiel1">
                <code-block lang="xml">
                    <![CDATA[
                    <xs:element name="person">
                        <xs:complexType>
                            <xs:sequence>
                                <xs:element name="firstname" type="xs:string"/>
                                <xs:element name="lastname" type="xs:string"/>
                            </xs:sequence>
                        </xs:complexType>
                    </xs:element>
                    ]]>
                </code-block>
            </chapter>

            <chapter title="Beispiel (2)" id="komplex-element-beispiel2">
                <code-block lang="xml">
                    <![CDATA[
                    <xs:element name="person" type="persontype"/>

                    <xs:complexType name="persontype">
                        <xs:sequence>
                            <xs:element name="firstname" type="xs:string"/>
                            <xs:element name="lastname" type="xs:string"/>
                        </xs:sequence>
                    </xs:complexType>
                    ]]>
                </code-block>

                <p>
                    Es besteht auch die Möglichkeit, das <code>complexType</code>-Element auszulagern und ein Name zu
                    geben. Damit kann es auch für andere Elemente verwendet werden und gestaltet das XSD-Dokument
                    übersichtlicher.
                </p>
            </chapter>
        </chapter>

        <chapter title="Komplexe Elemente welche nur Text enthalten" id="komplex-text">
            <p>
                Dieser Typ enthält nur einfachen Inhalt (Text und Attribute), daher wird ein
                <code>simpleContent</code>-Element um den Inhalt herum hinzugefügt. Wird einfacher Inhalt verwendet,
                muss innerhalb des <code>simpleContent</code>-Elements ein extension ODER ein
                <code>restriction</code>-Element definiert werden:
            </p>

            <code-block lang="xml" collapsible="true" collapsed-title="extension">
                <![CDATA[
                <xs:element name="somename">
                    <xs:complexType>
                        <xs:simpleContent>
                            <xs:extension base="basetype">
                                ....
                                ....
                            </xs:extension>
                        </xs:simpleContent>
                    </xs:complexType>
                </xs:element>
                ]]>
            </code-block>

            <code-block lang="xml" collapsible="true" collapsed-title="restriction">
                <![CDATA[
                <xs:element name="somename">
                    <xs:complexType>
                        <xs:simpleContent>
                            <xs:restriction base="basetype">
                                ....
                                ....
                            </xs:restriction>
                        </xs:simpleContent>
                    </xs:complexType>
                </xs:element>
                ]]>
            </code-block>

            <code-block lang="xml">
                <![CDATA[
                <shoesize country="france">35</shoesize>
                ]]>
            </code-block>

            <chapter title="Beispiel (1)" id="komplex-text-beispiel1">
                <code-block lang="xml">
                    <![CDATA[
                    <xs:element name="shoesize">
                        <xs:complexType>
                            <xs:simpleContent>
                                <xs:extension base="xs:integer">
                                    <xs:attribute name="country" type="xs:string" />
                                </xs:extension>
                            </xs:simpleContent>
                        </xs:complexType>
                    </xs:element>
                    ]]>
                </code-block>
            </chapter>

            <chapter title="Beispiel (2)" id="komplex-text-beispiel2">
                <code-block lang="xml">
                    <![CDATA[
                    <xs:element name="shoesize" type="shoetype"/>

                    <xs:complexType name="shoetype">
                        <xs:simpleContent>
                            <xs:extension base="xs:integer">
                                <xs:attribute name="country" type="xs:string" />
                            </xs:extension>
                        </xs:simpleContent>
                    </xs:complexType>
                    ]]>
                </code-block>

                <p>
                    Es besteht auch die Möglichkeit, das <code>complexType</code>-Element auszulagern und ein Name zu
                    geben. Damit kann es auch für andere Elemente verwendet werden und gestaltet das XSD-Dokument
                    übersichtlicher.
                </p>
            </chapter>
        </chapter>

        <chapter title="Komplexe Elemente mit verschiedenen Inhalt" id="komplex-verschieden">
            <code-block lang="xml">
                <![CDATA[
                <letter>
                  Dear Mr. <name>John Smith</name>.
                  Your order <orderid>1032</orderid>
                  will be shipped on <shipdate>2001-07-13</shipdate>.
                </letter>
                ]]>
            </code-block>

            <p>
                Damit Text zwischen den Kindelementen von <code>letter</code> geschrieben werden kann, muss in der XSD
                auf dem <code>complexType</code> das Attribut <code>mixed="true"</code> definiert werden.
            </p>

            <chapter title="Beispiel (1)" id="komplex-verschieden-beispiel1">
                <code-block lang="xml">
                    <![CDATA[
                    <xs:element name="letter">
                        <xs:complexType mixed="true">
                            <xs:sequence>
                                <xs:element name="name" type="xs:string"/>
                                <xs:element name="orderid" type="xs:positiveInteger"/>
                                <xs:element name="shipdate" type="xs:date"/>
                            </xs:sequence>
                        </xs:complexType>
                    </xs:element>
                    ]]>
                </code-block>
            </chapter>

            <chapter title="Beispiel (2)" id="komplex-verschieden-beispiel2">
                <code-block lang="xml">
                    <![CDATA[
                    <xs:element name="letter" type="lettertype"/>

                    <xs:complexType name="lettertype" mixed="true">
                        <xs:sequence>
                            <xs:element name="name" type="xs:string"/>
                            <xs:element name="orderid" type="xs:positiveInteger"/>
                            <xs:element name="shipdate" type="xs:date"/>
                        </xs:sequence>
                    </xs:complexType>
                    ]]>
                </code-block>

                <p>
                    Es besteht auch die Möglichkeit, das <code>complexType</code>-Element auszulagern und ein Name zu
                    geben. Damit kann es auch für andere Elemente verwendet werden und gestaltet das XSD-Dokument
                    übersichtlicher.
                </p>
            </chapter>
        </chapter>

        <chapter title="Das any Element" id="komplex-any">
            <p>
                Das <code>any</code>-Element ermöglicht es, das XML-Dokument mit Elementen zu erweitern, die nicht durch
                das Schema definiert werden.
            </p>

            <code-block lang="xml" collapsible="true" collapsed-title="Persons.xsd">
                <![CDATA[
                <xs:element name="person">
                    <xs:complexType>
                        <xs:sequence>
                            <xs:element name="firstname" type="xs:string"/>
                            <xs:element name="lastname" type="xs:string"/>
                            <xs:any minOccurs="0"/>
                        </xs:sequence>
                    </xs:complexType>
                </xs:element>

                <xs:element name="children">
                    <xs:complexType>
                        <xs:sequence>
                            <xs:element name="childname" type="xs:string" maxOccurs="unbounded"/>
                        </xs:sequence>
                    </xs:complexType>
                </xs:element>
                ]]>
            </code-block>

            <code-block lang="xml" collapsible="true" collapsed-title="Persons.xml">
                <![CDATA[
                <persons>
                    <person>
                        <firstname>Hege</firstname>
                        <lastname>Refsnes</lastname>
                        <children>
                            <childname>Cecilie</childname>
                        </children>
                    </person>

                    <person>
                        <firstname>Stale</firstname>
                        <lastname>Refsnes</lastname>
                    </person>
                </persons>
                ]]>
            </code-block>

            <p>
                Dieses XML-Dokument ist valide, da das XSD-Dokument es erlaubt dem <code>person</code>-Element ein
                optionales Element nach <code>lastname</code> hinzuzufügen.
            </p>
        </chapter>

        <chapter title="Das anyAttribute Element" id="komplex-anyattribute">
            <p>
                Das <code>any</code>-Element ermöglicht es, das XML-Elemente mit Attributen zu erweitern, die nicht
                durch das Schema definiert werden.
            </p>

            <code-block lang="xml" collapsible="true" collapsed-title="Persons.xsd">
                <![CDATA[
                <xs:element name="person">
                    <xs:complexType>
                        <xs:sequence>
                            <xs:element name="firstname" type="xs:string"/>
                            <xs:element name="lastname" type="xs:string"/>
                        </xs:sequence>
                        <xs:anyAttribute/>
                    </xs:complexType>
                </xs:element>

                <xs:attribute name="eyecolor">
                    <xs:simpleType>
                        <xs:restriction base="xs:string">
                            <xs:pattern value="blue|brown|green|grey"/>
                        </xs:restriction>
                    </xs:simpleType>
                </xs:attribute>
                ]]>
            </code-block>

            <code-block lang="xml" collapsible="true" collapsed-title="Persons.xml">
                <![CDATA[
                <persons>
                    <person eyecolor="green">
                        <firstname>Hege</firstname>
                        <lastname>Refsnes</lastname>
                    </person>

                    <person eyecolor="blue">
                        <firstname>Stale</firstname>
                        <lastname>Refsnes</lastname>
                    </person>
                </persons>
                ]]>
            </code-block>

            <p>
                Dieses XML-Dokument ist valide, da das XSD-Dokument es erlaubt dem <code>person</code>-Element ein
                optionales Attribut hinzuzufügen.
            </p>
        </chapter>
    </chapter>

    <chapter title="Elementsubstitution" id="elementsubstitution">
        <p>
            Mit XML-Schemas kann ein Element ein anderes ersetzen. Angenommen, wir haben Benutzer aus zwei verschiedenen
            Ländern: England und Norwegen. Wir möchten, dass der Benutzer wählen kann, ob er oder sie die norwegischen
            Elementnamen oder die englischen Elementnamen im XML-Dokument verwenden möchte. Um dieses Problem zu lösen,
            könnten wir eine <code>substitutionGroup</code> im XML-Schema definieren. Zuerst wird ein Head-Element und
            dann die anderen Elemente deklariert, die angeben, dass sie das Head-Element ersetzen können.
        </p>

        <code-block lang="xml">
            <![CDATA[
            <xs:element name="name" type="xs:string"/>
            <xs:element name="navn" substitutionGroup="name"/>

            <xs:complexType name="custinfo">
                <xs:sequence>
                    <xs:element ref="name"/>
                </xs:sequence>
            </xs:complexType>

            <xs:element name="customer" type="custinfo"/>
            <xs:element name="kunde" substitutionGroup="customer"/>
            ]]>
        </code-block>

        <p>
            Beide der folgenden XML-Dokumente sind valide:
        </p>

        <code-block lang="xml">
            <![CDATA[
            <customer>
                <name>John Smith</name>
            </customer>
            ]]>
        </code-block>

        <code-block lang="xml">
            <![CDATA[
            <kunde>
                <name>John Smith</name>
            </kunde>
            ]]>
        </code-block>

        <chapter title="Elementsubstitution blockieren" id="elementsubstitution-blockieren">
            <p>
                Um Elementsubstitution zu blockieren, kann dem Element das Attribut <code>block="substitution"</code>
                hinzugefügt werden.
            </p>

            <code-block lang="xml">
                <![CDATA[
                <xs:element name="name" type="xs:string" block="substitution"/>
                ]]>
            </code-block>
        </chapter>

        <chapter title="substitutionGroup" id="elementsubstitution-substitutiongroup">
            <p>
                Der Typ der substituierbaren Elemente muss derselbe sein wie der Typ des Head-Elements oder davon
                abgeleitet sein. Wenn der Typ des ersetzbaren Elements derselbe ist wie der Typ des Head-Elements, muss
                der Typ des ersetzbaren Elements nicht angegeben werden. Hierbei muss beachtet werden, dass alle
                Elemente in der <code>substitutionGroup</code> (das Head-Element und die substituierbaren Elemente) als
                globale Elemente deklariert werden müssen, sonst funktioniert es nicht! Globale Elemente sind Elemente,
                die unmittelbare Kinder des schema Elements sind! Lokale Elemente sind Elemente, die in anderen
                Elementen verschachtelt sind.
            </p>
        </chapter>
    </chapter>

    <chapter title="Indikatoren" id="indikatoren">
        <p>
            Mit Indikatoren ist es möglich, zu steuern, wie Elemente in Dokumenten verwendet werden sollen.
        </p>

        <chapter title="Sortierindikatoren" id="indikatoren-sort">
            <table>
                <tr>
                    <td>Indikator</td>
                    <td>Beschreibung</td>
                    <td>Beispiel</td>
                </tr>
                <tr>
                    <td><code>all</code></td>
                    <td>
                        <p>
                            Der <code>all</code>-Indikator gibt an, dass die untergeordneten Elemente in beliebiger
                            Reihenfolge erscheinen können und dass jedes untergeordnete Element nur einmal vorkommen
                            darf.
                        </p>
                        <p>
                            Wird der <code>all</code>-Indikator verwendet kann der <code>minOccurs</code> Indikator auf
                            <code>0</code> oder <code>1</code> und der <code>maxOccurs</code> nur auf <code>1</code>
                            gesetzt werden.
                        </p>
                    </td>
                    <td>
                        <code-block lang="xml">
                            <![CDATA[
                            <xs:element name="person">
                                <xs:complexType>
                                    <xs:all>
                                        <xs:element name="firstname" type="xs:string"/>
                                        <xs:element name="lastname" type="xs:string"/>
                                    </xs:all>
                                </xs:complexType>
                            </xs:element>
                            ]]>
                        </code-block>
                    </td>
                </tr>
                <tr>
                    <td><code>choice</code></td>
                    <td>
                        Der <code>choice</code>-Indikator gibt an, dass nur eines der Kindelemente vorkommen kann.
                    </td>
                    <td>
                        <code-block lang="xml">
                            <![CDATA[
                            <xs:element name="person">
                                <xs:complexType>
                                    <xs:choice>
                                        <xs:element name="employee" type="employee"/>
                                        <xs:element name="member" type="member"/>
                                    </xs:choice>
                                </xs:complexType>
                            </xs:element>
                            ]]>
                        </code-block>
                    </td>
                </tr>
                <tr>
                    <td><code>sequence</code></td>
                    <td>
                        Der <code>sequence</code>-Indikator gibt an, dass die untergeordneten Elemente in einer
                        bestimmten Reihenfolge erscheinen müssen.
                    </td>
                    <td>
                        <code-block lang="xml">
                            <![CDATA[
                            <xs:element name="person">
                                <xs:complexType>
                                    <xs:sequence>
                                        <xs:element name="firstname" type="xs:string"/>
                                        <xs:element name="lastname" type="xs:string"/>
                                    </xs:sequence>
                                </xs:complexType>
                            </xs:element>
                            ]]>
                        </code-block>
                    </td>
                </tr>
            </table>
        </chapter>

        <chapter title="Vorkommensindikatoren" id="indikatoren-vorkommen">
        </chapter>

        <chapter title="Gruppenindikatoren" id="indikatoren-gruppe">

            <chapter title="Elementgruppen" id="indikatoren-gruppe-element">
            </chapter>

            <chapter title="Attributgruppen" id="indikatoren-gruppe-attribut">
            </chapter>
        </chapter>
    </chapter>

    <chapter title="Einschränkungen (restrictions/facets)" id="restrictions">
    </chapter>

    <chapter title="Attribute" id="attribute">

        <chapter title="Attributattribute" id="attribute-attribute">
        </chapter>
    </chapter>

    <chapter title="Datentypen" id="datentypen">

        <chapter title="XSD String Datentypen" id="datentypen-string">

            <chapter title="Einschränkungen" id="datentypen-string-restrictions">
            </chapter>
        </chapter>

        <chapter title="XSD Date/Time Datentypen" id="datentypen-datetime">

            <chapter title="Einschränkungen" id="datentypen-datetime-restrictions">
            </chapter>
        </chapter>

        <chapter title="XSD numerische Datentypen" id="datentypen-numerisch">

            <chapter title="Einschränkungen" id="datentypen-numerisch-restrictions">
            </chapter>
        </chapter>

        <chapter title="XSD verschiedene Datentypen" id="datentypen-verschieden">

            <chapter title="Einschränkungen" id="datentypen-verschieden-restrictions">
            </chapter>
        </chapter>
    </chapter>

    <chapter title="Quellen" id="quellen">
        <tip>
            <b>(BUCH)</b>
            978-3836254663, IT Handbuch für Fachinformatiker, Sascha Kersken, Rheinwerk Verlag GmbH, 2017
        </tip>
        <tip>
            <b>(WEBSEITE)</b>
            <a href="https://de.wikipedia.org/wiki/XML_Schema" ignore-vars="true">
                https://de.wikipedia.org/wiki/XML_Schema
            </a>, 2023-02-20 13:30
        </tip>
        <tip>
            <b>(WEBSEITE)</b>
            <a href="https://www.w3schools.com/xml/xml_schema.asp" ignore-vars="true">
                https://www.w3schools.com/xml/xml_schema.asp
            </a>, 2023-02-26 12:30
        </tip>
        <tip>
            <b>(WEBSEITE)</b>
            <a href="https://www.w3schools.com/xml/schema_intro.asp" ignore-vars="true">
                https://www.w3schools.com/xml/schema_intro.asp
            </a>, 2023-02-26 12:45
        </tip>
        <tip>
            <b>(WEBSEITE)</b>
            <a href="https://www.w3schools.com/xml/schema_dtypes_string.asp" ignore-vars="true">
                https://www.w3schools.com/xml/schema_dtypes_string.asp
            </a>, 2023-02-26 13:30
        </tip>
        <tip>
            <b>(WEBSEITE)</b>
            <a href="https://www.w3schools.com/xml/schema_dtypes_date.asp" ignore-vars="true">
                https://www.w3schools.com/xml/schema_dtypes_date.asp
            </a>, 2023-02-26 13:45
        </tip>
        <tip>
            <b>(WEBSEITE)</b>
            <a href="https://www.w3schools.com/xml/schema_dtypes_numeric.asp" ignore-vars="true">
                https://www.w3schools.com/xml/schema_dtypes_numeric.asp
            </a>, 2023-02-26 14:00
        </tip>
        <tip>
            <b>(WEBSEITE)</b>
            <a href="https://www.w3schools.com/xml/schema_dtypes_misc.asp" ignore-vars="true">
                https://www.w3schools.com/xml/schema_dtypes_misc.asp
            </a>, 2023-02-26 14:30
        </tip>
        <tip>
            <b>(WEBSEITE)</b>
            <a href="https://www.w3schools.com/xml/schema_schema.asp" ignore-vars="true">
                https://www.w3schools.com/xml/schema_schema.asp
            </a>, 2023-02-26 17:00
        </tip>
        <tip>
            <b>(WEBSEITE)</b>
            <a href="https://www.w3schools.com/xml/schema_simple.asp" ignore-vars="true">
                https://www.w3schools.com/xml/schema_simple.asp
            </a>, 2023-02-26 17:00
        </tip>
        <tip>
            <b>(WEBSEITE)</b>
            <a href="https://www.w3schools.com/xml/schema_simple_attributes.asp" ignore-vars="true">
                https://www.w3schools.com/xml/schema_simple_attributes.asp
            </a>, 2023-02-26 17:15
        </tip>
        <tip>
            <b>(WEBSEITE)</b>
            <a href="https://www.w3schools.com/xml/schema_complex.asp" ignore-vars="true">
                https://www.w3schools.com/xml/schema_complex.asp
            </a>, 2023-02-26 17:15
        </tip>
        <tip>
            <b>(WEBSEITE)</b>
            <a href="https://www.w3schools.com/xml/schema_facets.asp" ignore-vars="true">
                https://www.w3schools.com/xml/schema_facets.asp
            </a>, 2023-02-27 13:00
        </tip>
        <tip>
            <b>(WEBSEITE)</b>
            <a href="https://www.w3schools.com/xml/schema_complex_indicators.asp" ignore-vars="true">
                https://www.w3schools.com/xml/schema_complex_indicators.asp
            </a>, 2023-02-27 14:45
        </tip>
        <tip>
            <b>(WEBSEITE)</b>
            <a href="https://www.w3schools.com/xml/schema_complex_any.asp" ignore-vars="true">
                https://www.w3schools.com/xml/schema_complex_any.asp
            </a>, 2023-02-27 15:30
        </tip>
        <tip>
            <b>(WEBSEITE)</b>
            <a href="https://www.w3schools.com/xml/schema_complex_anyattribute.asp" ignore-vars="true">
                https://www.w3schools.com/xml/schema_complex_anyattribute.asp
            </a>, 2023-02-27 16:00
        </tip>
        <tip>
            <b>(WEBSEITE)</b>
            <a href="https://www.w3schools.com/xml/schema_complex_empty.asp" ignore-vars="true">
                https://www.w3schools.com/xml/schema_complex_empty.asp
            </a>, 2023-02-27 16:30
        </tip>
        <tip>
            <b>(WEBSEITE)</b>
            <a href="https://www.w3schools.com/xml/schema_complex_elements.asp" ignore-vars="true">
                https://www.w3schools.com/xml/schema_complex_elements.asp
            </a>, 2023-02-27 16:45
        </tip>
        <tip>
            <b>(WEBSEITE)</b>
            <a href="https://www.w3schools.com/xml/schema_complex_text.asp" ignore-vars="true">
                https://www.w3schools.com/xml/schema_complex_text.asp
            </a>, 2023-02-27 17:00
        </tip>
        <tip>
            <b>(WEBSEITE)</b>
            <a href="https://www.w3schools.com/xml/schema_complex_mixed.asp" ignore-vars="true">
                https://www.w3schools.com/xml/schema_complex_mixed.asp
            </a>, 2023-02-27 17:15
        </tip>
        <tip>
            <b>(WEBSEITE)</b>
            <a href="https://www.w3schools.com/xml/schema_complex_subst.asp" ignore-vars="true">
                https://www.w3schools.com/xml/schema_complex_subst.asp
            </a>, 2023-02-27 17:30
        </tip>
    </chapter>

</topic>