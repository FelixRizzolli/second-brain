<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
        SYSTEM "https://resources.jetbrains.com/writerside/1.0/xhtml-entities.dtd">
<topic xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="https://resources.jetbrains.com/writerside/1.0/topic.v2.xsd"
       title="XML (Extensible Markup Language)" id="xml">
    <show-structure for="chapter,procedure" depth="2"/>

    <chapter title="Was ist XML?" id="xml">
        <p>
            XML (Extensible Markup Language), ist eine Metasprache zur Definition beliebiger Auszeichnungssprachen. 
            Diese Sprachen können Textdokumente, Vektorgrafiken, multimediale Präsentationen, Datenbanken oder andere 
            Arten von strukturierten Daten Beschreiben. XML wurde vom W3C entworfen und standardisiert. Die 
            XML-Spezifikation selbst enthält nur wenige formale Regeln für den Aufbau von Dokumenten. Hält man sich an 
            diese Regeln, erzeugt man ein wohlgeformtes XML-Dokument. Dokumente die auf Formatdefinitionen wie DTD 
            (= Document Type Definition), XLS (= XML Schema) oder RELAX NG basieren sind nicht nur wohlgeformt, sondern 
            auch gültig (oder valide). Der überwiegende Einsatz von XML beruht auf dem Einsatz vorhandener XML-basierter 
            Sprachen wie die Webseiten-Auszeichnungssprache XHTML, das Vektorgrafikformat SVG (= Scalable Vector 
            Graphics) oder die beliebte Handbuch- und Dokumentationssprache DocBook. Auch Anwendungsprogramme wie 
            LibreOffice/OpenOffice.org und neuere Versionen der Microsoft-Office-Programme verwenden XML-basierte 
            Datenformate, hierbei ist die Office-Arbeitsdatei ein ZIP-Archiv, in dem sich verschiedene XML-Dokumente und 
            eventuell weitere Ressourcen wie Bilddateien befinden. Gespeichert werden XML-Dokumente entweder als Datei 
            mit der Endung .xml, wenn es sich um allgemeine XML-Dokumente handelt, oder mit einer speziellen 
            Dateierweiterung, falls ein besonderes XML-Format verwendet wird (SVG <code>.svg</code>; XHTML 
            <code>.html</code> oder <code>.htm</code>).
        </p>

        <chapter title="Klartextbasierte Dokumentformate vs. Binärdateien" id="xml-format">
            <list>
                <li>
                    Sämtliche Konfigurations- und Strukturinformationen sind für Menschen lesbar und können notfalls
                    auch manuell geändert werden.
                </li>
                <li>
                    Die Dokumente lassen sich auf jedem beliebigen Computersystem in einem einfachen Texteditor öffnen
                    und eventuell bearbeiten. Der reine Textinhalt erschließt sich auch Anwendern, die die verwendeten
                    Auszeichnungsbefehle nicht verstehen.
                </li>
                <li>
                    Der Austausch von Dokumenten mit anderen Anwendungen, neunen Versionen einer Anwendung oder
                    Programmiersprachen ist erheblich einfacher als bei Binärformaten.
                </li>
            </list>

            <p>
                Der entscheidende Nachteil gegenüber Binärdateiformaten ist, dass textbasierte Formate mehr
                Speicherplatz benötigen.
            </p>
        </chapter>

        <chapter title="XML im Vergleich zu anderen Auszeichnungssprachen" id="xml-vergleich">
            <p>
                Fast alle textbasierten Auszeichnungssprachen außer XML haben eine spezielle Aufgabe: Beispielsweise
                dient LaTeX dem Erstellen von Vorlagen für den professionellen Satz; PostScript beschreibt dagegen
                fertig formatierte Ausgabeseiten für High-End-Drucker und -Belichter. Darüber hinaus besitzen
                Unix-Serveranwendungen und viele andere Programme jeweils ein eigenes ASCII-basiertes
                Konfigurationsdateiformat. XML ist dagegen eine universelle Sprache. In einem XML-Dokument kann die
                Musik-CD-Sammlung, die Doktorarbeit oder Geschäftsdaten gespeichert werden. XML beschreibt hier aber
                immer nur die Struktur und den Aufbau der Daten. Das Layout der Druck- oder Webversion von Textinhalten
                muss durch eine externe Stil- oder Formatierungssprache wie XSLT beschrieben werden.
            </p>
        </chapter>

        <chapter title="XML HttpRequest" id="xml-httprequest">
            <p>
                Alle modernen Browser haben ein eingebautes XMLHttpRequest-Objekt, um Daten von einem Server 
                anzufordern. Das XMLHttpRequest-Objekt kann verwendet werden, um Daten von einem Webserver anzufordern. 
                Das XMLHttpRequest-Objekt ist ein Traum für Entwickler, denn kann man:
            </p>
            
            <list>
                <li>eine Webseite aktualisieren, ohne die Seite neu zu laden</li>
                <li>Daten von einem Server anfordern - nachdem die Seite geladen wurde</li>
                <li>Daten von einem Server empfangen - nachdem die Seite geladen wurde</li>
                <li>Daten an einen Server senden - im Hintergrund</li>
            </list>
        </chapter>

        <chapter title="XML Parser" id="xml-parser">
            <p>
                Alle gängigen Browser verfügen über einen eingebauten XML-Parser für den Zugriff auf und die Bearbeitung
                von XML. Das XML DOM (Document Object Model) definiert die Eigenschaften und Methoden für den Zugriff
                auf und die Bearbeitung von XML. Bevor jedoch auf ein XML-Dokument zugegriffen werden kann, muss es in
                ein XML-DOM-Objekt geladen werden. Der XML-Parser wandelt den Text in ein XML-DOM-Objekt um.
            </p>
        </chapter>

        <chapter title="XML AJAX" id="xml-ajax">
        </chapter>
    </chapter>

    <chapter title="Terminologie" id="terminologie">
        <code-block lang="xml">
            &lt;?xml version="1.0" encoding="UTF-8"?&gt;
            &lt;bookstore&gt;
                &lt;book&gt;
                    &lt;title&gt;Harry Potter&lt;/title&gt;
                    &lt;author&gt;J K. Rowling&lt;/author&gt;
                    &lt;year&gt;2005&lt;/year&gt;
                    &lt;price&gt;29.99&lt;/price&gt;
                &lt;/book&gt;
                &lt;book&gt;
                    &lt;title lang="en"&gt;Learning XML&lt;/title&gt;
                    &lt;price&gt;39.95&lt;/price&gt;
                &lt;/book&gt;
            &lt;/bookstore&gt;
        </code-block>

        <table style="header-row">
            <tr>
                <td>DE</td>
                <td>EN</td>
                <td>Anmerkung</td>
            </tr>
            <tr>
                <td>Knoten</td>
                <td>node</td>
                <td>
                    <p>
                        In XPath gibt es sieben Arten von Knoten: Element-, Attribut-, Text-, Namespace-, Steuerungs-,
                        Kommentar- und Wurzelknoten. XML-Dokumente werden als Bäume von Knoten behandelt. Das oberste
                        Element des Baums wird als Wurzelelement bezeichnet.
                    </p>

                    <code-block lang="xml">
                        &lt;bookstore&gt; &lt;!-- root element node --&gt;
                    </code-block>
                    <code-block lang="xml">
                        &lt;author&gt;J K. Rowling&lt;/author&gt; &lt;!-- element node --&gt;
                    </code-block>
                    <code-block lang="xml">
                        lang="en" &lt;!-- attribute node --&gt;
                    </code-block>
                </td>
            </tr>
            <tr>
                <td>Atomarer Wert</td>
                <td>atomic value</td>
                <td>
                    <p>
                        Atomare Werte sind Knoten, die weder Kinder noch Eltern haben.
                    </p>

                    <code-block lang="xml">
                        J K. Rowling
                    </code-block>
                    <code-block lang="xml">
                        "en"
                    </code-block>
                </td>
            </tr>
            <tr>
                <td>Element</td>
                <td>item</td>
                <td>
                    Elemente sind atomare Werte oder Knoten.
                </td>
            </tr>
        </table>

        <chapter title="Beziehungen von Knoten" id="terminologie-knoten">
            <table>
                <tr>
                    <td>DE</td>
                    <td>EN</td>
                    <td>Beispiel</td>
                    <td>Anmerkung</td>
                </tr>
                <tr>
                    <td>Elternteil</td>
                    <td>parent</td>
                    <td>
                        Im obigen Beispiel ist das <code>book</code>-Element das Elternteil der Elemente
                        <code>title</code>, <code>author</code>, <code>year</code> und <code>price</code>.
                    </td>
                    <td>
                        Jedes Element und Attribut hat einen Elternteil.
                    </td>
                </tr>
                <tr>
                    <td>Kind</td>
                    <td>child</td>
                    <td>
                        Im obigen Beispiel sind die Elemente <code>title</code>, <code>author</code>, <code>year</code>
                        und <code>price</code> alle untergeordnete Elemente (= Kindelemente) des Elements
                        <code>book</code>.
                    </td>
                    <td>

                    </td>
                </tr>
                <tr>
                    <td>Geschwister</td>
                    <td>siblings</td>
                    <td>
                        Im obigen Beispiel sind die Elemente <code>title</code>, <code>author</code>, <code>year</code>
                        und <code>price</code> alle Geschwister.
                    </td>
                    <td>
                        Elementknoten können null, ein oder mehrere Kinder haben.
                    </td>
                </tr>
                <tr>
                    <td>Vorfahre</td>
                    <td>anecestors</td>
                    <td>
                        Im obigen Beispiel sind die Vorfahren des Elements <code>title</code> das Element
                        <code>book</code> und das Element <code>bookstore</code>.
                    </td>
                    <td>
                        Geschwister sind Knoten, die denselben Elternteil haben.
                    </td>
                </tr>
                <tr>
                    <td>Nachkommen</td>
                    <td>descendants</td>
                    <td>
                        Im obigen Beispiel sind die Elemente <code>book</code>, <code>title</code>, <code>author</code>,
                        <code>year</code> und <code>price</code> die Nachkommen des Elements <code>bookstore</code>.
                    </td>
                    <td>
                        Ein Vorfahre kann ein Elternteil eines Knotens, Elternteil eines Elternteils usw. sein.
                    </td>
                </tr>
            </table>
        </chapter>
    </chapter>

    <chapter title="Der Aufbau von XML-Dokumenten" id="xml-aufbau">
        <p>
            Jedes XML-Dokument besteht aus einer Hierarchie ineinander verschachtelter Steueranweisungen, sie als
            Elemente oder Tags bezeichnet werden, und kann zusätzlich einfachen Text enthalten. Die XML-Tags werden in
            spitze Klammern gesetzt, also zwischen ein <code>&lt;</code>-Zeichen und ein <code>&gt;</code>-Zeichen. Sie
            können ein oder mehrere Attribute in der Form <code>attribut="wert"</code> enthalten. Jedes Tag wird unter
            Angabe seiner Bezeichnung geöffnet. (zum Beispiel <code>&lt;test&gt;</code>) und weiter unten im Dokument
            durch eine Wiederholung mit vorangestelltem Slash (<code>/</code>) wieder geschlossen (etwa
            <code>&lt;/codetest&gt;</code>).
        </p>

        <chapter title="XML Beispiel" id="xml-aufbau-beispiel">
            <code-block lang="xml">
                &lt;?xml version="1.0" encoding="utf-8" standalone="yes"?&gt;
                &lt;comics&gt;
                    &lt;comic language="en-US"&gt;
                        &lt;publisher&gt;Marvel&lt;/publisher&gt;
                        &lt;series&gt;The Amazing Spider-Man&lt;/series&gt;
                        &lt;format&gt;Comic Book&lt;/format&gt;
                        &lt;issue&gt;663&lt;/issue&gt;
                        &lt;title&gt;The Return Of Anti-Venom&lt;/title&gt;
                        &lt;subtitle&gt;Part One: The Ghost of Jean DeWolff&lt;/subtitle&gt;
                        &lt;authors&gt;
                            &lt;author role="Writer"&gt;Dan Slott&lt;/author&gt;
                            &lt;author role="Pencils"&gt;Giuseppe Camuncoli&lt;/author&gt;
                        &lt;/authors&gt;
                        &lt;price currency="USD"&gt;3.99&lt;/price&gt;
                    &lt;/comic&gt;
                    &lt;comic language="en-US"&gt;
                        &lt;publisher&gt;Marvel&lt;/publisher&gt;
                        &lt;series&gt;Ultimate Spider-Man&lt;/series&gt;
                        &lt;format&gt;Trade Paperback&lt;/format&gt;
                        &lt;issue original="1-13"&gt;1&lt;/issue&gt;
                        &lt;title&gt;Ultimate Spider-Man&lt;/title&gt;
                        &lt;subtitle&gt;Ultimate Collection&lt;/subtitle&gt;
                        &lt;authors&gt;
                            &lt;author role="Writer"&gt;Brian Michael Bendis&lt;/author&gt;
                            &lt;author role="Pencils"&gt;Mark Bagley&lt;/author&gt;
                        &lt;/authors&gt;
                        &lt;price currency="USD"&gt;24.99&lt;/price&gt;
                    &lt;/comic&gt;
                    &lt;comic language="en-US"&gt;
                        &lt;publisher&gt;DC Comics&lt;/publisher&gt;
                        &lt;series&gt;Action Comics&lt;/series&gt;
                        &lt;format&gt;Comic Book&lt;/format&gt;
                        &lt;issue&gt;901&lt;/issue&gt;
                        &lt;title&gt;Reign Of The Doomsdays&lt;/title&gt;
                        &lt;subtitle&gt;Part 1&lt;/subtitle&gt;
                        &lt;authors&gt;
                            &lt;author role="Writer"&gt;Paul Cornell&lt;/author&gt;
                            &lt;author role="Artist"&gt;Kenneth Rocafort&lt;/author&gt;
                            &lt;author role="Artist"&gt;Jesus Merino&lt;/author&gt;
                        &lt;/authors&gt;
                        &lt;price currency="USD">2.99&lt;/price&gt;
                    &lt;/comic&gt;
                    &lt;comic language="en-US"&gt;
                        &lt;publisher&gt;Bongo Comics&lt;/publisher&gt;
                        &lt;series&gt;Simpsons Comics&lt;/series&gt;
                        &lt;format&gt;Comic Book&lt;/format&gt;
                        &lt;issue>178&lt;/issue&gt;
                        &lt;title&gt;The Thingama-Bob From Outer Space&lt;/title&gt;
                        &lt;authors&gt;
                            &lt;author role="Writer"&gt;Eric Rogers&lt;/author&gt;
                            &lt;author role="Pencils"&gt;John Costanza&lt;/author&gt;
                        &lt;/authors&gt;
                        &lt;price currency="USD"&gt;2.99&lt;/price&gt;
                    &lt;/comic&gt;
                &lt;/comics&gt;
            </code-block>
        </chapter>

        <chapter title="Die XML-Steueranweisungen und XML-Deklatation" id="xml-aufbau-deklaration">
            <p>
                Eine XML-Steueranweisung (auch PI, Processing Instruction) kann in XML-Dokumenten an beliebiger Stelle
                vorkommen. Es handelt sich um Anweisungen für interpretierende Geräte oder Programme, die mit dem
                Dokument selbst nichts zu tun haben. Eine XML-Steueranweisung hat folgende Syntax:
            </p>

            <code-block lang="xml">
                &lt;?Ziel Daten?&gt;
            </code-block>

            <p>
                Als Ziel muss ein Bezeichner (Name) angegeben werden, für welche Anwendung diese Verarbeitungsanweisung
                wirksam ist. Das Ziel der Verarbeitungsanweisung darf nicht die Zeichenfolge XML sein, da dies die
                XML-Deklaration wäre. Die Daten können alle Zeichen mit Ausnahme der Kombination <code>?&gt;</code>
                enthalten. In den Daten können auch Pseudoattribute eingetragen werden, die ähnlich wie
                Attribut-Werte-Paare aussehen, vom Parser jedoch nicht als solche behandelt werden.
            </p>
            <p>
                Die XML-Deklaration steht am Beginn des Prologes einer XML-Datei. In der XML-Deklaration seht zum
                Beispiel: die verwendete XML-Version (im Beispiel <code>1.0</code>) und der verwendete Zeichensatz im
                Dokument (im Beispiel <code>utf-8</code>):
            </p>

            <code-block lang="xml">
                &lt;?xml version="1.0" encoding="utf-8" standalone="yes"?&gt;
            </code-block>

            <p>
                Das Attribut <code>standalone</code> gibt an, ob sich das Dokument auf ein externes Formatdokument wie
                ein DTD oder ein XML Schema bezieht. Der Wert <code>yes</code> besagt, dass das Dokument selbstständig
                ist und nicht von einer solchen Standardisierung abhängt. Ein solches Dokument muss wohlgeformt sein,
                aber es ist nicht valide, da es keine Spezifikation gibt, gegen die seine Gültigkeit geprüft werden
                könnte.
            </p>
        </chapter>

        <chapter title="XML-Elemente" id="xml-aufbau-elemente">
            <p>
                XML Elemente können enthalten: Text, Attribute, andere Elemente oder einen Mix aus allem. Es ist
                wichtig, dass genau ein Tag, das Wurzelelement, das gesamte Dokument umschließt. Innerhalb des
                Wurzelelements sind weitere Elemente mit ihren Unterelementen und Textinhalten verschachtelt. Das
                Wichtigste ist dabei, dass auf die korrekte Reihenfolge bei der Verschachtelung geachtet wird. Die
                hierarchische Gliederung von XML-Dokumenten ergibt eine Art Baumdiagramm. Das Wurzelelement bildet
                logischerweise die Wurzel, die verschachtelten Elemente sind die Äste und Zweige und die Textinhalte die
                Blätter.
            </p>

            <img src="xml_hierarchische_gliederung.png" alt="XML - Hierarchische Gliederung"/>

            <p>
                Die Namen von Tags und Attributen dürfen aus Buchstaben und Ziffern sowie aus den folgenden
                Sonderzeichen bestehen: <code>_</code> (Unterstrich), <code>-</code> (Bindestrich) und <code>.</code>
                (Punkt). Das erste Zeichen darf keine Ziffer sein. Es wird zwischen Groß- und Kleinschreibung
                unterschieden.
            </p>
            <p>
                Jedes XML-Tag, das geöffnet wurde, muss auch wieder geschlossen werden, damit es ein XML-Element ergibt.
                In der Regel steht zwischen den beiden Tags Inhalt, der aus tiefer verschachtelten Tags oder aus
                einfachem Text bestehen kann. Mitunter kommt es jedoch vor, dass ein Element leer ist, also keinen
                weiteren Inhalt enthält. Beispiel:
            </p>

            <code-block lang="xml">
                &lt;cover file="simpsons_178.png" type="image/png"&gt;&lt;/cover&gt;
            </code-block>

            <p>
                Da alle erforderlichen Informationen über das Cover-Bild bereits in den Attributen stehen, benötigt das
                Element cover keinen verschachtelten Inhalt. In XML gibt es hierfür auch eine Kurzschreibweise. Das
                <code>cover</code>-Element kann entsprechend dieser Syntax auch folgendermaßen geschrieben werden:
            </p>

            <code-block lang="xml">
                &lt;cover file="simpsons_178.png" type="image/png" /&gt;
            </code-block>

            <p>
                Der Slash am Ende des Tags ersetzt das vollständige schließende Tag. Das Leerzeichen vor dem End-Slash
                ist nach der eigentlichen XML-Syntax nicht erforderlich.
            </p>

            <chapter title="Benennung der XML-Elemente" id="xml-aufbau-elemente-benennung">
                <p>
                    Folgende <strong>Regeln</strong> gelten für die Namensgebung von XML-Elementen:
                </p>

                <list>
                    <li>
                        Elementnamen sind case-sensitive.
                    </li>
                    <li>
                        Elementnamen müssen mit einem Buchstaben oder Unterstrich beginnen.
                    </li>
                    <li>
                        Es gibt keine reservierten Wörter bis auf XML, somit dürfen Elementnamen nicht mit XML wie "xml", "XML", "Xml" usw. beginnen.
                    </li>
                    <li>
                        Elementnamen können Buchstaben, Zahlen, Bindestriche, Unterstriche, und Punkte enthalten.
                    </li>
                </list>

                <p>
                    Es gelten folgende <strong>Best Practices</strong> bei der Benennung von XML-Elementen:
                </p>

                <list>
                    <li>
                        Elementnamen sollen beschreibend sein wie <code>&lt;person&gt;</code>,
                        <code>&lt;firstname&gt;</code>, <code>&lt;lastname&gt;</code>.
                    </li>
                    <li>
                        Elementnamen sollten kurz und simpel sein wie <code>&lt;book_title&gt;</code> statt
                        <code>&lt;the_title_of_the_book&gt;</code>.
                    </li>
                    <li>
                        Bindestriche sollten vermieden werden, da manche Software beim Beispiel
                        <code>&lt;first-name&gt;</code> versucht name von first zu subtrahieren.
                    </li>
                    <li>
                        Punkte sollten vermieden werden, da manche Software denkt, dass beim Beispiel
                        <code>&lt;first.name&gt;</code> name eine Eigenschaft des Objekts first ist.
                    </li>
                    <li>
                        Doppelpunkte dürfen nicht verwendet werden, da diese für Namespaces reserviert sind.
                    </li>
                </list>

                <p>
                    Für XML gibt es mehrere Naming Conventions. Wichtig ist, dass man bei der Namensgebung konsistent
                    bleibt.
                </p>

                <table>
                    <tr>
                        <td>Style</td>
                        <td>Beispiel</td>
                        <td>Beschreibung</td>
                    </tr>
                    <tr>
                        <td>Lower case</td>
                        <td><code>&lt;firstname&gt;</code></td>
                        <td>
                            Alle Buchstaben werden kleingeschrieben.
                        </td>
                    </tr>
                    <tr>
                        <td>Upper case</td>
                        <td><code>&lt;FIRSTNAME&gt;</code></td>
                        <td>
                            Alle Buchstaben werden großgeschrieben.
                        </td>
                    </tr>
                    <tr>
                        <td>Snake case</td>
                        <td><code>&lt;first_name&gt;</code></td>
                        <td>
                            Mit Unterstrich werden Wörter getrennt (wird üblicherweise in SQL-Datenbanken verwendet)
                        </td>
                    </tr>
                    <tr>
                        <td>Pascal case</td>
                        <td><code>&lt;FirstName&gt;</code></td>
                        <td>
                            Der erste Buchstabe von jedem Wort wird großgeschrieben (wird üblicherweise in C verwendet)
                        </td>
                    </tr>
                    <tr>
                        <td>Camel case</td>
                        <td><code>&lt;firstName&gt;</code></td>
                        <td>
                            Der erste Buchstabe von jedem Wort (bis auf dem ersten Wort) wird großgeschrieben (wird
                            üblicherweise in JavaScript verwendet).
                        </td>
                    </tr>
                </table>
            </chapter>
        </chapter>

        <chapter title="XML Attribute" id="xml-aufbau-attribute">
            <p>
                Attribute stehen nur beim öffnenden Tag und werden beim schließenden niemals wiederholt. Die Form ist
                stets <code>attributname="attributwert"</code> oder <code>attributname='attributwert'</code>. Die
                doppelten oder einfachen Anführungszeichen sind zwingend erforderlich. Werden einfache Anführungszeichen
                verwendet, dann können im Wert auch doppelte Anführungszeichen verwendet werden. Zwischen dem
                Attributnamen, dem Gleichheitszeichen und dem öffnenden Anführungszeichen ist kein Abstand erlaubt,
                während mehrere Attribute durch Whitespace voneinander getrennt werden, genau wie Tag-Name und Attribut.
                Allgemein werden Attribute häufig verwendet um Ordnungskriterien oder Metainformationen für Elemente
                anzugeben. Allerdings ergäbe sich kein Unterschied im Informationsgehalt des Dokuments bei folgendem
                Beispiel:
            </p>

            <code-block lang="xml">
                &lt;comic language="en-US"&gt;
                    ...
                &lt;/comic&gt;
            </code-block>

            <code-block lang="xml">
                &lt;comic&gt;
                    &lt;language&gt;en-US&lt;/language&gt;
                    ...
                &lt;/comic&gt;
            </code-block>

            <warning>
                Attribute sind nur für Informationen geeignet, die nur einmal pro Element vorkommen. Es können nicht
                zwei Attribute gleichen Namens in ein und demselben Tag verwendet werden. Außerdem ist ein Attribut
                naturgemäß nicht für mehrgliedrige Angaben geeignet, die eigentlich verschachtelt werden müssen.
            </warning>
        </chapter>

        <chapter title="Entity-Referenzen" id="xml-aufbau-entityreferenzen">
            <p>
                Einige Zeichen sind in XML-Dokumenten nicht zulässig und müssen durch spezielle Escape-Sequenzen ersetzt
                werden, die als Entity-Referenzen bezeichnet werden. Eine Entity-Referenz beginnt mit einem
                <code>&amp;</code>-Zeichen, darauf folgen ein spezieller Code und am Ende ein Semikolon.
            </p>

            <table>
                <tr>
                    <td>Zeichen</td>
                    <td>Entity-Referenz</td>
                    <td>Bedeutung</td>
                </tr>
                <tr>
                    <td><code>&lt;</code></td>
                    <td><code>&amp;lt;</code></td>
                    <td>less than (kleiner als)</td>
                </tr>
                <tr>
                    <td><code>&gt;</code></td>
                    <td><code>&amp;gt;</code></td>
                    <td>greater than (größer als)</td>
                </tr>
                <tr>
                    <td><code>&amp;</code></td>
                    <td><code>&amp;amp;</code></td>
                    <td>Amperstand (and per se and)</td>
                </tr>
                <tr>
                    <td><code>&apos;</code></td>
                    <td><code>&amp;apos;</code></td>
                    <td>Apostroph</td>
                </tr>
                <tr>
                    <td><code>&quot;</code></td>
                    <td><code>&amp;quot;</code></td>
                    <td>quotation mark (Anführungszeichen)</td>
                </tr>
            </table>

            <p>
                All diese Zeichen haben im XML-Code eine spezielle Bedeutung. Neben diesen vorgefertigten
                Entity-Referenzen können in XML auch beliebige Unicode-Zeichen numerisch angegeben werden. Die Syntax
                ist entweder <code>&amp;#Dezimalcode;</code> oder <code>&amp;#xHexadezimalcode;</code>. Beispielsweise
                kann ein Registered-Trademark-Zeichen <code>®</code> durch die Zeichenfolge <code>&amp;#174;</code>
                (dezimal) oder <code>&amp;#xAE;</code> (hexadezimal) erzeugt werden. Eigene Entity's können innerhalb
                von DTDs definiert und innerhalb der Dokumente darauf referenziert werden. Dies ermöglicht den schnellen
                Zugriff auf häufig benötigte Sonderzeichen oder sogar XML-Codeblöcke.
            </p>
        </chapter>

        <chapter title="CDATA-Abschnitte" id="xml-aufbau-cdata">
            <p>
                Der normale Text in XML-Dokumenten besteht aus sogenannten PCDATA-Abschnitten. PCDATA steht für parsed
                character data. Dies bedeutet, dass einige Sonderzeichen innerhalb des Textes gemäß ihrer speziellen
                XML-Bedeutung behandelt werden – es sei denn, es werden Entity-Referenzen verwendet. In einigen Fällen
                können Entity-Referenzen aber sehr störend sein. Im folgenden Beispiel wird XML-Code in XML dargestellt,
                welcher durch die Häufung von Entity-Referenzen absolut unleserlich wird:
            </p>

            <code-block lang="xml">
                &lt;codeblock&gt;
                    &amp;lt;cover file=&quot;simpsons_178.png&quot; type=&quot;image/png&quot; /&amp;gt;
                &lt;/codeblock&gt;
            </code-block>

            <p>

            </p>

            <code-block lang="xml">
                &lt;codeblock&gt;
                    &lt;![CDATA[  &lt;cover file="simpsons_178.png"  type="image/png" /&gt;]]&gt;
                &lt;/codeblock&gt;
            </code-block>

            <p>
                Es versteht sich von selbst, dass die Zeichenfolge <code>]]&gt;</code> innerhalb eines CDATA-Blocks
                unzulässig ist – schließlich beendet sie ebendiesen Block. Genau deshalb wurde eine so unwahrscheinliche
                Zeichensequenz gewählt.
            </p>
        </chapter>

        <chapter title="Kommentare" id="xml-aufbau-kommentare">
            <p>
                XML-Dokumente können auch Kommentare enthalten. Diese werden naturgemäß ignoriert und dienen der
                Übersicht im Dokument oder können zusätzliche Erläuterungen enthalten. Ein Kommentar wird durch die
                Zeichenfolge <code>&lt;!--</code> eingeleitet und endet mit <code>--&gt;</code>. Kommentare können sich
                über beliebig viele Zeilen erstrecken.
            </p>

            <code-block lang="xml">
                <![CDATA[
                    <authors>
                        <author role="Writer">Brian Michael Bendis</author>
                        <author role="Pencils">Mark Bagley</author>
                        <!-- An dieser Stelle fehlen Inks, Colors und Letters -->
                    </authors>
                ]]>
            </code-block>

            <warning>
                Werden Kommentare genutzt, um einen unerwünschten Bereich des XML-Dokuments vorübergehend zu
                deaktivieren, muss darauf geachtet werden, dass der Block selbst keine Kommentare enthält, denn beim
                ersten Auftreten der Sequenz <code>--&gt;</code> ist alles Weitere kein Kommentar mehr, und das nächste
                <code>--&gt;</code> gilt wegen des alleinstehenden, nicht als Entity-Sequenz geschriebenen
                <code>&gt;</code> sogar als Fehler.
            </warning>
        </chapter>
    </chapter>

    <chapter title="Namespaces (Namensräume)" id="namespaces">
        <p>
            Da in XML-Dokumenten mehrere Dokumenttypen vermischt werden können, wurden Namensräume (= Namespaces)
            eingeführt, die die Unterscheidung von Elementen aus verschiedenen DTDs zulassen. Der Standardnamensraum
            eines Dokuments zeichnet sich dadurch aus, dass seine Elemente ohne spezielles Präfix verwendet werden
            können. Werden weitere Namensräume eingebunden, wird deren Elementen ein Namensraumpräfix vorangestellt, das
            durch einen Doppelpunkt vom eigentlichen Elementnamen getrennt wird. Namensräume werden mithilfe von
            <code>xmlns</code>-Angaben innerhalb eines Elements in das Dokument eingebunden. In der Regel stehen sie im
            Wurzelelement. Der Standardnamensraum wird einfach als <code>xmlns</code> bezeichnet während zusätzliche
            Namensräume mit <code>xmlns:namensraum</code> angegeben werden. Unter den angegebenen URLs muss sich kein
            spezielles Dokument befinden, das den Namensraum definiert – allerdings ist es üblich, dort eine kurze
            Beschreibung des Namensraums im HTML-Format abzulegen. Wichtig ist nur, dass verschiedene Namensraumangaben
            auch unterschiedliche URLs verwenden.
        </p>

        <code-block lang="xml">
            <![CDATA[
            <comics xmlns="http://api.webpage.com/dtds/comics.dtd"
                    xmlns:html="http://www.w3.org/1999/xhtml">
                <comic language="en-US">
                    <publisher>Marvel</publisher>
                    <series>Ultimate Spider-Man</series>
                    <format>Trade Paperback</format>
                    <issue original="1-13">1</issue>
                    <title>Ultimate Spider-Man</title>
                    <subtitle>Ultimate Collection</subtitle>
                    <authors>
                        <author role="Writer">Brian Michael Bendis</author>
                        <author role="Pencils">Mark Bagley</author>
                    </authors>
                    <summary>
                        <html:p>
                            Der erste Band der Sammelausgabe von
                            <html:i>Ultimate Spider-Man</html:i> beschreibt, wie
                            der Schüler <html:b>Peter Parker</html:b> zum Superhelden
                            <html:b>Spider-Man</html:b> wird und seine ersten Abenteuer
                            erlebt.
                        </html:p>
                    </summary>
                    <price currency="USD">24.99</price>
                </comic>
            </comics>
            ]]>
        </code-block>
    </chapter>

    <chapter title="Wohlgeformtheit" id="wohlgeformtheit">
        <p>
            Jedes XML-Dokument muss eine Reihe formaler Regeln erfüllen, um wohlgeformt zu sein. XML-Dateien, die diesen
            Regeln nicht genügen, werden von XML-Parsern in Anwendungen und Programmiersprachen nicht verarbeitet,
            sondern erzeugen Fehlermeldungen.
        </p>
        
        <list>
            <li>
                Ein XML-Dokument benötigt genau ein Wurzelelement: Ein bestimmtes Element muss alle anderen Elemente und
                Textinhalte umschließen. Alle Elemente müssen korrekt ineinander verschachtelt werden; das zuletzt
                geöffnete Element wird als Erstes wieder geschlossen.
            </li>
            <li>
                Jedes Element besteht aus einem öffnenden und einem schließenden Tag; »Einfach-Tags« wie in klassischem
                HTML gibt es nicht. Für leere Tags existiert die spezielle Kurzfassung mit dem End-Slash.
            </li>
            <li>
                Attribute haben die Form <code>name="wert"</code>. Der Wert muss stets in Anführungszeichen stehen.
            </li>
            <li>
                Die Namen von Elementen und Attributen dürfen nur Buchstaben, Ziffern, Unterstriche, Bindestriche und
                Punkte enthalten. Es wird zwischen Groß- und Kleinschreibung unterschieden. Das erste Zeichen darf keine
                Ziffer sein.
            </li>
            <li>
                Bestimmte Zeichen sind in XML-Dokumenten nicht zulässig: <code>&lt;</code>, <code>&gt;</code>,
                <code>&amp;</code>, <code>&quot;</code> und <code>&apos;</code> müssen durch die Entity-Referenzen
                <code>&amp;lt;</code>, <code>&amp;gt;</code>, <code>&amp;amp;</code>, <code>&amp;quot;</code>
                beziehungsweise <code>&amp;apos;</code> ersetzt werden. Die Definition weiterer Entity-Referenzen ist
                zulässig, aber sie dürfen nicht undefiniert verwendet werden.
            </li>
            <li>
                CDATA-Blöcke ermöglichen die beliebige Verwendung der Sonderzeichen, die normalerweise durch
                Entity-Referenzen ersetzt werden müssen. Ein CDATA-Abschnitt steht zwischen
                <code>&lt;![CDATA[ und ]]&gt;</code>.
            </li>
        </list>
    </chapter>

    <chapter title="Quellen" id="quellen">
    </chapter>
</topic>