<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
        SYSTEM "https://resources.jetbrains.com/writerside/1.0/xhtml-entities.dtd">
<topic xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="https://resources.jetbrains.com/writerside/1.0/topic.v2.xsd"
       title="Workflows" id="swe-vcs-git-workflows" help-id="vcs-git-workflows">
    <show-structure for="chapter,procedure" depth="2"/>
    
    <chapter title="Grundlegendes" id="grundlagen">
        <chapter title="Anweisungen für das Team" id="grundlagen-team">
            <p>
                Um alleine oder vor allem in einem Team, erfolgreich und produktiv mit Git zu arbeiten gibt es gewisse
                Abläufe: sog. Workflows. Welche dieser Abläufe für das eigene Team der richtige ist, hängt neben dem
                Produkt auch ein wenig vom persönlichen Geschmack ab.
            </p>
            <p>
                Es ist sinnvoll zum Projektstart mit dem Team gewisse Regeln für die Zusammenarbeit am Quellcode
                festzulegen. Die festgelegten Anweisungen müssen folglich in physischer oder digitaler Form für jedes
                Teammitglied in greifbarer nähe sein.
            </p>
            <p>
                Je nach Teamgröße kann es auch sinnvoll sein, einen Git-Tutor zu bestimmen, der als Ansprechpartner bei
                Problemen fungiert.
            </p>
        </chapter>

        <chapter title="Welcher Workflow ist der Richtige?" id="grundlagen-vergleich">
            <p>
                Für die Entscheidung welcher Workflow der Richtige ist, sind folgende Faktoren wichtig:
            </p>

            <list>
                <li>
                    <b>Erfahrung der Teammitglieder</b>: Haben alle Mitglieder im Team bereits eingehende Erfahrung mit
                    Git, so kann jeder Beliebige Workflow gewählt werden. Für Git-Einsteiger helfen grafische
                    Oberflächen wie GitHub oder GitLab sie bieten enorm. Außerdem kann die zusätzliche Dokumentation für
                    den Merge/Pull-Request-Workflow sehr hilfreich sein.
                </li>
                <li>
                    <b>Größe des Teams</b>: Trunk-based Development funktioniert vor allem mit kleineren Teams gut. Die
                    anderen Workflows sollten auch bei großen Teams gut funktionieren.
                </li>
                <li>
                    <b>Art der Software</b>: Wenn es bei Ihrem Projekt notwendig ist, mehrere stabile Versionen der
                    Software in Produktion zu betreiben, ist ein Workflow mit parallelen Branches eine gute Wahl. Trotz
                    der erhöhten Komplexität von GitFlow kann schnell zu einer Version gesprungen und dort Bugfixes
                    eingespielt werden. Gibt es immer nur eine Version in Produktion, wie die z. B. bei einer
                    Onlineplattform der Fall ist, kann ein agiler Arbeitsablauf wie das Trunk-based Development mehr
                    Spaß machen und zu höherer Produktivität führen.
                </li>
                <li>
                    <b>Verfügbarkeit von Infrastruktur</b>: Während manche Arbeitsabläufe ganz ohne zusätzliche Software
                    außer Git auskommen, ist es bei anderen notwendig, weitere Programme zu verwenden. Trunk-based
                    Development kann ohne CI-Pipeline nicht richtig funktionieren. Die Pipelines müssen einerseits
                    konfiguriert werden und andererseits auf einer Computer-Infrastruktur ausgeführt werden. Beim
                    Pull/Merge-Request-Workflow benötigt es eine Git-Plattform, die Kosten verursacht.
                </li>
            </list>
        </chapter>
    </chapter>

    <chapter title="Das Ein-Mann-Team und die Solo-Entwicklung" id="solo">
        <p>
            Sobald ein Projekt den Hello-World-Status verlässt ist es schon sinnvoll, dass eine Versionsverwaltung
            eingesetzt wird. Die Software dazu ist gratis und der Mehraufwand bei den Arbeitsabläufen ist minimal.
        </p>
        <p>
            Bei der Solo-Entwicklung findet de Entwicklung nur am Master-Branch statt. Es werden von Zeit zu Zeit
            Commits, welche auch als eine Art Dokumentation des Codes bzw. der verrichteten Arbeit dienen, erstellt.
            Folglich werden immer wieder wird auf dem Remote, das als Backup für den Quellcode dient, gepusht.
        </p>
        <p>
            Bildet sich im Zuge der Entwicklung eine neue Idee, die ausprobiert werden soll, so kann es sinnvoll sein,
            deren Entwicklung auf einen neuen Branch zu verlagern. Wird die Weiterentwicklung dieser Idee aufgrund eines
            Problems unterbrochen, so kann zu einem späteren Zeitpunkt immer noch darauf zugegriffen werden oder Code in
            einer anderen Form verwendet werden.
        </p>

        <chapter title="Fazit" id="solo-fazit">
            <p><b>Vorteile</b></p>

            <list>
                <li>Dokumentation der Arbeit</li>
                <li>Zurückspringen zu früheren Versionen</li>
                <li>einfaches Ausprobieren von Ideen mit Branches</li>
                <li>Backup bei Verwendung von Remotes</li>
            </list>

            <p><b>Nachteile</b></p>

            <list>
                <li>erhöhter Arbeitsaufwand durch Commits/Pushes</li>
            </list>
        </chapter>
    </chapter>

    <chapter title="Feature-Branches für Teams" id="featurebranching">
        <chapter title="Neues Feature, neuer Branch" id="featurebranching-neu">
            <p>
                Mit Feature-Branches kann das Konfliktpotential reduziert werden, indem Arbeitspakete auf Personen
                aufgeteilt werden und die Entwicklung jeweils in einem eigenen Branch, dem Feature-Branch, stattfindet.
                Schreibzugriffe auf den Master-Branch werden dadurch seltener, was zu weniger Merges und einer
                unkomplizierten Entwicklung am Feature-Branch führt. Im Extremfall darf nur eine Person auf den Branch
                schreiben, alle anderen im Team entwickeln in ihren Feature-Branches und schicken, sobald sie damit
                fertig sind, einen Merge/Pull-Request an die berechtigte Person.
            </p>

            <chapter title="Code-Review" id="featurebranching-neu-codereview">
                <p>
                    Code-Reviews sind in agilen Softwareentwicklungsprozessen oft ein integrierter Bestandteil. Mit
                    Feature-Branches ist es sehr einfach die Änderungen zu begutachten. Treten im Code-Review noch
                    Probleme auf, so können diese vor dem Merge mit dem master noch durch weitere Commits behoben
                    werden.
                </p>
            </chapter>

            <chapter title="Merge" id="featurebranching-neu-merge">
                <p>
                    Da die Merge-Vorgänge auf dem Master-Branch immer Fast-forward-Merges sind, erscheint der
                    eigentliche Merge nicht mehr in der Git-History. Wird Wert darauf gelegt, dass die Merges nicht
                    verloren gehen, muss git merge mit der Option <code>--no-ff</code> aufgerufen werde, um einen
                    expliziten Commit zu erzwingen. Hierbei ist anzumerken, dass die Git-History ohne Merge-Commits
                    aufgeräumter beleibt.
                </p>
            </chapter>

            <chapter title="Rebase" id="featurebranching-neu-rebase">
                <p>
                    Die Grundregel für Rebasing lautet, dass Rebases nie auf einen schon hochgeladenen öffentlichen
                    Branch angewendet werden darf. Daher sollte das Rebasing nur angewendet werden, wenn der
                    Feature-Zweig noch nicht mit git push in ein Remote Repository hochgeladen wurde. Die Commits am
                    Feature-Branch werden beim Rebasing vom master neu geschrieben.
                </p>
            </chapter>
        </chapter>

        <chapter title="best practice" id="featurebranching-bestpractice">
            <p>
                Mit vielen kleinen, sog. Mini-Feature-Branches, funktioniert der Workflow ganz unkompliziert. Während
                der Entwicklung kann der Feature-Branch mit dem Master-Branch auch immer wieder gemergt oder gerebaset
                werden, damit der abschließende Merge in den Master nicht zu kompliziert wird.
            </p>
            <p>
                Wenn im Laufe des Projektes Funktionen entwickelt werden, die auch von anderen Entwicklern gebraucht
                werden, kann es hier zu parallelen Entwicklungen kommen. Das lässt sich mit guter Kommunikation
                verhindern, aber es bleibt ein Problem, das bei diesem Workflow bedacht werden muss.
            </p>
        </chapter>

        <chapter title="Fazit" id="featurebranching-fazit">
            <p><b>Vorteile</b></p>

            <list>
                <li>ungestörte Entwicklung von neuen Funktionen</li>
                <li>Code-Reviews vor dem Merge des Feature-Branches</li>
                <li>übersichtliche Git-History</li>
                <li>Master-Branch bleibt stabil</li>
            </list>

            <p><b>Nachteile</b></p>

            <list>
                <li>mögliche Codeduplizierung in gemeinsamen Bibliotheken</li>
                <li>zu komplizierte Merges wegen zu langer Entwicklung</li>
            </list>
        </chapter>
    </chapter>

    <chapter title="Merge/Pull-Requests" id="mergepull">
        <chapter title="Das Feature-Branch-Modell der Remotes" id="mergepull-featurebranch">
            <p>
                Aufbauend auf das Feature-Branch-Modell haben die großen Git-Plattformen den Arbeitsablauf erweitert und
                fügten Merge/Pull-Requests als festen Bestandteil ein. Die wesentliche Erweiterung im Vergleich zum
                Feature-Branch-Workflow im vorangegangenen Kapitel stellt der verpflichtende Review-Prozess dar: Beim
                Pushen auf das Remote Repository erhält der Entwickler eine mit remote: gekennzeichnete Antwort. Zudem
                lässt sich dieser Workflow nur mit entsprechenden Git Servern umsetzen.
            </p>
        </chapter>

        <chapter title="Forks" id="mergepull-forks">
            <p>
                In Kombination mit Merge/Pull-Requests kann auch einen Workflow eingeführt werden, bei dem alle
                Entwickler eigene Repositorys verwalten, auf die nur sie selbst Schreibzugriff haben. Diese Technik
                kommt der ursprünglichen Idee Torvalds sehr nahe. Da es GitHub damals noch nicht gab, mussten Entwickler
                eigene Git-Server betreiben, von denen andere Entwickler wiederum dann pullen konnten. Dafür ist der in
                Git integrierte Server <b>git deamon</b> gedacht.
            </p>
            <p>
                Forks mit Pull/Merge-Requests sind ein äußerst praktischer Arbeitsablauf für gelegentliche Beiträge von
                unterschiedlichen Personen bei fremden Projekten.
            </p>
        </chapter>

        <chapter title="Fazit" id="mergepull-fazit">
            <p><b>Vorteile</b></p>

            <list>
                <li>Code-Review, bevor auf master gemerged wird</li>
                <li>gute Dokumentation der Arbeitsabläufe</li>
                <li>stabiler Master-Branch</li>
            </list>

            <p><b>Nachteile</b></p>

            <list>
                <li>parallele Branches bei zu langsamen Code-Reviews</li>
            </list>
        </chapter>
    </chapter>

    <chapter title="Gitflow (Long-Running Branches)" id="gitflow">

        <chapter title="Der Gitflow-Workflow" id="gitflow-workflow">

            <chapter title="Master, Develop, Feature" id="gitflow-workflow-branches">
            </chapter>

            <chapter title="Hot Bugfix" id="gitflow-workflow-hotfix">
            </chapter>

            <chapter title="Bugfix im Develop-Branch" id="gitflow-workflow-bugfix">
            </chapter>

            <chapter title="Release-Branches" id="gitflow-workflow-release">
            </chapter>
        </chapter>

        <chapter title="Fazit" id="gitflow-fazit">
        </chapter>
    </chapter>

    <chapter title="Trunk-based Development" id="tbd">

        <chapter title="Master-based Development" id="tbd-master">

            <chapter title="Grundregeln" id="tbd-master-grundregeln">
            </chapter>

            <chapter title="Konzept" id="tbd-master-konzept">
            </chapter>
        </chapter>

        <chapter title="Continuous Integration" id="tbd-ci">

            <chapter title="Release-ready" id="tbd-ci-release">
            </chapter>
        </chapter>

        <chapter title="Continuous Development" id="tbd-cd">

            <chapter title="Feature-Flags / Featured-Toggles" id="tbd-cd-featureflags">
            </chapter>
        </chapter>

        <chapter title="Achtung!" id="tbd-achtung">
        </chapter>

        <chapter title="Fazit" id="tbd-fazit">
        </chapter>
    </chapter>

    <chapter title="Quellen" id="quellen">
        <tip>
            <b>(BUCH)</b>
            978-3836271868, "Git - Projektverwaltung für Entwickler und DevOps-Teams", Bernd Öggl &amp; Michael Kofler, 2020
        </tip>
    </chapter>
</topic>