<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
        SYSTEM "https://resources.jetbrains.com/writerside/1.0/xhtml-entities.dtd">
<topic xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="https://resources.jetbrains.com/writerside/1.0/topic.v2.xsd"
       title="Commits" id="swe-vcs-git-commits">
    <show-structure for="chapter,procedure" depth="2"/>

    <chapter title="Grundlagen" id="grundlagen">
        <chapter title="Der aktuelle Zustandsspeicher: Staging Area" id="grundlagen-stage">
            <p>
                Bevor Änderungen dauerhaft ins Repository gespeichert werden, muss ausgewählt werden welche Änderungen
                berücksichtigt werden.
            </p>

            <note>
                <p><b>Beispiel</b></p>

                <p>
                    Es wurden drei neue Dateien erstellt. Zwei Dateien enthalten Code und sollen Teil des Projekts sein.
                    Die dritte Datei enthält aber persönliche Anmerkungen und soll nicht in das Repository übernommen
                    werden.
                </p>
            </note>

            <p>
                Für diese Differenzierung (siehe Beispiel) sieht Git die <b>Staging Area</b> vor (oft kurz <b>Stage</b>,
                <b>Index</b> oder <b>Cache</b> genannt). Der Stage-Bereich umfasst den gesamten aktiven Zweig inklusive
                aller Änderungen, die beim nächsten Commit dauerhaft gespeichert werden sollen. Um eine Datei im
                gegenwärtigen Zustand in den Stage-Bereich zu befördern, wird der Befehl
                <code>git add &lt;file&gt;</code> oder das gleichwertige Kommando <code>git stage &lt;file&gt;</code>
                ausgeführt.
            </p>
        </chapter>

        <chapter title="Der letzte Commit: HEAD" id="grundlagen-letzter-commit">
            <p>
                Mit jedem Commit werden die im Stage-Bereich vorgemerkten Änderungen dauerhaft in der
                Repository-Datenbank gespeichert. Der letzte (aktuellste) Commit im aktuellen Zweig wird
                <code>HEAD</code> genannt.
            </p>
            <p>
                Zu beachten ist, dass Git zwischen <code>Head</code> und <code>HEAD</code> differenziert: Für jeden
                Zweig gibt es einen aktuellsten Commit, also einen <code>Head</code>. Der <code>HEAD</code> mit lauter
                Großbuchstaben bezeichnet dagegen explizit den aktiven Zweig, der gerade bearbeitet wird.
            </p>
        </chapter>

        <chapter title="Sauber einen Zweig wechseln: Checkout" id="grundlagen-checkout">
            <p>
                Mit einem <b>Checkout</b> werden die aktuellen Dateien des Projektverzeichnisses durch die des Zweiges
                ersetzt. Dabei können neue Dateien hinzukommen, vorhandene Dateien sich ändern und andere können
                verschwinden. Normalerweise wird vor dem Wechsel eines Zweiges ein Commit ausgeführt. Sind die
                Änderungen aber noch nicht committauglich, so wird eine Möglichkeit benötigt die Änderungen
                vorübergehend zu speichern. Genau dazu dient der Stash, eine Art Stauraum für noch nicht 
                committauglichen Code.
            </p>
        </chapter>

        <chapter title="Commit Intern" id="grundlagen-intern">
            <p>
                Der Befehl <code>git add</code> verschiebt die Änderungen vom Projektverzeichnis (Workspace) im
                Stage-Bereich. Durch einen Commit werden die Änderungen dauerhaft ins Repository aufgenommen. Aus sicht
                von Commit kann eine Datei also gleichzeitig drei Zustände habe:
            </p>
            
            <list>
                <li>den aktuellen Zustand im Projektverzeichnis</li>
                <li>den Zustand im Stage-Bereich (staged)</li>
                <li>den Zustand im Repository (committed)</li>
            </list>
            
            <p>
                Bei einem Commit entstehen in der Git-Datenbank mehrere Objekte:
            </p>
            
            <list>
                <li>
                    Das Commit-Objekt fasst die Metadaten zusammen. (Wer? Wann?) Es enthält die Commit-Message, einen
                    Verweis auf den vorigen Commit im gleichen Branch (parent) und einen Verweis auf ein Tree-Objekt.
                </li>
                <li>
                    Das Tree-Objekt verweist auf die Blobs aller Dateien des aktiven Zweigs (und nicht nur auf
                    neue/geänderte Dateien). Mit der Kombination aus Commit- und Tree-Objekt kann unkompliziert auf
                    sämtliche versionierte Dateien des betreffenden Zweigs zugegriffen werden. (Der Parent-Verweis ist
                    nur von Interesse, wenn man an historischen Informationen interessiert ist, wie es zum aktuellen
                    Zustand gekommen ist.)
                </li>
                <li>
                    Für jede versionierte Datei gibt es ein Blob (Binary Large Object) mit dem Inhalt der Datei.
                </li>
            </list>

            <img src="swe-vcs-git-commit-intern.jpg" alt="Commit"/>
        </chapter>
    </chapter>

    <chapter title="Referenzen auf Commits" id="referenzen">
        <p>
            Bei einigen <code>git</code>-Kommandos verweist ein Parameter auf einen Commit oder ein anderes Objekt im
            Git-Repository. Die Git-Nomenklatur spricht in diesem Zusammenhang von <emphasis>Revisionen</emphasis>, also
            von Zuständen oder Versionen eines Objekts im Git-Repository.
        </p>
        <p>
            Hashcodes von Commits, welche mittels <code>git log --online</code> ermittelt werden können, bieten die
            einfachste Form von Referenzen. Normalerweise reicht die Nennung der ersten Zeichen des hexadezimalen
            Objekts – sofern es nicht zwei Objekte gibt, deren Hashcode mit den gleichen Zeichen beginnt. Mit den ersten
            7 Zeichen ist die Wahrscheinlichkeit auf Duplikate sehr gering.
        </p>
        <p>
            Computern fällt das Hantieren mit Hashcodes leichter als Menschen. Deswegen bietet Git eine Menge anderer
            Optionen, um auf eine bestimmte Revision eines Objekts hinzuweisen. Eine davon sind
            <a href="swe-vcs-git-tags.topic">Tags</a>, welche für ganz wichtige Commits wie beispielsweise Releases
            verwendet werden.
        </p>
        <p>
            Andere Möglichkeiten sind:
        </p>

        <list>
            <li>
                <code>HEAD@{4}</code> bezeichnet den Commit vier lokale Aktionen vor dem letzten Commit. Die
                Schreibweise <code>{date}</code> bezieht sich auf das Referenz-Log (Reflog), als Aktionen kommen neben
                Commits auch Pull-, Push- und Checkout-Kommandos infrage.
            </li>
            <li>
                <code>develop@{2 weeks ago}</code> steht für den letzten Zustand im Zweig develop, der zumindest zwei
                Wochen alt ist. Auch diese Schreibweise bezieht sich auf das Reflog.
            </li>
            <li>
                <code>HEAD~2</code> verweist auf den Vor-Vorgänger des aktuellen Commits. Statt des Reflogs werden hier
                die Parent-Informationen der Commit-Objekte
            </li>
            <li>
                <code>@^2</code> bezeichnet den zweiten Elternteil den aktuellen Commit. (Bei Merge-Prozessen kann ein
                Commit mehrere Elternteile haben.) <code>@</code> ist dabei eine Kurzschreibweise für HEAD.
            </li>
        </list>

        <p>
            Alle Varianten gibt es in der <a href="https://git-scm.com/docs/gitrevisions">offiziellen Dokumentation</a>
            zu lesen, folglich werden die wichtigsten gelistet und genauer beschrieben.
        </p>

        <chapter title="Referenznamen (Refernames)" id="referenzen-refnames">
            <p>
                Refnames sind Namen, die in <path>.git/refs</path> verwendet werden, also Namen lokaler bzw. entfernter
                Zweige wie master oder <path>refs/remote/origin/develop</path>. Erlaubt ist außerdem <code>HEAD</code>
                zur Bezeichnung des aktuellsten Commits des aktuellen Zweigs. Je nach Kontext (z. B. während eines
                Merge-Prozesses) sind auch <path>FETCH_HEAD</path>, <path>MERGE_HEAD</path>, <path>ORIG_HEAD</path> und
                <path>CHERRY_PICK_HEAD</path> zulässige Namen. Das Zeichen <code>@</code> für sich ist eine
                Kurzschreibweise für <path>HEAD</path>.
            </p>

            <chapter title="Beispiele" id="referenzen-refnames-beispiele">
                <code-block lang="bash">
                    git show @
                </code-block>
                <code-block lang="bash">
                    git show HEAD
                </code-block>
                <code-block lang="bash">
                    git show master
                </code-block>
                <code-block lang="bash">
                    git show refs/heads/feature_xy
                </code-block>
                <code-block lang="bash">
                    git show refs/remotes/origin/develop
                </code-block>
            </chapter>
        </chapter>

        <chapter title="refname@{date}" id="referenzen-datum">
        </chapter>

        <chapter title="refname@{n}" id="referenzen-n">
        </chapter>

        <chapter title="Zugriff auf Vorgängerversionen" id="referenzen-last">

            <chapter title="Die Tildensyntax" id="referenzen-last-tilde">
            </chapter>

            <chapter title="Die Zirkumflexsyntax" id="referenzen-last-zirkumflex">
            </chapter>
        </chapter>

        <chapter title="Beispiele" id="referenzen-beispiele">
        </chapter>

        <chapter title="Referenzen auf Dateien" id="referenzen-dateien">
        </chapter>
    </chapter>

    <chapter title="Alte Version einer Datei anzeigen (git show)" id="gitshow">
    </chapter>

    <chapter title="Änderungen vergleichen (git diff)" id="gitdiff">
    </chapter>

    <chapter title="Änderungen rückgängig machen (git reset, restore)" id="rueckgaengig">

        <chapter title="Datei aus dem Stage-Bereich entfernen (git reset)" id="rueckgaengig-gitreset">
        </chapter>

        <chapter title="Den zuletzt durchgeführten Commit widerrufen (git restore)" id="rueckgaengig-gitrestore">
        </chapter>
    </chapter>

    <chapter title="Die letzten Commits widerrufen (git revert)" id="gitrevert">

        <chapter title="Einen Commit widerrufen" id="gitrevert-commit">
        </chapter>

        <chapter title="Mehrere Commits widerrufen" id="gitrevert-commits">
        </chapter>

        <chapter title="Commit-Message für Revert-Vorgänge zusammenfassen" id="gitrevert-zusammenfassen">
        </chapter>
    </chapter>

    <chapter title="Die letzten Commits aus dem Repository löschen (git reset)" id="gitreset">
    </chapter>

    <chapter title="Vorübergehend zu einem älteren Commit wechseln (git checkout)" id="gitckeckout">
    </chapter>

    <chapter title="Commit-Message ändern" id="commit-message-aendern">

        <chapter title="Commit-Massage des letzten Commits ändern" id="commit-message-aendern-letzter">
        </chapter>

        <chapter title="Commit-Message des letzten Commits in einem externen Repository ändern"
                 id="commit-message-aendern-extern">
        </chapter>
    </chapter>

    <chapter title="Quellen" id="quellen">
        <tip>
            <b>(BUCH)</b>
            978-3836271868, "Git - Projektverwaltung für Entwickler und DevOps-Teams", Bernd Öggl &amp; Michael Kofler, 2020
        </tip>
        <tip>
            <b>(WEBSEITE)</b>
            <a href="https://git-scm.com/docs/git-show" ignore-vars="true">
                https://git-scm.com/docs/git-show
            </a>, 2020-11-06 09:17
        </tip>
    </chapter>
</topic>