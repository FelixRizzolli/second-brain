<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
        SYSTEM "https://resources.jetbrains.com/writerside/1.0/xhtml-entities.dtd">
<topic xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="https://resources.jetbrains.com/writerside/1.0/topic.v2.xsd"
       title="Merge" id="swe-vcs-git-merge">
    <show-structure for="chapter,procedure" depth="2"/>

    <chapter title="Einführung" id="einfuehrung">
        <p>
            Der Merge-Befehl wird verwendet, um Zweige zusammenzuführen. Oftmals findet Git selbständig Lösungen für das
            Zusammenführen der Dateien. Zum Beispiel, wenn die Änderungen in unterschiedlichen Teilen einer Codedatei,
            oder gar unterschiedlichen Dateien erfolgen. Bei komplizierteren Fällen wird die Entscheidung jedoch dem
            Entwickler überlassen.
        </p>
        <p>
            Durch wiederholte Merge-Vorgänge entsteht oft eine unübersichtliche Struktur im lokalen Repository, bei der
            sich ständig Zweige öffnen und wieder schließen. Durch das sogenannte
            <a href="swe-vcs-git-rebase.topic">Rebasing</a> kann die Commit-Abfolge (die History) aufgeräumt und
            gewissermaßen begradigt werden.
        </p>
    </chapter>

    <chapter title="Zweige/Branches zusammenführen" id="merge">
        <p>
            Um die in enthaltenen Änderungen des newfeature Zweiges in master zu integrieren und den Zweig aufzulösen
            wird zuerst in den master-Zweig gewechselt und dort der Befehl <code>git merge</code> verwendet.
        </p>

        <code-block lang="bash">
            git checkout master
        </code-block>
        <code-block lang="bash">
            git merge newfeature
        </code-block>
        
        <p>
            Was danach passiert hängt stark von den Begleitumständen ab.
        </p>
        <p>
            Egal, von welcher Seite der Merge-Prozess gestartet wurde: Das Endergebnis in Ihrem Projektverzeichnis ist
            in beiden Fällen dasselbe! Dennoch ist es keineswegs egal, von welcher Seite der Merge-Prozess ausgeführt
            wird!
        </p>
        
        <list>
            <li>
                Wird vom Master-Branch aus der Feature-Branch mit dem Master-Branch zusammenführen, ändert sich der
                Master-Branch. Der Feature-Zweig bleibt, wie er ist.
            </li>
            <li>
                Wird hingegen vom Feature-Branch aus der Master-Zweig zum Feature-Zweig gemerged, ändert sich der
                Feature-Zweig. In diesem Fall bleibt der Master-Zweig unverändert.
            </li>
        </list>
        
        <p>
            In jedem Fall können beide Zweige weitergenutzt werden. Der Merge-Prozess »schließt« keinen Zweig. Wenn ein
            Zweig nicht mehr benötigt wird, muss er explizit mit <code>git branch -d</code> gelöscht werden.
        </p>
        
        <table>
            <tr>
                <td>Gewöhnlicher Merge</td>
                <td>
                    Sofern im newfeature-Branch andere Codeteile verändert wurden als die auf dem master-Branch, kann
                    Git die Änderungen selbstständig verarbeiten. Die durchgeführten Änderungen werden im Rahmen eines
                    Commits gespeichert, wobei automatisch ein Editor erscheint, in dem eine vorgegebene Commit-Message
                    bei Bedarf angepasst werden kann.
                </td>
            </tr>
            <tr>
                <td>Fast-forward Merge</td>
                <td>
                    Ein Sonderfall ist ein Merge-Prozess, bei dem der Basiszweig, seit der Aufspaltung in zwei Zweige,
                    unverändert geblieben ist. In diesem Fall ist kein »echter« Merge erforderlich. Vielmehr reicht es
                    aus, den Zeiger des Basiszweigs auf den letzten Commit zu stellen.
                </td>
            </tr>
            <tr>
                <td>Merge Konflikt</td>
                <td>
                    Bei einem Merge-Konflikt ist Git nicht in der Lage, die in den Zweigen durchgeführten Änderungen
                    zusammenzuführen. Der häufigste Grund besteht darin, dass bestimmte Zeilen des Codes in beiden
                    Zweigen unterschiedlich verändert wurden – z. B. ursprünglich <code>maxvalue=20</code>, aber
                    <code>maxvalue=10</code> in Commit C und <code>maxvalue=30</code> in Commit E. Gits Automatismen
                    versagen aber auch bei binären Dateien
                </td>
            </tr>
        </table>
    </chapter>

    <chapter title="Fast-forward-Merge" id="fastforward">
        <p>
            Angenommen nach dem Commit B des master-Zweiges wurde ein neuer Zweig new_feature erstellt. Dort wurden die
            Commits C und D durchgeführt. Am ursprünglichen Zweig (hier master) mussten in der Zwischenzeit keine
            Änderungen durchgeführt werden.
        </p>
        
        <img src="swe-vcs-git-merge-fastforward.jpg" alt="Fast-forward-Merge"/>

        <p>
            Wenn nun in den Master-Zweig gewechselt und <code>git merge new_feature</code> ausgeführt wird, ist gar kein
            richtiger Merge-Prozess erforderlich. Es reicht aus, den Zeiger des Master-Zweigs auf Commit D zu versetzen
            (fast forward). HEAD zeigt automatisch auf das Ende des aktuellen Zweigs, hier also ebenfalls auf Commit D.
            Unverändert verweist auch new_feature auf diesen Commit. Weil bei der Veränderung des Zeigers master
            keinerlei Änderung an den Git-Objekten erforderlich ist, kommt es beim Merge-Prozess zu keinem eigenen
            Commit. Dementsprechend entfällt auch die Eingabe einer Commit-Message. Der offensichtliche Vorteil eines
            Fast-forward-Merge-Prozesses ist dessen Einfachheit und Geschwindigkeit. Der Nachteil: Es ist später nicht
            mehr nachvollziehbar, dass die Commits C und D als Teil des Zweigs new_feature entstanden sind. Wenn Sie
            diese Intransparenz stört, können Sie git merge mit der Option <code>--no-ff</code> ausführen.
        </p>
        <p>
            Selbstverständlich bleiben auch nach einem Fast-forward-Merge beide Zweige erhalten. In beiden Zweigen kann
            die Entwicklung fortgesetzt werden, z. B. durch die neuen Commits E in master und F in new_feature.
        </p>
    </chapter>

    <chapter title="Octopus-Merge" id="octopus">
        <p>
            Der <code>git merge</code> Befehl kann sogar mehrere Zweige als Parameter aufnehmen. Dabei wird der aktuelle
            Zweig mit allen übergebenen Zweigen zusammengeführt. Dieses Verfahren wird <b>Octopus-Merge</b> genannt. Der
            einzige Vorteil eines Octopus-Merges im Vergleich zu mehreren Einzel-Merge-Prozessen besteht darin, dass es
            – wenn alles gut geht – nur einen Merge-Commit gibt.
        </p>
        <p>
            Schon ein gewöhnlicher Merge-Prozess, der zwei Zweige zusammenführt, kann genug Probleme verursachen. Je
            mehr Zweige im Spiel sind, desto diffiziler wird die Behebung der anfallenden Konflikte oder Unklarheiten.
        </p>
        <p>
            Wenn man die Git-Repository des Linux-Kernels durchsucht so kann man etliche Octopus-Merges finden, wobei
            einer beachtliche 65 Zweige zusammenführt.
        </p>
    </chapter>

    <chapter title="Merge Konflikte lösen" id="konflikte">

        <chapter title="Weniger Konflikte durch häufige Merge-Prozesse" id="konflikte-vermeiden">
        </chapter>

        <chapter title="Kollisionen im Code" id="konflikte-codekollisionen">
        </chapter>

        <chapter title="Merge-Tools" id="konflikte-tools">
        </chapter>

        <chapter title="Konflikte bei binären Dateien" id="konfilikte-binaere-dateien">
        </chapter>

        <chapter title="Merge-Abbruch und Undo" id="konflikte-abbruch">
        </chapter>

        <chapter title="Whitespace-Probleme" id="konflikte-whitespace">
        </chapter>

        <chapter title="Inhaltliche Merge-Konflikte" id="konflikte-inhalt">
        </chapter>

        <chapter title="MERGE-Dateien" id="konflikte-dateien">
        </chapter>
    </chapter>

    <chapter title="Merge für eine einzelne Datei" id="einzeldatei">

        <chapter title="Der Befehl git merge-file" id="einzeldatei-befehl">
        </chapter>

        <chapter title="Die einfachere Alternative" id="einzeldatei-alternative">
        </chapter>
    </chapter>

    <chapter title="Commit der letzten gemeinsamen Basis" id="merge-base">
    </chapter>

    <chapter title="Quellen" id="quellen">
        <tip>
            <b>(BUCH)</b>
            978-3836271868, "Git - Projektverwaltung für Entwickler und DevOps-Teams", Bernd Öggl &amp; Michael Kofler, 2020
        </tip>
    </chapter>
</topic>