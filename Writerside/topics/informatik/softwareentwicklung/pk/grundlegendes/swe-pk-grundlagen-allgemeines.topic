<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
        SYSTEM "https://resources.jetbrains.com/writerside/1.0/xhtml-entities.dtd">
<topic id="swe-pk-grundlagen-allgemeines"
       title="Allgemeines über die Programmierung"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="https://resources.jetbrains.com/writerside/1.0/topic.v2.xsd">
    <show-structure depth="2" for="chapter,procedure"/>

    <chapter id="geschichte" title="Geschichte zur Programmierung">
        <p>
            Erste Ideen, die mit dem heutigen Ansatz der Programmierung im weitestgehenden Sinne vergleichbar sind,
            stammen bereits aus dem 17. Jh. Als erste mechanische Rechenmaschine (1635) wird die sog. Rechenuhr des
            deutschen Mathematikers Wilhelm Schickard (1592-1635) bezeichnet. Den Aufzeichnungen zufolge sollte sie alle
            vier Grundrechenarten mit Zahlen bis zu einer Größe von einer Million beherrschen. Ob diese Maschine
            tatsächlich gebaut wurde, ist nicht klar. Möglich wäre es jedoch gemäß der Aufzeichnungen gewesen. Den
            gleichen Ansatz verfolgt die 1643 gebaute Pascaline des französischen Mathematikers Blaise Pascal
            (1623–1662). Aufgrund von Ungenauigkeiten in der Konstruktion produzierte die Maschine jedoch fehlerhafte
            Ergebnisse. Zu erwähnen ist in diesem Zusammenhang auch die Einführung des programmierbaren Webstuhls von
            Joseph-Marie Jacquard. Der Webstuhl wurde durch Lochstreifen gesteuert, d. h., das zu webende Muster wurde
            damit festgelegt. Die ersten Ideen zur Programmierung von Rechnern gehen zurück auf Charles Babbage
            (1791–1871). Er entwarf zwei Rechenmaschinen, die Difference Engine (1823) und die Analytical Engine (1834),
            die jedoch niemals fertiggestellt wurden. Die Operation, die ausgeführt werden sollte, war die Addition von
            27-stelligen Dezimalzahlen. Die Logik steckte ohne Programmiersprache in einfachen Maschinenkonstruktionen.
            Als Pionier auf dem Gebiet der Programmierung gilt Konrad Zuse (1910–1995). Konrad Zuse wurde am 22. Juni
            1910 in Berlin geboren. Er hatte die Vision, stupide Rechenarbeiten auf eine Maschine zu übertragen. Konrad
            Zuse wollte binär arbeitende Rechner bauen. Diese sollten mit sogenannten bistabilen Bauelementen arbeiten.
            Nach diesem Prinzip, der Aussagenlogik, sollten nicht nur Zahlen verarbeitet werden, sondern die gesamte
            Maschine sollte darauf beruhen. Die erste Maschine, Z1, konstruierte er in den Jahren 1936 bis 1938. Es war
            die erste programmierbare Rechenmaschine der Welt. Einen Nachbau kann man heute im Museum für Verkehr und
            Technik in Berlin besichtigen. Weiterentwicklungen waren die Z2 (Konstruktion 1938 bis 1939) und die Z3
            (Konstruktion 1941). Die Z3 beinhaltete ca. 600 Relais im Rechenwerk und 1.400 Relais im Speicher. Die Z3
            gilt heute als der erste funktionsfähige, frei programmierbare, auf dem binären Zahlensystem und der binären
            Schaltungstechnik basierende Rechner der Welt. Die Z4, begonnen im Jahr 1942, wurde 1949 nach dem Krieg
            restauriert und war ab 1950 fünf Jahre lang an der Eidgenössischen Technischen Hochschule in Zürich im
            Einsatz. In den Jahren 1942 bis 1946 arbeitete Konrad Zuse an einer universellen algorithmischen Sprache,
            Plankalkül. Plankalkül enthielt unter anderem Zuweisungszeichen, Datenstrukturen, Datentypen wie Gleit- und
            Festkommazahlen, Unterprogrammtechnik, verschiedene Schleifentypen und darüber hinaus umfangreiche
            Abhandlungen zu Schachprogrammen. Es wurde erst 1971 veröffentlicht.
        </p>
        <p>
            Zur Macht der Computer soll Konrad Zuse gesagt haben:
        </p>

        <tip>
            »Wenn die Computer zu mächtig werden, dann zieht doch einfach den Stecker aus der Steckdose«.
        </tip>

        <note>
            <p><b>WICHTIG!</b></p>

            <p>
                Auch die historische Entwicklung von Programmiersprachen spielt bis heute eine große Rolle.
            </p>
        </note>

        <chapter id="geschichte-tabelle" title="Tabelle bekannter und zugleich historischer Programmiersprachen">
            <table style="both">
                <tr>
                    <td>Name der Sprache</td>
                    <td>Erscheinungsdatum</td>
                    <td>Sprachkategorie</td>
                    <td>Anwendungsgebiet/Bemerkung</td>
                </tr>
                <tr>
                    <td>Fortan</td>
                    <td>1954</td>
                    <td>prozedural</td>
                    <td>
                        mathematisch-technische Probleme
                    </td>
                </tr>
                <tr>
                    <td>Algol 60</td>
                    <td>1958</td>
                    <td>prozedural</td>
                    <td>
                        mathematisch-wissenschaftliche Probleme
                    </td>
                </tr>
                <tr>
                    <td><a href="cobol.topic"/></td>
                    <td>1959</td>
                    <td>prozedural, objektorientiert</td>
                    <td>
                        kaufmännische Probleme; keine klare Definition, unsystematischer Aufbau, eine der am weitest
                        verbreiteten Sprachen; 1997 erweitert zu OO-Cobol mit objektorientierter Konzeption
                    </td>
                </tr>
                <tr>
                    <td>Lisp</td>
                    <td>1959</td>
                    <td>funktional</td>
                    <td>
                        gut geeignet für sog. symbolische Berechnungen
                    </td>
                </tr>
                <tr>
                    <td>Basic</td>
                    <td>1963</td>
                    <td>prozedural</td>
                    <td>
                        universell; Sprachumfang nicht einheitlich festgelegt
                    </td>
                </tr>
                <tr>
                    <td>PL/I</td>
                    <td>1964</td>
                    <td>prozedural</td>
                    <td>
                        mathematisch-technische und kaufmännische Probleme; sehr umfangreich
                    </td>
                </tr>
                <tr>
                    <td>Simula 67</td>
                    <td>1965</td>
                    <td>prozedural</td>
                    <td>
                        mathematisch-wissenschaftliche Probleme und Simulationen
                    </td>
                </tr>
                <tr>
                    <td>Pascal</td>
                    <td>1971</td>
                    <td>prozedural</td>
                    <td>
                        mathematisch-technische und kaufmännische Probleme; als Lehrsprache bekannt
                    </td>
                </tr>
                <tr>
                    <td>C</td>
                    <td>1974</td>
                    <td>prozedural</td>
                    <td>
                        systemnahe Programmierung; sehr verbreitet
                    </td>
                </tr>
                <tr>
                    <td>Modula-2</td>
                    <td>1976</td>
                    <td>prozedural, objektorientiert</td>
                    <td>
                        mathematisch-technische und kaufmännische Probleme; Weiterentwicklung zu Modula-3
                        (objektorientiert)
                    </td>
                </tr>
                <tr>
                    <td>Prolog</td>
                    <td>1977</td>
                    <td>prädikativ</td>
                    <td>
                        Anwendung mit symbolischen Formeln; Einsatz bei Expertensystemen
                    </td>
                </tr>
                <tr>
                    <td>Ada</td>
                    <td>1979</td>
                    <td>prozedural, objektorientiert</td>
                    <td>
                        Echtzeitanwendung; Weiterentwicklung von Pascal; Ada-95 um Objektorientierung erweitert
                    </td>
                </tr>
                <tr>
                    <td><a href="sql.topic"/></td>
                    <td>1970</td>
                    <td>deklarativ</td>
                    <td>
                        Datenbankanwendung; seit 1983 genormt
                    </td>
                </tr>
                <tr>
                    <td>Smalltalk-80</td>
                    <td>1970</td>
                    <td>objektorientiert</td>
                    <td>
                        universell; erste objektorientierte Sprache
                    </td>
                </tr>
                <tr>
                    <td>C++</td>
                    <td>1980</td>
                    <td>prozedural, objektorientiert</td>
                    <td>
                        universell; Obermenge von C
                    </td>
                </tr>
                <tr>
                    <td>Eiffel</td>
                    <td>1986</td>
                    <td>objektorientiert</td>
                    <td>
                        umfangreiche Softwaresysteme
                    </td>
                </tr>
                <tr>
                    <td>Pearl</td>
                    <td>1987</td>
                    <td>prozedural, modular, teilweise objektorientiert</td>
                    <td>
                        plattformunabhängige, interpretierte Scriptsprache
                    </td>
                </tr>
                <tr>
                    <td><a href="java.topic"/></td>
                    <td>1990</td>
                    <td>objektorientiert</td>
                    <td>
                        universell
                    </td>
                </tr>
                <tr>
                    <td>Haskell</td>
                    <td>1990</td>
                    <td>funktional</td>
                    <td>
                        Anwendungen in der Wissenschaft
                    </td>
                </tr>
                <tr>
                    <td><a href="python.topic"/></td>
                    <td>1991</td>
                    <td>multiparadigmatisch</td>
                    <td>
                        universelle, üblicherweise interpretierte höhere Programmiersprache
                    </td>
                </tr>
                <tr>
                    <td>R</td>
                    <td>1993</td>
                    <td>funktional, dynamisch, objektorientiert</td>
                    <td>
                        freie Programmiersprache für statistische Berechnungen und Grafiken
                    </td>
                </tr>
                <tr>
                    <td><a href="javascript.topic"/></td>
                    <td>1995</td>
                    <td>objektorientiert, prozedural, funktional</td>
                    <td>
                        Scriptsprache für interaktive Web-Anwendungen
                    </td>
                </tr>
                <tr>
                    <td><a href="csharp.topic"/></td>
                    <td>2002</td>
                    <td>objektorientiert</td>
                    <td>
                        Anwendung auf Microsoft-Plattformen
                    </td>
                </tr>
                <tr>
                    <td>Go</td>
                    <td>2009</td>
                    <td>multiparadigmatisch</td>
                    <td>
                        entwickelt von Google; kompilierbare Programmiersprache, die Nebenläufigkeit unterstützt und
                        über eine automatische Speicherbereinigung verfügt
                    </td>
                </tr>
                <tr>
                    <td>Rust</td>
                    <td>2010</td>
                    <td>multiparadigmatisch</td>
                    <td>
                        als sichere, nebenläufige und praxisnahe Sprache von Mozilla Research entwickelt
                    </td>
                </tr>
                <tr>
                    <td><a href="swift.topic"/></td>
                    <td>2014</td>
                    <td>multiparadigmatisch</td>
                    <td>
                        Programmiersprache von Apple für iOS, macOS, tvOS, watchOS und Linux
                    </td>
                </tr>
            </table>
        </chapter>
    </chapter>

    <chapter id="generationen" title="Generationen der Programmiersprachen">
        <chapter id="generationen-grundlegendes" title="Grundlegendes">
            <p>
                Programmiersprachen lassen sich nicht nur nach ihrem Verwendungszweck (kaufmännisch, technisch,
                mathematisch) und ihrer Sprachkategorie (objektorientiert, funktional) einteilen, sondern auch nach
                ihrem Grad der Abstraktion. Nach diesem Kriterium unterteilt man sie in Sprachen der ersten bis vierten
                Generation. Heute kommen primär Programmiersprachen der dritten und vierten Generation zum Einsatz, das
                heißt aber nicht, dass man eine Sprache einer früheren Generation nicht mehr verwendet.
            </p>

            <img alt="Abstraktionsgrad einer Programmiersprache"
                 src="swe-pk-grundlagen-allgemeines-abstraktionsgrad.png"/>
        </chapter>

        <chapter id="generationen-gen1" title="Sprachen der ersten Generation: Maschinensprachen">
            <p>
                Computer waren zu Beginn ausschließlich in Maschinensprache, d. h. als Folge von Nullen und Einsen zu
                programmieren. Befehle und zu bearbeitende Daten wurden dabei in Kombination an den Prozessor gesandt.
                Typische Operationen sind das Verschieben von Daten aus dem Speicher in bestimmte Register des
                Prozessors und einfachste arithmetische Operationen, zum Beispiel Addition und Subtraktion, mit den
                Inhalten der Register.
            </p>

            <code-block>
                1: 10110000 01100011
                2: (hex) B0 63
                3: Operand 0x63 wird in AL-Register geladen
            </code-block>

            <p>
                Man kann sagen, dass die Programmierung in Maschinensprache aus heutiger Sicht fast keine Bedeutung mehr
                hat. Der Code in Maschinensprache unterscheidet sich von Prozessortyp zu Prozessortyp. Für jeden
                Prozessortyp muss also ein eigenes Programm in Maschinensprache erstellt werden, damit es die gleichen
                Aufgaben ausführt.
            </p>
        </chapter>

        <chapter id="generationen-gen2" title="Sprachen der zweiten Generation: Assemblersprachen">
            <p>
                Programmiersprachen der zweiten Generation werden sogenannte Assemblersprachen bezeichnet. Auch diese
                Sprachen sind auf den Befehlssatz des Prozessors ausgerichtet, aber die Anweisungen erfolgen durch im
                Klartext formulierte Anweisungen. Diese Anweisungen beschreiben Operationen mit den Registern des
                Prozessors. Assemblerprogramme werden durch einen Übersetzer, der sehr oft als Assembler bezeichnet
                wird, in die vom Prozessor ausführbare Maschinensprache transformiert. Assemblerprogrammierung ist sehr
                hardwarenah.
            </p>
            <note>
                Assemblersprachen werden für die Entwicklung von Hardwaretreibern oder bei der Programmierung von
                Software von Mikrocontrollern, da der Treiber meist ohne zeitliche Verzögerung auf die Ein- und Ausgänge
                zugreifen muss.
            </note>

            <code-block>
                <![CDATA[
                START
                    Btfsc      GPIO, 3     ; Abfrage des Eingangs GPIO3, ob Taste gedrückt
                    Goto       START       ; Taste nicht gedrückt, springe zur Marke >START<
                    Movfw      einer       ; Laden der Variablen >einer< in das W-Register
                    Call       TabellePIN  ; Sprung zum Label >TabellePIN<

                    bsf STATUS, RPO        ; Auswahl Bank 1
                    movwf       TRISIO     ; Setzen der aktuellen Pin-Konfiguration
                    bcf STATUS, RPO        ; Auswahl Bank 0
                    movfw       einer      ; Laden der Variablen >einer< in das W-Register
                    call        TablleLED  ; Sprung zum Label >TabelleLED<, Laden der Variablen
                WARTE
                    Btfss       GPIO, 3    ; Abfragen des Eingangs GPIO3, ob Taste gedrückt
                    Goto        WARTE      ; Taste gedrückt, springe zur Marke >WARTE<
                    Decfsz      einer, 1   ; Tastendruck zählen bis 0 erreicht
                    Goto        START      ; Zurück zu >START<, sofern nicht 0 ; bei 0 geht es mit der Folgeanweisung weiter
                    Movlw       D'8        ; Laden der Konstanten <acht>
                    Movewf      einer      ; Erneutes Setzen von >einer< auf >acht<
                    Goto        START      ; und von vorn
                ]]>
            </code-block>

            <p>
                In Assemblerprogrammen kann man schon ein wenig abstrakt arbeiten, d.h., man kann zum Beispiel Variablen
                und Sprungmarken definieren sowie auch Kommentare setzten.
            </p>
        </chapter>

        <chapter id="generationen-gen3" title="Sprachen der dritten Generation: Höhere Programmiersprachen">
            <p>
                Ziel der Programmiersprachen der dritten Generation war es, eine neue Ebene der Abstraktion zu erreichen
                und weitestgehende unabhängig von der verwendeten Hardware zu programmieren. Diese Art von
                Programmiersprachen werden daher auch als höhere Programmiersprachen bezeichnet.
            </p>
            <p>
                Eine der ersten Sprachen (1954) war Fortran (Formula Translator). 1959 wurde die Sprache Lisp (List
                Processor) entwickelt, und ebenfalls 1959 wurde die Sprache <a href="cobol.topic">Cobol (Common Business
                Oriented Language)</a> für primäre betriebswirtschaftliche Anwendungen entwickelt.
            </p>
            <p>
                Die Sprache Algol 60 (1960) basierte auf dem Vorläufer Algol 58 (1958) und hat die Entwicklung und
                Struktur der Programmiersprachen wesentlich mitbestimmt. Die Sprache Algol war maßgebend für die
                Entwicklung weiterer Sprachen. Dazu zählen unter anderem Pascal, Simula und C. Mit der Einführung der
                Sprache BASIC (Beginner’s All-purpose Symbolic Instruction Code) sollte der Einstieg in die
                Programmierung für Anfänger erleichtert werden. BASIC, in den Anfängen wegen der oft fehleranfälligen
                Struktur des erstellten Quellcodes kritisiert, hat dennoch eine beachtliche Erfolgsgeschichte.
                BASIC-Dialekte existieren für nahezu alle Plattformen. Bekannte Meilensteine waren QuickBASIC und die
                Entwicklung von Visual Basic. Heute ist Visual Basic .NET eine der wichtigen Programmiersprachen bei der
                Entwicklung von Anwendungen für das .Net-Framework. Die grundlegenden Sprachmerkmale sind mit denen der
                ersten Version nach wie vor vergleichbar, was einen Einstieg erleichtert. Hinzugekommen sind
                professionelle Konzepte wie Objektorientierung und weitere moderne Ausdrucksformen. Dennoch nimmt ihre
                Bedeutung laut Tiobe-Index (
                <a href="https://www.tiobe.com/tiobe-index/">
                    https://www.tiobe.com/tiobe-index/
                </a>
                ) ab.
            </p>
            <p>
                Die Programmierung wird bis heute durch das objektorientierte Paradigma geprägt. Kernelement ist die
                Vereinigung von Daten und der zugehörigen Methoden innerhalb eines Objekts. Einen ersten Ansatz in diese
                Richtung wurde durch die Sprache Simula 67 gegangen. Simula war eine Spezialsprache zur Simulation von
                Vorgängen in der realen Welt. Die Sprache Smalltalk gilt bis heute als die erste objektorientierte
                Sprache, da ihr Konzept auf der reinen Objektorientierung beruht. Die Terminologie der heutigen
                objektorientierten Sprachen beruht zu einem Großteil auf den Begrifflichkeiten in Smalltalk.
            </p>
            <p>
                Um 1970 wurde durch Niklaus Wirth die Programmiersprache Pascal entwickelt. Pascal erlangte sehr schnell
                Bedeutung in Lehre und Forschung. Der hauptsächliche Grund dafür ist die klare Strukturierung der
                Sprache und der mit ihr erzeugten Programme. Die Weiterentwicklung von Pascal – primär um
                objektorientierte Sprachkonzepte, aber auch um Anpassungen an neue Entwicklungsmöglichkeiten – führte zu
                Object Pascal und Delphi. Delphi steht heute dabei für mehr als eine Programmiersprache. Es handelt sich
                um einen umfassenden Entwicklungsansatz für die effiziente Erstellung von Anwendungen für
                unterschiedliche Betriebssysteme. Die Kernelemente der zugrundeliegenden Programmiersprache beruhen
                jedoch auf Pascal. Auf Pascal beruht ebenfalls die Weiterentwicklung zur Programmiersprache Modula-2.
                Diese verfügt über ein strenges Modul- und Schnittstellenkonzept. Modula-2 wurde zu Oberon und später zu
                Oberon-2, einer echten objektorientierten Sprache, ausgebaut.
            </p>
            <p>
                Die Sprache C hat bis heute große Bedeutung. Sie ist weiterhin die häufigste Programmiersprache im
                Bereich der hardwarenahen Entwicklung wie zum Beispiel Treiber, Betriebssysteme und Software für
                eingebettete Systeme. C++ und Objective-C sind zwei objektorientierte Erweiterungen von C. C++ war sehr
                lange die dominierende Sprache bei der Entwicklung von professionellen Anwendungen. Eine neuere
                Sprachentwicklung ist <a href="java.topic"/>. Java verzichtet gegenüber C++ auf das fehleranfällige
                Zeigerkonzept. Die Plattformunabhängigkeit ermöglicht es, erstellte Anwendungen ohne größere Änderungen
                in verschiedenen Systemumgebungen zu starten. Voraussetzung dafür ist, dass eine Laufzeitumgebung auf
                dem Zielsystem vorhanden ist. Java wird auf Rechnern unterschiedlichster Kategorien und Leistungsklassen
                angewendet.
            </p>
            <p>
                Gehen wir noch einen Schritt in Richtung Zukunft: Weitere, neuere Sprachentwicklungen sind C# und F#,
                die für die Softwareentwicklung mithilfe des .Net-Frameworks zur Verfügung stehen. C# ist dabei aus Java
                hervorgegangen, enthält aber auch Elemente aus C. Die Sprache ist inzwischen ausgereift und stellt den
                Quasi-Standard für die Entwicklung von Anwendungen mit .Net dar. F# ist eine noch relativ junge
                Programmiersprache, die das funktionale Paradigma in den Fokus rückt. Eine weitere wichtige
                Programmiersprache – primär für die Entwicklung von dynamischen Web-Anwendungen – ist die Sprache
                <a href="php.topic"/>, die auch kontinuierlich weiterentwickelt wird.
            </p>
            <p>
                Die Entwicklung der Programmiersprachen hat auch in der jüngeren Zeit nicht aufgehört. Neue Sprachen
                sind beispielsweise <a href="swift.topic"/> von Apple (2014), Go von Google (2009) und Rust von Mozilla
                (2010).
            </p>
        </chapter>

        <chapter id="generationen-gen4" title="Sprachen der vierten und höheren Generation">
            <p>
                Programmiersprachen der vierten und höheren Generation unterliegen keinem speziellen Paradigma. Es
                handelt sich um Sprachen mit einem höheren Abstraktionsniveau, die auf spezielle Anwendungsbereiche
                ausgerichtet sind. In diese Kategorie fallen zum einen Skriptsprachen wie z.B.
                <a href="sql.topic"/> (Datenbankabfragesprache) oder TeX bzw. <a href="latex.topic"/>
                (Seitenlayoutsprache). Zum anderen gehören deskriptive Sprachen dazu. Diese Sprachen dienen der
                Beschreibung von Inhalten, weisen jedoch keine Programmlogik auf. Beispiele sind
                <a href="xml.topic">XML</a> oder <a href="html.topic">HTML</a>.
            </p>
        </chapter>
    </chapter>

    <chapter id="compiler" title="Compiler &amp; Interpreter">
        <p>
            Als Entwickler speichert man das, was man mit einer Programmiersprache programmiert in ganz gewöhnlichen
            Textdateien, die auch als Quelldateien (eng. Source Files) bezeichnet werden. Der Inhalt einer solchen Datei
            wird dann auch als Quelltext bzw. Quellcode (eng. Source Code) bezeichnet. Damit der Computer die
            Anweisungen, die im Quelltext formuliert sind, auch verstehen und umsetzen kann, muss der Quelltext in ein
            für den Computer verständliches Format, den Maschinencode (sprich in Nullen und Einsen), übersetzt werden.
            Dazu gibt es im Wesentlichen zwei verschiedene Wege: zum einen sogenannte Compiler und zum anderen
            sogenannte Interpreter. Je nachdem, ob eine Programmiersprache einen Compiler oder einen Interpreter
            verwendet handelt es sich dabei um eine kompilierte Programmiersprache, eine interpretierte
            Programmiersprache oder um eine sogenannte Zwischensprache.
        </p>

        <code-block lang="mermaid">
            stateDiagram-v2

            DEV: Entwickler
            QC: Quelltext
            MC: Maschinencode
            PC: Computer

            DEV --> QC: versteht
            QC --> MC: muss übersetzt werden
            PC --> MC: versteht
        </code-block>

        <chapter id="compiler-kompiliert" title="Kompilierte Programmiersprachen">
            <p>
                Bei kompilierten Programmiersprachen ist es so, dass der Quelltext durch einen Compiler in Maschinencode
                bzw. in eine ausführbare Maschinencodedatei umgewandelt wird. Dabei werden die im Quelltext formulierten
                Anweisungen in einer Folge von Anweisungen für den Computer übersetzt. Die Programme, die auf diese
                Weise durch einen Compiler erzeugt werden, können dann direkt ohne weitere Hilfskomponenten auf dem
                Betriebssystem, für das sie kompiliert wurden, ausgeführt werden.
            </p>

            <code-block lang="mermaid">
                stateDiagram-v2

                QC: Quelltext
                CMP: Compiler
                MC: Maschinencode

                QC --> CMP
                CMP --> MC
            </code-block>

            <p>
                Beispiele für kompilierte Programmiersprachen sind C oder auch C++. Um beispielsweise ein in C++
                geschriebenes Programm ausführen zu können, muss es vorher über einen entsprechenden C++ Compiler
                umgewandelt werden. Da sich Letzterer aber von Betriebssystem zu Betriebssystem unterscheidet, muss für
                jedes Betriebssystem auch eine eigene Version kompiliert werden.
            </p>
            <p>
                Dazu wird für jedes Betriebssystem ein eigener Compiler benötigt. Um das Programm also unter Windows
                laufen zu lassen, muss es auch zuvor unter Windows über einen entsprechenden Compiler kompiliert werden.
                Um es unter Linux ausführen zu können, muss mit einem Compiler unter Linux kompiliert werden, und dies
                gilt analog für macOS, wenn das Programm auf einem Mac ausgeführt werden soll. Es gibt zwar auch
                Ansätze, um unter einem Betriebssystem für ein anderes zu kompilieren (beispielsweise unter Linux für
                Windows oder umgekehrt, diese Technik nennt man Cross-Compilation), trotzdem ändert das nichts an der
                Tatsache, dass man recht viel Aufwand betreiben muss, um ein C++-Programm unter verschiedenen
                Betriebssystemen zum Laufen zu bringen. Und dabei haben wir noch gar nicht die Prozessarchitekturen (32
                Bit, 64 Bit und ARM) berücksichtigt, für die auch jeweils noch mal anders kompiliert werden muss.
            </p>

            <code-block lang="mermaid">
                stateDiagram-v2

                CPPQT: C++-Quelltext
                CPPCMPWIN: C++-Compiler Windows
                CPPCMPLIN: C++-Compiler Linux
                CPPCMPMAC: C++-Compiler macOS
                MCWIN: Ausführbare Maschinencodedatei Windows
                MCLIN: Ausführbare Maschinencodedatei Linux
                MCMAC: Ausführbare Maschinencodedatei macOS

                CPPQT --> CPPCMPWIN
                CPPQT --> CPPCMPLIN
                CPPQT --> CPPCMPMAC
                CPPCMPWIN --> MCWIN
                CPPCMPLIN --> MCLIN
                CPPCMPMAC --> MCMAC
            </code-block>

            <p>
                Bei diesem ganzen Aufwand haben kompilierte Programme aber auch einen entscheidenden Vorteil: Der
                jeweils erzeugte Maschinencode kann ohne andere Hilfsmittel auf dem jeweiligen Betriebssystem ausgeführt
                werden. Es müssen also keine weiteren Programme auf dem Betriebssystem installiert sein, um ein in
                Maschinencode kompiliertes Programm ausführen zu können. Das ist ein wesentlicher Unterschied zu
                interpretierten Programmen.
            </p>
            <note>
                Programme, die für ein bestimmtes Betriebssystem kompiliert wurden, nennt man auch native Programme oder
                native Anwendungen.
            </note>
        </chapter>

        <chapter id="compiler-interpretiert" title="Interpretierte Programmiersprachen">
            <p>
                Bei interpretierten Programmiersprachen ist es nicht notwendig, den Quelltext zu kompilieren. Der
                Quelltext wird hier nicht durch einen Compiler übersetzt, sondern durch einen Interpreter ausgewertet.
                Ein solcher Interpreter muss auf dem Rechner (bzw. auf dem entsprechenden Betriebssystem) installiert
                sein, auf dem das Programm ausgeführt werden soll (im Unterschied zum Compiler, der nur auf dem Rechner
                installiert sein muss, auf dem man den entsprechenden Quelltext kompiliert.
            </p>

            <code-block lang="mermaid">
                stateDiagram-v2

                QC: Quelltext
                CMP: Interpreter
                MC: Maschinencodesequenz

                QC --> CMP
                CMP --> MC
            </code-block>

            <p>
                JavaScript ist eine interpretierte Programmiersprache. Das bedeutet, dass prinzipiell mit jedem
                beliebigen Texteditor ein JavaScript-Programm geschrieben und der Quelltext ohne zusätzliche
                Zwischenschritte direkt in einem Browser ausgeführt werden kann.
            </p>

            <code-block lang="mermaid">
                stateDiagram-v2

                JSQT: JavaScript-Quelltext
                JSCMPWIN: JavaScript-Interpreter Windows
                JSCMPLIN: JavaScript-Interpreter Linux
                JSCMPMAC: JavaScript-Interpreter macOS
                MCSWIN: Maschinencodesequenz Windows
                MCSLIN: Maschinencodesequenz Linux
                MCSMAC: Maschinencodesequenz macOS

                JSQT --> JSCMPWIN
                JSQT --> JSCMPLIN
                JSQT --> JSCMPMAC
                JSCMPWIN --> MCSWIN
                JSCMPLIN --> MCSLIN
                JSCMPMAC --> MCSMAC
            </code-block>

            <p>
                Interpretierte Programmiersprachen benötigen zur Ausführung eines Programms einen Interpreter. Häufig
                ist es dabei so, dass dieser ein Bestandteil einer sogenannten Laufzeitumgebung ist. Laufzeitumgebungen
                (oder auch eng.: Runtime Environment, kurz RTE) dienen dazu, dass Anwendungsprogramme auf dem
                jeweiligen Betriebssystem laufen können. Neben einem Interpreter stellen Laufzeitumgebungen
                beispielsweise auch Grundfunktionen wie das Lesen und Schreiben von Dateinen, den Zugriff auf
                Peripheriegeräte (wie Maus, Tastatur, Drucker etc.) zur Verfügung.
            </p>
            <p>
                Neben den Browser gibt es auch die Laufzeitumgebung Node.js in der JavaScript ausgeführt werden kann.
                Neben den Laufzeitumgebungen für JavaScript gibt es auch Laufzeitumgebungen für andere
                Programmiersprachen. Bekannte Beispiele wären das Java Runtime Environment (JRE) für das Ausführen von
                Java-Programmen oder Microsofts .NET Common Language Runtime, in der Programme ausgeführt werden können,
                die in C#, Visual Basic oder C++ geschrieben sind.
            </p>
            <p>
                Hier noch einen Überblick über das Prinzip von Laufzeitumgebungen und den Zusammenhang zu nativen
                Anwendungen:
            </p>

            <code-block lang="mermaid">
                stateDiagram-v2

                JSAPP: JavaScript-Anwendung
                JAVAAPP: Java-Anwendung
                NETAPP: .NET-Anwendung
                NATAPP: Native-Anwendung

                JSI: Browser/Node.js
                JRE: JRE
                CLR: CLR

                OS: Betriebssystem

                JSAPP --> JSI
                JAVAAPP --> JRE
                NETAPP --> CLR

                JSI --> OS
                JRE --> OS
                CLR --> OS
                NATAPP --> OS
            </code-block>
        </chapter>

        <chapter id="compiler-procontra" title="Vor- und Nachteile">
            <table>
                <tr>
                    <td>Compiler</td>
                    <td>Interpreter</td>
                </tr>
                <tr>
                    <td>
                        Programm muss zur Ausführung jedes Mal neu kompiliert werden.
                    </td>
                    <td>
                        Programm kann direkt ausgeführt werden.
                    </td>
                </tr>
                <tr>
                    <td>
                        Ist in der Regel sehr performant, da der Quelltext zur Laufzeit nicht mehr umgewandelt werden
                        muss.
                    </td>
                    <td>
                        Tendenziell weniger performant als kompilierte Programme, da eine Umwandlung des Quelltextes zur
                        Laufzeit des Programms stattfindet. Häufig kommen heutzutage in diesem Zusammenhang auch
                        sogenannte Just-in-Time-Compiler (JIT) zum Einsatz, die den Quelltext bzw. häufig ausgeführten
                        Quelltext in Maschinencode umwandeln, der dann relativ schnell ausgeführt werden kann.
                    </td>
                </tr>
                <tr>
                    <td>
                        Durch den zusätzlichen Kompilierungsschritten werden Syntaxfehler schneller erkannt.
                    </td>
                    <td>
                        Da Syntaxfehler erst zur Laufzeit erkannt werden, können sie schnell übersehen werden.
                    </td>
                </tr>
            </table>
        </chapter>

        <chapter id="compiler-zwischensprachen" title="Zwischensprachen">
            <p>
                Es gibt einige Programmiersprachen, die sich nicht eindeutig einer der beiden genannten Kategorien
                (kompiliert und interpretiert) zuordnen lassen, da bei ihnen sowohl Compiler als auch Interpreter zum
                Einsatz kommen. In Java beispielsweise ist es so, dass der Quelltext durch einen Compiler in sogenannten
                Bytecode kompiliert wird, eine Art Zwischencode, der seinerseits einen Interpreter benötigt, um
                ausgeführt werden zu können.
            </p>

            <code-block lang="mermaid">
                stateDiagram-v2

                QT: Quelltext
                CMP: Compiler
                BC: Bytecode
                IP: Interpreter
                MCS: Maschinencodesequenz

                QT --> CMP
                CMP --> BC
                BC --> IP
                IP --> MCS
            </code-block>

            <p>
                Der Vorteil davon: Java-Anwendungen müssen nicht (wie bei rein kompilierten Sprachen) auf dem gleichen
                Betriebssystem kompiliert werden, auf dem sie später ausgeführt werden, da der Bytecode unabhängig vom
                Betriebssystem ist. Das Einzige, was auf dem jeweiligen Zielbetriebssystem vorhanden sein muss, ist ein
                Interpreter für diesen Bytecode, mit anderen Worten: eine Laufzeitumgebung für Java.
            </p>

            <code-block lang="mermaid">
                stateDiagram-v2

                JAVAQT: Java-Quelltext
                JAVACMP: Java-Compiler
                JAVABC: Java-Bytecode
                JAVAIPWIN: Java-Interpreter Windows
                JAVAIPLIN: Java-Interpreter Linux
                JAVAIPMAC: Java-Interpreter macOS
                MCWIN: Maschinencodesequenz Windows
                MCLIN: Maschinencodesequenz Linux
                MCMAC: Maschinencodesequenz macOS

                JAVAQT --> JAVACMP
                JAVACMP --> JAVABC
                JAVABC --> JAVAIPWIN
                JAVABC --> JAVAIPLIN
                JAVABC --> JAVAIPMAC
                JAVAIPWIN --> MCWIN
                JAVAIPLIN --> MCLIN
                JAVAIPMAC --> MCMAC
            </code-block>
        </chapter>

        <chapter id="compiler-uebersicht" title="Übersicht über verschiedene Programmiersprachen">
            <table>
                <tr>
                    <td>Programmiersprache</td>
                    <td>Typ</td>
                </tr>
                <tr>
                    <td>ADA</td>
                    <td>kompiliert</td>
                </tr>
                <tr>
                    <td>BASIC</td>
                    <td>interpretiert</td>
                </tr>
                <tr>
                    <td>C</td>
                    <td>kompiliert</td>
                </tr>
                <tr>
                    <td>C++</td>
                    <td>kompiliert</td>
                </tr>
                <tr>
                    <td>COBOL</td>
                    <td>kompiliert</td>
                </tr>
                <tr>
                    <td>Fortran</td>
                    <td>kompiliert</td>
                </tr>
                <tr>
                    <td>Java</td>
                    <td>Zwischensprache</td>
                </tr>
                <tr>
                    <td>JavaScript</td>
                    <td>interpretiert</td>
                </tr>
                <tr>
                    <td>Lisp</td>
                    <td>Zwischensprache</td>
                </tr>
                <tr>
                    <td>Objective-C</td>
                    <td>kompiliert</td>
                </tr>
                <tr>
                    <td>Perl</td>
                    <td>interpretiert</td>
                </tr>
                <tr>
                    <td>PHP</td>
                    <td>interpretiert</td>
                </tr>
                <tr>
                    <td>Python</td>
                    <td>interpretiert</td>
                </tr>
                <tr>
                    <td>Ruby</td>
                    <td>interpretiert</td>
                </tr>
                <tr>
                    <td>Swift</td>
                    <td>kompiliert</td>
                </tr>
            </table>
        </chapter>
    </chapter>

    <chapter id="programmierparadigmen" title="Programmierparadigmen">
        <p>
            Eine sehr wichtige Frage bei der Programmierung ist die Art und Weise, wie eine Aufgabe aus der realen Welt
            in Software abgebildet und damit bearbeitet wird. Je nach Problem existieren unterschiedliche Ansätze zum
            Aufbau des Programms. Diese Ansätze werden als Programmierparadigmen bezeichnet. Dabei wird zwischen
            folgenden grundsätzlichen Paradigmen unterschieden:
        </p>

        <list>
            <li>
                <b>Imperativ</b>: Das Programm besteht aus einer Folge von Anweisungen, die streng sequentiell
                abgearbeitet werden. Das Konzept des imperativen Programmierparadigmas beruht auf Funktionen und
                Prozeduren zur Abbildung der Funktionalität.
            </li>
            <li>
                <b>Objektbasiert</b>: Diese Programmiersprachen kennen Objekte, welche Daten und die zugehörigen
                Funktionen zu einer Einheit, d.h. zu einem Objekt zusammenfassen. Vererbung oder die Abbildung von
                Beziehungen zwischen Objekten werden jedoch nicht angeboten. Objektbasierte Sprachen können damit als
                Vorstufe der objektorientierten Programmierung aufgefasst werden. Beispiel: Microsoft PowerShell.
            </li>
            <li>
                <b>Objektorientiert</b>: Programmiersprachen dieser Gattung erweitern das objektbasierte
                Programmierparadigma um typische Konzepte wie z.B. die Vererbung. Es ist heutzutage die am meisten
                angewendete Vorgehensweise.
            </li>
            <li>
                <b>Objektorientiert</b>: Programmiersprachen dieser Gattung erweitern das objektbasierte
                Programmierparadigma um typische Konzepte wie z.B. die Vererbung. Es ist heutzutage die am meisten
                angewendete Vorgehensweise.
            </li>
            <li>
                <b>Funktional</b>: Ein funktionales Programm besteht nur aus einer Reihe von Funktionsaufrufen. Nahezu
                alle Elemente können dabei als Funktionen aufgefasst werden. Einsatzgebiete sind Anwendungen der
                künstlichen Intelligenz, Compilerbau und Computeralgebra-Systeme. Beispiele: Lisp, Haskell, F# und
                Scala.
            </li>
            <li>
                <b>Logisch</b>: Hier steht im Mittelpunkt der Aufbau einer Datenbasis, die aus Fakten und Regeln
                besteht. Fakten sind dabei wahre Aussagen im Sinne der Mathematik. Im Fokus steht die
                Problemformulierung, nicht der Lösungsalgorithmus. Beispiel: Prolog.
            </li>
            <li>
                <b>Deklarativ</b>: Es ist der Überbegriff für das funktionale und das logische Programmierparadigma.
            </li>
        </list>

        <p>
            Computerprogramme können grundsätzlich nach unterschiedlichen Programmierparadigmen aufgebaut werden. Ein
            »falsch« oder »richtig« gibt es dabei nicht, sondern eine ehr oder weniger gute Eignung. Viele
            Programmiersprachen unterstützen meist auch nicht nur ein Paradigma, sondern mehrere Ansätze können
            miteinander kombiniert werden. Insgesamt kann man aus heutiger Perspektive sagen, dass sich die
            objektorientierte Programmierung seit Langem etabliert hat und heute als
            <emphasis>State of the
                Art
            </emphasis>
            in vielen Bereichen der Softwareentwicklung gilt.
        </p>
    </chapter>

    <chapter id="quellen" title="Quellen">
        <tip>
            <b>(BUCH)</b>
            978-3836244763, "Handbuch für Softwareentwickler", Veikko Krypczyk &amp; Elena Bochkor, 2018
        </tip>
        <tip>
            <b>(BUCH)</b>
            978-3836256971, "JavaScript - Das umfassende Handbuch", Philip Ackermann, 2018
        </tip>
    </chapter>
</topic>