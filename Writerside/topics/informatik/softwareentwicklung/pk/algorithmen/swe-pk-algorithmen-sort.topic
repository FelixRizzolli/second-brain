<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
        SYSTEM "https://resources.jetbrains.com/writerside/1.0/xhtml-entities.dtd">
<topic xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="https://resources.jetbrains.com/writerside/1.0/topic.v2.xsd"
       title="Sortieralgorithmen" id="swe-pk-algorithmen-sort">
    <show-structure for="chapter,procedure" depth="2"/>
    
    <chapter title="Einleitung" id="einleitung">
        <p>
            Ein Sortierverfahren ist ein Algorithmus, der dazu dient, Elemente einer Liste zu sortieren. Voraussetzung
            ist, dass zwischen den Elementen eine Ordnung möglich ist. Es müssen also Vorgänger- und
            Nachfolgerbeziehungen bzw. Gleichheit zwischen zwei zu vergleichenden Elementen bezüglich des
            Sortierkriteriums herstellbar sein. Diese Forderung wird als <emphasis><b>Trichotomie</b></emphasis>
            bezeichnet und sagt, dass für alle Elemente einer Menge bezüglich der Schlüssel <code>a</code>,
            <code>b</code> gilt:
        </p>

        <list>
            <li><code>a &lt; b</code> (lies: a vor b) oder</li>
            <li><code>a = b</code> oder</li>
            <li><code>a &gt; b</code> (lies: a nach b)</li>
        </list>

        <p>
            Um das mit Symbolen darzustellen, verwendet man die gezeigten Zeichen.
        </p>
        <p>
            Typische Beispiele sind die lexikografische Ordnung von Zeichenketten oder die numerische Ordnung von
            Zahlen.
        </p>
        <p>
            Eine weitere Voraussetzung dafür, dass man die Daten sortieren kann, ist
            <emphasis><b>Transitivität</b></emphasis>. Ist sie gegeben, dann ist gewährleistet, dass die Sortierung
            widerspruchsfrei durchgeführt werden kann. Es soll gelten: Gehört in der Liste Element <code>a</code> vor
            Element <code>b</code> und gehört Element <code>b</code> vor Element <code>c</code>, so folgt, dass Element
            <code>a</code> vor Element <code>c</code> anzuordnen ist.
        </p>
        <p>
            Wichtige Merkmale eines Sortier-Algorithmus sind die Zahl der durchschnittlich benötigten Schritte, bis die
            gewünschte Reihenfolge der Elemente vorliegt, und der benötigte <b>Speicherplatzbedarf</b>. Die Zahl der
            Schritte gibt die <b>Komplexität</b> des Algorithmus an und bestimmt maßgeblich, wie lange der gesamte
            Vorgang dauert.
        </p>
        <p>
            Sortierverfahren können in <b>interne</b> und <b>externe</b> Verfahren unterteilt werden. Wenn es möglich
            ist, die zu sortierenden Daten komplett im Hauptspeicher, zum Beispiel innerhalb einer Datenstruktur, zu
            sortieren, so liegt ein internes Sortierverfahren vor. Bei größeren Datenbeständen ist es nicht handhabbar,
            sämtliche Daten innerhalb des Arbeitsspeichers zu halten. Dann kommen externe Speichermedien wie Festplatten
            zum Einsatz. Die Effizienz des Algorithmus ist hier besonders wichtig, da die Lese- und Schreibzugriffe auf
            externe Medien viel Zeit beanspruchen.
        </p>
        <p>
            Unter <b>Effizienz</b> eines Suchverfahrens versteht man, wie viele Schritte im Durchschnitt notwendig sind,
            um den Sortiervorgang erfolgreich abzuschließen.
        </p>
        <p>
            Ein Sortier-Algorithmus wird als <b>stabil</b> bezeichnet, wenn er die relative Reihenfolge von Elementen
            beibehält, welche den gleichen Wert bezüglich des Sortierschlüssels aufweisen. Als <b>Sortierschlüssel</b>
            bezeichnet man das Element, nachdem die Sortierung erfolgt.
        </p>
    </chapter>

    <chapter title="Bubblesort" id="bubblesort">
        <chapter title="Grundlagen" id="bubblesort-grundlagen">
            <chapter title="Erklärung" id="bubblesort-grundlagen-erklaerung">
                <p>
                    Der Grundgedanke des Sortieralgorithmus kommt tatsächlich von Luftblasen. Ein Glas gefüllt mit
                    Mineralwasser: Darin steigen größere Luftblasen schneller auf als kleinere. Die sogenannten
                    "Bubbles" sortieren sich also der Größe nach. Deswegen kann das Sortierverfahren auch als
                    <b>"Sortieren durch Aufsteigen"</b> oder <b>"Austauschsortieren"</b> bezeichnet werden.
                </p>
                <p>
                    Der Bubble Sort gehört zu den Sortieralgorithmen mit einem vergleichsbasierten Verfahren. Dabei ist
                    das Sortierverfahren <b>stabil</b> und arbeitet <b>in-place</b>. Wegen seiner <b>durchschnittlichen
                    Zeitkomplexität von <code>O(n²)</code></b> gilt er als ziemlich langsam und wird deshalb in der
                    Praxis kaum verwendet.
                </p>
            </chapter>

            <chapter title="Prinzip" id="bubblesort-grundlagen-prinzip">
                <p>
                    Beim Bubblesort Algorithmus wird ein Array – also eine Eingabe-Liste – immer <b>paarweise von links
                    nach rechts in einer sogenannten Bubble-Phase durchlaufen</b>. Man startet also mit der ersten Zahl
                    und vergleicht diese dann mit ihrem direkten Nachbarn nach dem Sortierkriterium. Sollten beide
                    Elemente nicht in der richtigen Reihenfolge sein, werden sie ganz einfach miteinander vertauscht.
                    Danach wird direkt das nächste Paar miteinander verglichen, bis die gesamte Liste einmal durchlaufen
                    wurde. Die Phase wird so oft wiederholt, bis der gesamte Array vollständig sortiert ist.
                </p>
            </chapter>
        </chapter>

        <chapter title="Pseudocode" id="bubblesort-pseudocode">
            <code-block>
                laenge = x.Anzahl;
                for b = 1 to laenge
                    for k = 0 to (laenge-b)
                        if zahl[k] >  zahl[k+1]
                            c = zahl [k]
                            zahl[k] = zahl[k+1]
                            zahl[k+1] = c
            </code-block>
        </chapter>

        <chapter title="Bubblesort Laufzeit" id="bubblesort-laufzeit">
            <p>
                In der Praxis wird der Sortieralgorithmus kaum verwendet. Grund hierfür ist seine sehr lange Laufzeit,
                weswegen sich andere Sortierverfahren deutlich besser eignen. Beispielsweise der <b>Mergesort</b> oder
                der <b>Heapsort</b> sind bei einem Datensatz im über vierstelligem Bereich tausendmal schneller.
            </p>
            <p>
                Die Laufzeit im <b>Average-Case</b> beträgt genauso wie im <b>Worst-Case <code>O(n2)</code></b>. Das
                liegt daran, dass der Algorithmus paarweise voranschreitet und damit entsprechend viele Paare
                vergleichen muss.
            </p>
            <p>
                Nur im <b>Best-Case</b> kann er eine Laufzeit von <b><code>O(n)</code></b> erreichen. Das ist der Fall,
                wenn der Array bereits von Beginn an nach dem Sortierkriterium sortiert ist.
            </p>
            <p>
                Die Berechnung von der Anzahl benötigter Vergleiche einer Datenfolge von der Länge <code>n</code>, lässt 
                sich wie folgt darstellen:
            </p>
            
            <code-block lang="tex">
                n-1+n-2+...+1=\frac{(n(n-1)))}{2}\in O(n^{2})
            </code-block>
            
            <p>
                Bubblesort Laufzeit als Überblick:
            </p>
            
            <list>
                <li>Worst-Case: <code>O(n^2)</code></li>
                <li>Average-Case: <code>O(n^2)</code></li>
                <li>Best-Case: <code>O(n)</code></li>
            </list>
        </chapter>
    </chapter>

    <chapter title="Bucketsort" id="bucketsort">
        <chapter title="Grundlagen" id="bucketsort-grundlagen">
            <p>
                Der Bucketsort ist ein <b>nicht-vergleichsbasierter Sortieralgorithmus</b>. Er sortiert eine Liste von
                gleichmäßig verteilten Elementen sehr schnell in linearer Zeit. Das Verfahren erfolgt dabei in drei
                Schritten:
            </p>

            <list style="decimal">
                <li>
                    Zuerst erstellen wir sogenannte <b>Buckets</b>, in die wir dann die <b>Elemente</b> der unsortierten
                    Liste <b>verteilen und ablegen</b>.
                </li>
                <li>
                    Jeder einzelne dieser <b>Eimer</b> wird dann <b>mit einem weiteren Sortierverfahren</b> sortiert.
                    Diese können etwa der <b>Mergesort</b> oder der <b>Insertionsort</b>.
                </li>
                <li>
                    Der <b>Inhalt</b> der einzelnen Buckets wird dann durch eine Konkatenation <b>zu einer neuen
                    Gesamtliste zusammengefügt</b>.
                </li>
            </list>

            <p>
                Da der Sortieralgorithmus Zwischenspeicher verwendet, arbeitet das Sortierverfahren somit
                <b>out-of-place</b>.
            </p>
        </chapter>

        <chapter title="Algorithmus" id="bucketsort-algorithmus">
            <p>
                Der <b>Bucketsort Algorithmus</b> lässt sich also folgendermaßen darstellen:
            </p>

            <list style="bullet">
                <li>
                    Für den Sortiervorgang wird einerseits eine zu sortierende Liste benötigt, zusätzlich aber auch eine
                    Funktion, die jedes Element des Arrays einem Wert in dem Intervall <code>[0,n]</code> zuordnen kann.
                    Die Liste selbst setzt sich dabei aus <code>n</code>-Elementen zusammen.
                </li>
                <li>
                    Zum Sortieren werden Buckets benötigt, die das Intervall <code>[0,1]</code> in <code>n</code>
                    Teilintervalle mit der Größe <code>1/n</code> unterteilen kann. Entsprechend kann damit dann jedes
                    Element in den zugehörigen Eimer einsortiert werden. Für jeden Bucket wird dann für seine jeweiligen
                    Inhalte ein <b>Insertionsort</b> durchgeführt (Es kann auch ein <b>Mergesort</b> verwendet werden!).
                    Die Inhalte werden dann mittels Konkatenation zu einer fertig sortierten Gesamtliste zusammengefügt.
                </li>
            </list>

            <chapter title="Pseudocode" id="bucketsort-algorithmus-pseudocode">
                <code-block>
                    Bucketsort (liste, funktion)
                        n = liste.size
                        bucket = intervall(n)
                            for (element in liste)
                                bucket[floor (funktion(element) * n].add(element)
                        ausgabearray []
                        for (inhalt in buckets)
                            x.insertionsort(inhalt)
                            ausgabearray.append(x)
                        return ausgabearray
                </code-block>
            </chapter>
        </chapter>

        <chapter title="Komplexität" id="bucketsort-komplexitaet">
            <p>
                Die Komplexität hängt von mehreren Faktoren ab. Zum einen von der Verteilung der Funktionswerte. Dabei
                beträgt die <code>O</code>-Notation
            </p>

            <code-block lang="tex">
                O(n)+\sum_{n-1}^{i=0} O(l*log*l)
            </code-block>

            <p>
                Im günstigsten Fall sind die einzelnen Elemente annähernd <b>gleichverteilt</b>. Dann benötigt das
                Zuweisen in die Buckets, ebenso wie die Konkatenation eine <b>Gesamtlaufzeit</b> von <code>O(n)</code>.
                Bei anderen Werteverteilungen kann die Laufzeit jedoch vom Sortierverfahren, das für die einzelnen
                Listen verwendet wird, dominiert werden – also dem Insertionsort oder Mergesort. Die Komplexität wird
                also im Fall dieses Sortierverfahrens von verschiedenen Faktoren beeinflusst. <code>O(n)</code>
                entspricht dabei auch gleichzeitig dem Average-Case.
            </p>
            <p>
                Im Falle der Verwendung eines <b>Mergesorts</b> als angewendetes Sortierverfahren innerhalb eines
                Buckets, beträgt die Laufzeitkomplexität <code>O(n*log*n)</code>.
            </p>
            <p>
                Die <b>Speicherplatzkomplexität</b> ist <code>O(n)</code>.
            </p>
        </chapter>
    </chapter>

    <chapter title="Counting Sort" id="countingsort">
        <chapter title="Grundlagen" id="countingsort-grundlagen">

            <chapter title="Eigenschaften" id="countingsort-grundlagen-eigenschaften">

            </chapter>
        </chapter>

        <chapter title="Funktionsweise" id="countingsort-funktionsweise">

            <chapter title="Pseudocode" id="countingsort-funktionsweise-pseudocode">

            </chapter>
        </chapter>

        <chapter title="Laufzeit" id="countingsort-laufzeit">

        </chapter>
    </chapter>

    <chapter title="Quellen" id="quellen">
        <tip>
            <b>(BUCH)</b>
            978-3836244763, "Handbuch für Softwareentwickler", Veikko Krypczyk &amp; Elena Bochkor, 2018
        </tip>
        <tip>
            <b>(WEBSEITE)</b>
            <a href="https://studyflix.de/informatik/bubblesort-1325" ignore-vars="true">
                https://studyflix.de/informatik/bubblesort-1325
            </a>, 2020-12-18 14:40
        </tip>
        <tip>
            <b>(WEBSEITE)</b>
            <a href="https://studyflix.de/informatik/bucketsort-1438" ignore-vars="true">
                https://studyflix.de/informatik/bucketsort-1438
            </a>, 2020-12-18 15:50
        </tip>
    </chapter>
</topic>