<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
        SYSTEM "https://resources.jetbrains.com/writerside/1.0/xhtml-entities.dtd">
<topic id="swe-pk-paradigmen-oop"
       title="OOP (Objektorientierte Programmierung)"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://resources.jetbrains.com/writerside/1.0/topic.v2.xsd">
    <show-structure depth="2" for="chapter,procedure"/>

    <chapter id="grundlagen" title="Grundlegendes">
        <p>
            Die objektorientierte Programmierung basiert darauf, Elemente der Software, in Anlehnung an die
            Gegebenheiten der realen Welt, als Objekte aufzufassen. Solche Objekte verfügen über Eigenschaften, die sie
            genauer charakterisieren. Ebenso können Objekte bestimmte Tätigkeiten ausführen. Objekte können miteinander
            kommunizieren und in einer bestimmten Beziehung zueinander stehen. Beispielsweise weisen ähnliche Objekte
            einen gleichen Bauplan auf.
        </p>
        <p>
            Der konkrete Umgang mit der Objektorientierung ist von Programmiersprache zu Programmiersprache
            unterschiedlich. Spätestens wenn ein konkretes Programm erstellt wird, wird man sich damit auseinandersetzen
            müssen. Das Grundverständnis von Klassen und ihren Objekten bleibt jedoch stets identisch.
        </p>

        <img alt="OOP - Beispiel" src="swe-pk-paradigmen-oop-meinauto.png"/>

        <chapter id="grundlagen-objekte" title="Objekte">
            <p>
                Objekte sind also konkrete Ausprägungen, eine Instanz, einer Klasse. Instanz könnte man übersetzen mit
                »gehört zur Klasse«: Entsprechend muss ein Objekt instanziiert werden. Dabei können von einer Klasse in
                der Regel beliebig viele Objekte, auch als Instanzen bezeichnet, erstellt werden. Die einzelnen Objekte
                können sich also in den konkreten Werten der Attribute unterscheiden.
            </p>
            <p>
                Zum Beispiel können die Objekte Toyota Avensis und VW Golf erstellt werden, welche beide die Klasse Auto
                verwenden. Sie unterscheiden sich in den Eigenschaften.
            </p>

            <chapter id="grundlagen-objekte-eigenschaften" title="Eigenschaften">
                <p>
                    Die Eigenschaften repräsentieren die Daten des Objekts. Ein Automobil ist je nach Sichtweise ein
                    mehr oder weniger komplexes Objekt, das sich durch folgende <b>Attribute (Eigenschaften)</b>
                    beschreiben lässt:
                </p>

                <list>
                    <li>Hersteller</li>
                    <li>Typ</li>
                    <li>Farbe</li>
                    <li>Zulassungsjahr</li>
                </list>

                <note>
                    Es gibt weitere Attribute, die uns aber bei der Abbildung als Modell für eine Software nicht
                    interessieren. Soll beispielsweise eine Verwaltung für den Fuhrpark eines Unternehmens programmiert
                    werden, so müssen die dafür relevanten Eigenschaften der Fahrzeuge erfasst werden. Dies könnten die
                    eben genannten Attribute sein. Nicht von Interesse für die Software ist dagegen, ob das Auto eine
                    schöne Fußmatte hat und ob im Handschuhfach eine Beleuchtung eingebaut ist.
                </note>

                <chapter id="grundlagen-objekte-eigenschaften-attribute" title="Attribute">
                    <p>
                        Als <b>Attribute</b> werden Variablen bezeichnet, die grundsätzlich nur innerhalb der Klasse
                        verwendet werden können. Sie sind daher als <code>private</code> deklariert. Will man auf die
                        Werte dieser Attribute von außerhalb des Objekts zugreifen, muss man das über Methoden
                        erledigen.
                    </p>
                </chapter>

                <chapter id="grundlagen-objekte-eigenschaften-properties" title="Properties">
                    <p>
                        Moderne Programmiersprachen, wie C#, kennen auch das Konzept der <b>Properties</b>. Über eine
                        Property kann von außen auf das zugeordnete Attribut zugegriffen werden. Die Property ist damit
                        als <code>public</code> deklariert. Der Zugriff kann lesend oder schreibend sein bzw. beide
                        Varianten umfassen.
                    </p>
                </chapter>
            </chapter>

            <chapter id="grundlagen-objekte-methoden" title="Methoden">
                <p>
                    Eine Methode enthält ähnlich wie eine Funktion, Funktionalität. Durch sie werden die Fähigkeiten
                    eines Objektes beschrieben, also welche Funktionen bzw. Aufgaben ein Objekt ausführen kann.
                </p>
                <p>
                    Methoden werden auch dazu verwendet, die Werte bestimmter Attribute zu verändern. Eine Methode
                    Lackieren der Klasse Auto könnte also eine Veränderung der Farbe bewirken. Als Argument müsste die
                    Methode die neue Farbe übermitteln. Aus unserem grauen Toyota könnte also mithilfe der Methode
                    Lackieren ein farbenfrohes blaues Automobil werden. Ebenso dienen Methoden dazu, dass man die Werte
                    von Attributen abfragen kann.
                </p>
                <p>
                    Auch ein Auto verfügt stets über bestimmte Fähigkeiten. Mit Bezug auf die zu entwickelnde Software
                    könnten folgende Methoden von Interesse sein:
                </p>

                <list>
                    <li><code>BehoerdlichZulassen</code>, d. h. Anmeldung bei der zuständigen Behörde, und</li>
                    <li><code>FahrtenbuchAnalysieren</code>.</li>
                </list>

                <note>
                    Natürlich verfügt das reale Objekt über viel mehr Funktionalität. Ein Automobil kann beispielsweise
                    beschleunigen und bremsen. In der Software bilden wir jedoch nur die interessierenden Methoden ab,
                    denn die Software ist ein stark vereinfachtes Modell der Wirklichkeit.
                </note>

                <chapter id="grundlagen-objekte-methoden-gettersetter" title="Getter und Setter">
                    <p>
                        In welcher Form man die Werte von Attributen ändern kann, ist von Programmiersprache zu
                        Programmiersprache etwas unterschiedlich. Historisch und in Anlehnung an die Grundidee der
                        objektorientierten Programmierung kann man von außerhalb eines Objekts nicht auf die Attribute
                        des Objekts direkt zugreifen, sie sind geheim. Dazu verwendet man Methoden. Wie man diese
                        Methoden benennt, spielt grundsätzlich keine Rolle. Zur Vereinfachung dieser Notwendigkeit
                        verwenden viele Sprachen spezielle Methoden, d. h. für das Lesen eine <code>get</code>- und für
                        das Schreiben eine <code>set</code>-Methode. Beispielsweise könnte man mit der Methode
                        <code>setFarbe</code> die Farbe des betreffenden Autoobjekts seinen Wünschen anpassen. Wollte
                        man die aktuelle Farbe wissen, müsste man den Wert über die Methode <code>getFarbe</code>
                        auslesen. Ebenso könnte man – wie im obigen Beispiel angeführt – eine Methode
                        <code>Lackieren</code> erstellen, die auch die Farbe anpasst und vielleicht darüber hinaus noch
                        etwas anderes macht, zum Beispiel eine Schutzversiegelung auf den Lack aufbringt.
                    </p>
                    <p>
                        Da ständig auf die Attribute der Objekte lesend und schreiben zugegriffen werden muss, haben
                        einige Programmiersprachen, zum Beispiel C#, noch mehr Vereinfachungen vorgesehen. Hier
                        definiert man sogenannte Properties. Dabei kann man von außerhalb der Klasse so tun, als ob man
                        direkt das betreffende Attribut liest oder schreibt. Im Hintergrund werden dazu jedoch weiterhin
                        <code>get</code>- und <code>set</code>-Methoden aufgerufen. Um den Entwicklern das Leben jedoch
                        zu erleichtern, werden diese <code>set</code>- und <code>get</code>-Methoden vom Compiler
                        automatisch bei der Erstellung des Programms generiert.
                    </p>
                </chapter>

                <chapter id="grundlagen-objekte-methoden-konstruktor" title="Konstruktor">
                    <p>
                        Der Konstruktor ist eine Methode, die ausgeführt wird, wenn ein Objekt einer Klasse erstellt
                        wird. Sie kann beliebige Parameter übernehmen, mit denen das Objekt instanziiert wird.
                    </p>
                </chapter>

                <chapter id="grundlagen-objekte-methoden-destruktor" title="Destruktor">
                    <p>
                        Die Destruktor-Methode kommt immer dann zum Einsatz, wenn ein Objekt aufgelöst wird.
                    </p>
                </chapter>

                <chapter id="grundlagen-objekte-methoden-ueberladen" title="Methoden Überladen">
                    <p>
                        Überladen bedeutet, eine Methode erhält mehr Parameter als vorgegeben oder Parameter mit
                        unterschiedlichen Datentypen. Zusammengefasst, es werden also Werte übergeben, die die Methode
                        so nicht kennen kann. Überladen ist als Programmiertechnik ausgesprochen praktisch, da eine
                        Methode mit verschiedenen Situationen umgehen kann, für die normalerweise mehrere Methoden
                        notwendig wären.
                    </p>
                </chapter>
            </chapter>

            <chapter id="grundlagen-objekte-garbagecollector" title="Garbage Collector">
                <p>
                    Nachdem ein Objekt einer Klasse durch einen Konstruktor erstellt wurde, wird es im Speicher
                    vorgehalten. Es sollte mindestens so lange existieren, wie es noch benötigt wird. Das ist der Fall,
                    wenn noch auf das Objekt zugegriffen wird. Da einzelne Objekte einen beachtlichen Speicherbedarf
                    haben können, sollten nicht mehr benötigte Objekte wieder gelöscht werden.
                </p>
                <p>
                    Je nach Programmiersprache ist man entweder als Entwickler selbst für das Löschen nicht mehr
                    benötigter Objekte zuständig, oder das System erledigt dies automatisch. Ersteres ist aufwendig und
                    fehleranfällig. Die zweite Variante ist komfortabel und befreit den Entwickler vor lästiger
                    Routinearbeit. Das System der automatischen Speicherfreigabe für nicht mehr benötigte Objekte wird
                    als <b>Garbage-Collection</b> bezeichnet.
                </p>
            </chapter>
        </chapter>

        <chapter id="grundlagen-klassen" title="Klassen">
            <p>
                Ein konkretes Objekt gehört zu einer Klasse oder andersherum betrachtet, eine Klasse ist der Bauplan
                bzw. die Struktur für die zugehörigen Objekte. Mit Struktur sind die Eigenschaften und Methoden des
                Objekts gemeint.
            </p>
            <p>
                Konkretisiert man ein Auto anhand seiner spezifischen Attribute, so gelangt man zum Objektbegriff.
                Konkret: Das Fahrzeug mit dem Kennzeichen EF-LN 88 ist ein konkretes Objekt der Klasse Auto. Dabei weist
                es die folgenden Werte der oben genannten Attribute auf:
            </p>

            <code-block>
                Hersteller = "Toyota";
                Typ = "Avensis";
                Farbe = "grau";
                Zulassungsjahr = 2012;
            </code-block>

            <p>
                Ein anderes Objekt der Klasse Auto hat andere Werte bezüglich dieser Attribute, beispielsweise:
            </p>

            <code-block>
                Hersteller = "VW";
                Typ = "Golf";
                Farbe = "rot";
                Zulassungsjahr = 2014;
            </code-block>

            <p>
                Beide Objekte verfügen also über die gleichen Attribute, aber gegebenenfalls über andere Werte dieser
                Attribute. Sowohl der Toyota als auch der VW kennen die beiden oben genannten Methoden
                <code>BehoerdlichZulassen</code> und <code>FahrtenbuchAnalysieren</code>.
            </p>
        </chapter>

        <chapter id="grundlagen-ereignisse" title="Ereignisse">
            <p>
                Ereignisse gehören streng betrachtet nicht zu den Grundpfeilern der objektorientierten Programmierung,
                sondern zum Konzept der ereignisorientierten Entwicklung von Programmen. Es ist jedoch mit dem Konzept
                der Klassen und Methoden eng verbunden.
            </p>
            <p>
                Beispiele für Ereignisse:
            </p>

            <list>
                <li>
                    Ein Objekt der Klasse Auto ein Ereignis auslösen, wenn in den nächsten vier Wochen der TÜV abläuft.
                    Die Software könnte in diesem Fall mit einem Hinweis den Bearbeiter auf diesen Umstand aufmerksam
                    machen.
                </li>
                <li>
                    Wenn der Nutzer auf ein Element der Benutzeroberfläche, zum Beispiel auf einen Button, klickt. Das
                    zugehörige Ereignis heißt in diesem Fall zum Beispiel <code>ButtonClick</code>-Ereignis.
                </li>
                <li>
                    Wischgesten bei einer Anwendung für Smartphone oder Tablet bzw. Mausbewegungen bei einem
                    Zeichenprogramm.
                </li>
            </list>

            <p>
                Ein Ereignis wird von einem Objekt in einer bestimmten Situation ausgelöst. Grundsätzlich stellen
                Ereignisse die Grundlagen für die Interaktionsfähigkeit der Anwendung dar. Um gegenseitig auf Ereignisse
                zu reagieren, registrieren sich die Objekte untereinander. Beispielsweise kann ein Objekt A sich beim
                Objekt B für ein bestimmtes Ereignis registrieren. Löst Objekt A dieses Ereignis aus, so bekommt Objekt
                B das mit und kann seinerseits ein bestimmtes Verhalten auslösen.
            </p>

            <img alt="Ereignisse" src="swe-pk-paradigmen-oop-ereignisse.png"/>

            <p>
                Auf der linken Seite haben wir die Quelle (eng.
                <emphasis>Source</emphasis>
                ), in Form eines konkreten
                Objekts einer Klasse. Diese Quelle feuert in einer bestimmten Situation ein Ereignis
                (eng.
                <emphasis>Event</emphasis>
                ) ab. Beispielsweise könnte die Quelle ein Button sein, der auf das
                Klicken durch den Nutzer reagiert. Andere Objekte – auch als <b>Listener</b> bezeichnet – »lauschen«
                darauf, dass das betreffende Ereignis ausgelöst wird. Ist dies der Fall, dann reagieren sie in
                vorgesehener Art und Weise. Dabei können mehrere Listener parallel das Auslösen eines bestimmten
                Ereignisses überwachen. Ein Objekt der Klasse Berechnungen könnte eine neue Berechnung starten, sobald
                der Nutzer auf den Button geklickt hat. Gleichzeitig könnte ein Objekt der Benutzeroberfläche darauf
                reagieren und dem Nutzer mitteilen, dass nunmehr der Rechenvorgang gestartet wurde.
            </p>
        </chapter>

        <chapter id="grundlagen-modellierung" title="Modellierung von Klassen und Objekten">
            <p>
                Zur Modellierung einzelner Klassen bzw. zur Darstellung der Beziehung von Klassen untereinander
                verwendet man in der Software-Entwicklung häufig sogenannte »Klassendiagramme« der Modellierungssprache
                UML (Unified Modelling Language), die Beziehung von Objekten stellt man dagegen in sogenannten
                »Objektdiagrammen« dar.
            </p>
        </chapter>
    </chapter>

    <chapter id="datentypen-unterschiede" title="Unterschied zwischen primitiven Datentypen und Referenztypen">
        <p>
            Der Unterschied zwischen primitiven Datentypen und Referenztypen ist die Art und Weise, wie die jeweiligen
            Werte gespeichert werden.
        </p>

        <list>
            <li>
                Jedes Mal, wenn eine Variable deklariert wird, sieht der Computer dafür Speicherplatz vor und speichert
                die Variable inklusive Wert in einer dafür vorgesehenen Speicheradresse. Beim primitiven Datentyp wird
                jedes Mal, wenn einer Variable ein Wert zugewiesen wird, der gesamte Wert in diese Speicheradresse
                kopiert.
            </li>
            <li>
                Bei Referenztypen ist dies anders. Hier speichert der Computer in dem für die jeweilige Variable
                vorgesehenen Register nicht den Wert selbst, sondern nur eine Referenz darauf (man spricht in diesem
                Fall auch von Zeigern). Wenn zwei oder mehrere Variablen auf das gleiche Objekt zeigen, bedeutet das
                aber auch, dass man – egal, auf welche der Variablen man zugreift – immer mit dem gleichen Objekt
                arbeitet: Ändert man also, über eine der Variablen eine Eigenschaft des referenzierten Objekts, hat dies
                auch Auswirkungen auf die andere Variable.
            </li>
        </list>

        <p>
            Übergibt man einer Funktion ein Argument primitiven Datentyps, wird der gesamte Wert übergeben und in den
            Parameter der Funktion kopiert. Übergibt man einer Funktion dagegen ein Argument mit Referenztyp, wird nur
            die Referenz auf das entsprechende Objekt übergeben.
        </p>
    </chapter>

    <chapter id="konzepte" title="Wesentliche Konzepte der objektorientierten Programmierung">
        <img alt="Konzepte" src="swe-pk-paradigmen-oop-konzepte.png"/>

        <warning>
            Nicht jedes Prinzip wird in gleicher Art und Weise von jeder Programmiersprache umgesetzt. Hier gibt es
            Abweichungen und unterschiedliche Herangehensweisen.
        </warning>

        <chapter id="konzepte-kapselung" title="Kapselung">
            <p>
                Unter dem Begriff Datenkapselung (bzw. im Englischen
                <emphasis>Encapsulation</emphasis>
                oder auch
                <emphasis>Information Hiding</emphasis>
                ) versteht man in der Objektorientierung das Zusammenfassen von
                Eigenschaften und Methoden zu Klassen bzw. Prototypen, wobei die Details der Implementierung verborgen
                bleiben: In der Regel stellt man die Eigenschaften nur über sogenannte Setter- und Getter-Methoden zur
                Verfügung. Solche Zugriffsmethoden (eng.:
                <emphasis>Accessor Methods</emphasis>
                oder einfach
                <emphasis>Accessors</emphasis>
                ) können davor schützen, dass einer Eigenschaft ungültige Werte zugewiesen
                werden. Erlaubt man dagegen einen direkten Zugriff auf die Eigenschaften (und erfüllt damit nicht das
                Prinzip der Datenkapselung), ist dies nicht gewährleistet, da dann auch Werte zugewiesen werden können,
                die
                nicht gültig sind. Der Datenzugriff wird bei einigen Programmiersprachen auch über spezielle Felder
                geregelt, die jedoch wiederum intern auf <code>get</code>- und <code>set</code>-Methoden zurückgreifen.
                In
                Programmiersprachen wie Java kann man über spezielle Schlüsselwörter verhindern, dass die Werte von
                Eigenschaften von außen (d. h. von außerhalb einer Objektinstanz) geändert werden können (und zwar,
                indem
                sie über das Schlüsselwort private als privat markiert werden).
            </p>

            <img alt="Konzept: Kapselung" src="swe-pk-paradigmen-oop-kapselung.png"/>

            <chapter id="konzepte-kapselung-eigenschaften" title="Dateneigenschaften und Zugriffseigenschaften">
                <p>
                    Dateneigenschaften bezeichnen solche Eigenschaften, auf die direkt zugegriffen wird, d.h. ohne
                    Getter- und Setter-Methoden. Zugriffseigenschaften definieren Funktionen, die beim Lesen und
                    Schreiben der entsprechenden Eigenschaft aufgerufen werden (sprich Getter- und Setter-Methoden).
                </p>
            </chapter>
        </chapter>

        <chapter id="konzepte-sichtbarkeit" title="Geheimnisprinzip / Sichtbarkeit">
            <p>
                Das <b>Geheimnisprinzip</b> besagt, dass ein Objekt nach außen nur die Informationen und Methoden
                bereitstellt, die zur Anwendung notwendig sind. Klassen sowie deren Attribute und Methoden können
                unterschiedliche <b>Sichtbarkeiten</b> aufweisen. Die Sichtbarkeit wird durch den Modifizierer, dem
                jeweiligem Schlüsselwort, bestimmt.
            </p>

            <chapter id="konzepte-sichtbarkeit-geheimnisprinzip" title="Das Geheimnisprinzip">
                <p>
                    Ein Beispiel: Alle Objekte der Klasse Auto verfügen über die Methode
                    <code>FahrtenbuchAnalysieren</code>. Für einen Benutzer ist es nicht von Interesse, wie dies
                    innerhalb der Klasse umgesetzt wird. Es interessiert nur, dass der Aufruf der Methode zum
                    gewünschten Ergebnis führt. Die Funktionsweise der Klasse wirkt nach außen wie eine Black Box.
                </p>

                <img alt="Konzepte: Geheimnisprinzip" src="swe-pk-paradigmen-oop-geheimnisprinzip.png"/>

                <p>
                    Das Prinzip der Black Box hat hier mehrere Bedeutungen. Möchte man die Funktionalität einer Klasse
                    bzw. seiner Objekte nutzen, muss man in keiner Weise dabei wissen, wie die Verarbeitung intern
                    funktioniert. Dieses Prinzip ist essenziell für die Wiederverwendung von Programmcode.
                </p>
                <p>
                    Als Entwickler ist es üblich, für viele Standardaufgaben die Funktionalität einer allgemein zu
                    verwendenden Klasse zu nutzen, beispielsweise einen speziellen Such-Algorithmus, der als Methode
                    einer Klasse implementiert sein kann. Diese Algorithmen können sehr kompliziert sein, wie wir im
                    kommenden Kapitel sehen werden. Die wirkliche Funktionsweise müssen wir jedoch nicht kennen. Es
                    kommt lediglich darauf an, welche Inputdaten wir an den Algorithmus übergeben und welches Ergebnis
                    wir zurückbekommen. Auch wenn zu einem späteren Zeitpunkt die Klasse aktualisiert wird, weil
                    beispielsweise der verwendete Such-Algorithmus gegen ein leistungsfähigeres Exemplar ausgetauscht
                    wird, ist das Geheimnisprinzip wichtig. Die Klasse kann problemlos in der ursprünglichen Form
                    weiterverwendet werden. Dabei muss man sicherstellen, dass die Schnittstellen gegenüber der
                    vorherigen Version unverändert bleiben. Die technische Umsetzung innerhalb der Klasse kann dabei
                    angepasst werden.
                </p>
            </chapter>

            <chapter id="konzepte-sichtbarkeit-sichtbarkeit" title="Die Sichtbarkeit">
                <p>
                    Die Sichtbarkeit bestimmt, welche Elemente eines Objekts für andere Objekte sichtbar sind. Die
                    beiden Extreme lauten:
                </p>

                <list>
                    <li><code>private</code>: Das Element ist nur innerhalb der Klasse sichtbar.</li>
                    <li><code>public</code>: Das Element ist für alle anderen Objekte sichtbar.</li>
                </list>

                <p>
                    Beispielsweise werden Attribute, die nur für eine Berechnung innerhalb einer Methode benutzt werden,
                    als <code>private</code> definiert. Soll auf die Daten eines Objekts auch von außen zugegriffen
                    werden, so ist das Element als <code>public</code> zu kennzeichnen. Für die Klasse PKW könnte es
                    beispielsweise sinnvoll sein, die Property Leistung als <code>public</code> zu definieren, denn so
                    können andere Objekte diesen Wert erfragen. Je nach Programmiersprache kann man zwischen den beiden
                    Extremen <code>public</code> und <code>private</code> weitere Abstufungen in den Sichtbarkeiten
                    definieren. Beispielsweise könnte das Schlüsselwort <code>protected</code> darauf hinweisen, dass
                    ein Zugriff von außen auf das Klassenelement möglich, aber nur innerhalb des Moduls erlaubt ist.
                </p>
            </chapter>
        </chapter>

        <chapter id="konzepte-vererbung" title="Vererbung">
            <p>
                Mithilfe der <b>Vererbung</b> (eng.:
                <emphasis>Inheritance</emphasis>
                ) können Attribute und Methoden
                einer übergeordneten Klasse auf nachgelagerte Klassen vererbt bzw. abgeleitet werden. Das bedeutet, es
                können Hierarchien von Klassen erstellt werden, die untereinander in Beziehung stehen. Die erbende
                Klasse bzw. ableitende Klasse nennt man dabei auch Unterklasse, die vererbende Klasse auch Oberklasse.
            </p>

            <img alt="Konzepte: Vererbung" src="swe-pk-paradigmen-oop-vererbung.png"/>

            <p>
                Die Klasse <code>Fahrzeug</code> enthält die Attribute <code>Fahrzeuglänge</code>,
                <code>Höchstgeschwindigkeit</code> und <code>maximaleLeistung</code> und ebenso die Methoden
                <code>bremsen</code> und <code>beschleunigen</code>. Die Klasse <code>Fahrzeug</code> ist eine
                sogenannte Oberklasse. Von dieser Klasse werden andere Klassen abgeleitet. In diesem Fall sind dies die
                Klassen <code>Hybridauto</code>, <code>Elektroauto</code>, <code>Benzinauto</code> und
                <code>Dieselauto</code>. Alle abgeleiteten Klassen verfügen automatisch über dieselben Attribute und
                Methoden wie die Oberklasse. Dieses Prinzip nennt man Vererbung. In den abgeleiteten Klassen muss man
                dann nur die zusätzlichen Attribute und Methoden hinzufügen. Beispielsweise werden der Klasse
                <code>Hybridauto</code> die Methoden <code>BenzinTanken</code> und <code>StromLaden</code> hinzugefügt.
                Wie gesagt, auch diese Klasse kennt die Methoden bremsen und <code>beschleunigen</code>.
            </p>
            <warning>
                Die Vererbung von Klassen bzw. Objekten repräsentiert eine Ist-ein-Beziehung: Eine Instanz von
                Elektroauto ist auch gleichzeitig eine Instanz von Fahrzeug. Umgekehrt gilt dies allerdings nicht: Eine
                Instanz von Fahrzeug ist nicht zwangsläufig eine Instanz von Elektroauto.
            </warning>
        </chapter>

        <chapter id="konzepte-abstraktion" title="Abstraktion &amp; Generalisierung / Spezialisierung">
            <p>
                Klassen oder Prototypen definieren in der objektorientierten Programmierung die Grundlage für mehrere
                Objektinstanzen, die über einen ähnlichen Zustand und ein ähnliches Verhalten verfügen. Klassen und
                Prototypen können demnach auch als Abstraktion (eng.:
                <emphasis>Abstraction</emphasis>
                ) der (konkreten)
                Objektinstanzen angesehen werden. In Klassen und Prototypen wird das abstrakte Verhalten definiert (das
                allen Objektinstanzen gemeinsam ist) bzw. die Eigenschaften, die den Zustand repräsentieren (und
                ebenfalls allen Objektinstanzen gemeinsam sind). In den Objektinstanzen werden dann die Eigenschaften
                mit konkreten Werten belegt, und damit wird der konkrete Zustand definiert.
            </p>

            <chapter id="konzepte-abstraktion-generalisierung" title="Generalisierung / Spezialisierung">
                <p>
                    Die Zuordnung von Attributen und Methoden zu Ober- und Unterklassen folgt dabei den Prinzipien von
                    Generalisierung und Spezialisierung.
                </p>

                <img alt="Konzepte: Generalisierung" src="swe-pk-paradigmen-oop-generalisierung.png"/>

                <p>
                    Innerhalb einer Klassenhierarchie sollten Attribute und Methoden so weit wie möglich oben angeordnet
                    werden: Wenn alle Unterklassen über ein bestimmtes Merkmal verfügen, dann sollte dieses in die
                    Oberklasse angeordnet werden, und die Unterklassen übernehmen dieses Merkmal automatisch per
                    Vererbung. Auf diese Weise braucht man bestimmte Sachverhalte nur einmal codieren, d. h., man
                    vermeidet Wiederholungen und Fehleranfälligkeiten. Bitte beachten Sie ebenfalls, dass eine
                    Klassenhierarchie über viele Ebenen gebildet werden kann, d. h., Attribute und Methoden können sich
                    in diesem Fall über mehrere Ebenen vererben.
                </p>
                <p>
                    Ebenso muss man bei der Erstellung einer eigenen Klassenbibliothek beachten, dass zwischen Ober- und
                    Unterklassen auch wirklich ein inhaltlicher Zusammenhang besteht. Man sollte also nur da Objekte in
                    eine Hierarchie bringen, wo es auch Sinn macht. Obwohl die Objekte <code>Hund</code> und
                    <code>Tisch</code> beide über <code>Beine</code> verfügen, sollte man sie nicht als Unterklassen
                    einer gemeinsamen Oberklasse mit dem Attribut <code>AnzahlBeine</code> bilden. Das ergibt inhaltlich
                    wenig Sinn und verwirrt bei der Programmentwicklung.
                </p>
                <warning>
                    Die Klassenhierarchie sollte ein modellhaftes Abbild eines Realitätsausschnitts sein. Hier kommt ja
                    auch niemand auf die Idee, einen Hund und einen Tisch einer gemeinsamen Kategorie zuzuordnen.
                </warning>

                <chapter collapsible="true" id="konzepte-abstraktion-generalisierung-beispiel"
                         title="Weiteres Beispiel">
                    <img alt="Konzepte: Generalisierung Beispiel"
                         src="swe-pk-paradigmen-oop-generalisierung-beispiel.png"/>

                    <p>
                        Das Beispiel stammt aus einem vektorbasierten Grafikprogramm. Hier können wir einige
                        interessante Beobachtungen machen:
                    </p>

                    <list>
                        <li>
                            <b>Zweck</b>: Die Klassenhierarchie ordnet typische Zeichenobjekte der Ebene in eine
                            mehrstufige Vererbungsbeziehung zueinander. Ein Beispiel: Die Klassen <code>Triangle</code>
                            (Dreieck) und <code>Quadrangle</code> (Viereck) sind spezielle Klassen der abstrakten Klasse
                            <code>nAngle</code> (Vieleck). Man kann also kein Objekt der Klasse <code>nAngle</code>
                            erzeugen, aber durchaus ein Objekt der Klasse <code>Triangle</code>. Für die anderen Klassen
                            gelten ähnliche Zusammenhänge.
                        </li>
                        <li>
                            <b>Ober-/Unterklassen</b>: die oberste Basisklasse für die Zeichenobjekte ist die Klasse
                            <code>Figure</code>. Sie ist ebenfalls abstrakt und leitet von einer weiteren Klasse,
                            <code>BasicObject</code>, ab. Die Klasse <code>BasicObject</code> enthält alle essenziellen
                            Methoden zum Zeichnen. Sie könnte weitere Unterklassen außer <code>Figure</code> haben, die
                            hier nicht dargestellt werden.
                        </li>
                    </list>
                </chapter>
            </chapter>

            <chapter id="konzepte-abstraktion-abstrakteklassen" title="Abstrakte Klassen">
                <p>
                    Abstrakte Klassen sind Klassen, die als Oberklassen fungieren, jedoch können von solchen Klassen
                    selbst keine Objekte erstellt werden.
                </p>
                <p>
                    Die Klasse <code>Fahrzeug</code> könnte zum Beispiel als abstrakte Klasse ausgeführt werden. Ein
                    Objekt der allgemeinen Klasse <code>Fahrzeug</code> ergibt in der Regel keinen Sinn. Ein Fahrzeug
                    ist stets ein konkretes Fahrzeug des Typs <code>Benzinauto</code>, <code>Dieselauto</code>,
                    <code>Hybridauto</code> oder <code>Elektroauto</code>. Die Klasse <code>Fahrzeug</code> sammelt
                    daher alle Attribute und Methoden, die für alle Fahrzeugtypen gelten, selbst kann sie aber nicht als
                    Bauplan für ein konkretes Objekt stehen.
                </p>
            </chapter>
        </chapter>

        <chapter id="konzepte-polymorphismus" title="Polymorphismus">
            <p>
                Das Prinzip der Polymorphie ist einfach und genial zugleich. Objekte verschiedener Klassen müssen
                gelegentlich gleiche Funktionen ausführen. Mithilfe der Polymorphie ist es möglich, in einer Oberklasse
                eine allgemein verwendbare Methode zu definieren und auch diese mit entsprechendem Quellcode zu
                versehen. Abgeleitete Unterklassen haben dann grundsätzlich zwei Optionen:
            </p>

            <list>
                <li>
                    Sie verwenden die Methode der Oberklasse.
                </li>
                <li>
                    Sie können eine eigene Methode mit gleichem Namen definieren und gewissermaßen die Methode der
                    Oberklasse überschreiben.
                </li>
            </list>

            <p>
                Damit gilt folgendes Prinzip: Beim Aufruf einer Methode wird immer geprüft, ob es eine speziellere
                Methode der zugehörigen Klasse gibt. Ist das nicht der Fall, dann wird die Methode der Oberklasse
                verwendet. Es gilt also: Eine spezielle Implementierung (Attribut oder Methode) hat stets Vorrang vor
                einer allgemeineren (generischen) Implementierung.
            </p>
            <p>
                Es kann auch eine abstrakte Methode in der Oberklasse definiert werden, welche nur als Platzhalter für
                die Unterklassen dient. Sie enthält keinen Code. Erbt eine Klasse von einer Klasse welche eine abstrakte
                Methode definiert hat, so zwingt der Compiler die Unterklasse jene Methode zu implementieren.
            </p>
            <note>
                Objektinstanzen einer Unterklasse können wie Objektinstanzen der jeweiligen Oberklasse behandelt werden.
            </note>

            <chapter id="konzepte-polymorphismus-beispiel" title="Beispiel">
                <img alt="Konzepte: Polymorphismus" src="swe-pk-paradigmen-oop-polymorphismus.png"/>

                <p>
                    Im Beispiel ist eine Oberklasse <code>Buch</code> und zwei abgeleitete Klassen <code>Fachbuch</code>
                    und <code>Hoerbuch</code> zu sehen. Die abstrakte Methode <code>info()</code> der Klasse
                    <code>Buch</code> liefert eine Zeichenkette vom Datentyp <code>String</code>, die eine Information
                    zum Buch ausgibt. Nur Objekte der abgeleiteten Klassen <code>Fachbuch</code> und
                    <code>Hoerbuch</code> verfügen über die entsprechenden Daten, um Informationen auszugeben. Dazu wird
                    jeweils eine Methode <code>info()</code> in den Klassen Fachbuch und <code>Hoerbuch</code>
                    definiert. Diese Methoden enthalten dann auch den jeweils spezifischen Quellcode.
                </p>

                <code-block lang="java">
                    Buch einBuch = new Fachbuch();
                </code-block>

                <p>
                    Der Variablen <code>einBuch</code> wird ein Objekt von der Klasse <code>Fachbuch</code> zugeordnet.
                    Später ist es durchaus erlaubt, das Objekt neu zuzuweisen, vielleicht dieses Mal als
                    <code>Hoerbuch</code>. Wir würden dann schreiben:
                </p>

                <code-block lang="java">
                    einBuch = new Hoerbuch();
                </code-block>

                <p>
                    Egal zu welchem Zeitpunkt, es kann jederzeit die Methode <code>info()</code> aufgerufen werden. Je
                    nachdem, ob es sich um ein Objekt der Klasse <code>Fachbuch</code> oder der Klasse
                    <code>Hoerbuch</code> handelt, wird die korrekte Methode aufgerufen.
                </p>
                <p>
                    Zusammengefasst: Das Prinzip der Polymorphie sorgt also dafür, dass der Compiler stets die richtigen
                    Attribute und Methoden auswählt. Würden wir unsere kleine Klassenbibliothek später um eine Klasse
                    <code>Roman</code> ergänzen, dann müsste auch diese eine Methode <code>info()</code> haben. Es
                    würden sich nicht die Konventionen ändern, man braucht auch wieder nur die Methode
                    <code>info()</code> aufrufen, und man bekommt dann die Informationen zum Roman angezeigt.
                </p>
            </chapter>
        </chapter>
    </chapter>

    <chapter id="wiederverwendung" title="Wiederverwendung">
        <p>
            Die objektorientierte Programmierung fördert insbesondere den Ansatz der Wiederverwendung. Quellcode zur
            Lösung allgemeiner Probleme kann und sollte für ähnliche Fragestellungen zur Verfügung gestellt werden. Dies
            geschieht in Form von Klassenbibliotheken, die als Referenzen in Projekte eingebunden werden.
        </p>
        <p>
            Bei der objektorientierten Programmierung führt es dann zu folgendem beschriebenen grundsätzlichen
            Systemaufbau:
        </p>

        <img alt="Konzepte: Wiederverwendung" src="swe-pk-paradigmen-oop-wiederverwendung.png"/>

        <p>
            Ausgangsbasis ist die jeweilige Programmiersprache, die die Prinzipien der objektorientierten Programmierung
            möglichst umfassend unterstützt. Die Software als Modell wird dann in Form einer Klassenbibliothek
            umgesetzt. Dabei wäre es natürlich möglich, sämtliche Funktionalität vollständig neu zu implementieren. Das
            wäre jedoch nicht sinnvoll und nicht effektiv. Viele Aufgaben der Programmentwicklung sind wiederkehrend.
            Typische Beispiele sind:
        </p>

        <list>
            <li>
                Benutzeroberflächen bestehen in fast allen Programmen aus ähnlichen Komponenten wie Buttons, Labels oder
                Textboxen.
            </li>
            <li>
                Funktionen wie Dateioperationen oder Suchfunktionen werden immer wieder benötigt.
            </li>
        </list>

        <p>
            Es ergibt also Sinn, den Quellcode in einer wiederverwendbaren Form zu schreiben und in allgemein
            zugänglichen Klassenbibliotheken abzulegen. Ein Programm nutzt dabei also eigene und vorhandene
            Softwarekomponenten. Alle eigenen und fremden Softwarekomponenten werden dabei üblicherweise in einem
            Projekt zusammengefasst.
        </p>

        <chapter id="wiederverwendung-bibliotheken" title="Verwaltung der Bibliotheken">
            <p>
                Die Verwaltung der Bibliotheken und deren Abhängigkeiten untereinander muss man dabei üblicherweise
                nicht per Hand vornehmen. Dabei helfen komfortable Programmierwerkzeuge in Form von integrierten
                Entwicklungsumgebungen (IDE). Damit man die Bibliotheken nicht mühsam an unendlich vielen Orten
                zusammensuchen muss, werden diese in zentralen Repositorien bereitgestellt. Entwickler können die
                gewünschten Bibliotheken suchen, in ihr Projekt einbinden sowie gegenseitige Abhängigkeiten verwalten
                und auflösen. Bei Aktualisierungen wird man benachrichtigt.
            </p>

            <chapter id="wiederverwendung-bibliotheken-beispiel" title="Beispiel (VisualStudio)">
                <img alt="Konzepte: Bibliotheken (Beispiel: VisualStudio)"
                     src="swe-pk-paradigmen-oop-bibliotheken-beispiel-visualstudio.png"/>

                <p>
                    Wir sehen die Entwicklungsumgebung Visual Studio. Am rechten Rand ist der Projektmappen-Explorer
                    eingeblendet, der alle Bestandteile des aktuellen Projekts zeigt. Unterhalb von Verweise sehen Sie,
                    welche externen Bibliotheken im aktuellen Projekt eingebunden sind. In diesem Fall sind es die
                    beiden Bibliotheken <code>Microsoft.NetCore.UniversalWindowsPlatform</code> und
                    <code>Microsoft.Xaml.Behavios.Uwp.Managed</code>. Deren Funktionen spielen jetzt nur eine
                    untergeordnete Rolle. Es sind zwei grundsätzliche Bibliotheken zum Erstellen von Apps für die
                    Universal Windows Platform. Im linken Teilbereich des Fensters sehen Sie den NuGet-Paketmanager. Mit
                    dessen Hilfe werden die Bibliotheken zentral verwaltet. Die Entwickler der Bibliotheken können ihn
                    über einen zentralen Server anderen Entwicklern zur Verfügung stellen. Mittels des NuGet-Managers
                    kann man auf öffentlich zugängliche Bibliotheken über das Internet zugreifen. Alternativ können
                    Softwareentwicklungsunternehmen ihre eigenen Softwarebibliotheken aufbauen und auf einem eigenen
                    Unternehmensserver verwalten.
                </p>
            </chapter>
        </chapter>

        <chapter id="wiederverwendung-komponenten" title="Softwarekomponenten">
            <p>
                Je nach Programmtyp und Vorgehensweise wird also bei der Erstellung eines neuen Projekts ein bestimmtes
                Set an vorhandene Softwarekomponenten zur Nutzung direkt angebunden. Weitere Bibliotheken werden dann
                während der Programmentwicklung durch den Softwareentwickler verwendet. Diese Softwarekomponenten können
                vom Hersteller der Programmiersprache, von sogenannten Drittanbietern und aus eigenen früheren Projekten
                stammen. Üblicherweise ist es so, dass ein Projekt letztendlich auf einen Großteil von bereits
                vorhandenen Softwarekomponenten zugreifen kann. Nur die spezifische Funktionalität eines Programms wird
                dann neu entwickelt. Tatsächlich ist es erst dadurch möglich, die immer weiter steigenden Anforderungen
                an neue Software in Sachen Umfang und Komplexität zu bewältigen.
            </p>

            <chapter id="wiederverwendung-komponenten-beispiel-dotnet" title="Beispiel (.NET-Framework)">
                <p>
                    Ein sehr gutes Beispiel ist das .Net-Framework, das eine sehr umfassende Klassenbibliothek mit
                    mehreren Tausend Klassen für ein sehr breites Anwendungsspektrum bereitstellt. Für nahezu alle
                    möglichen Anwendungsszenarien finden sich bereits vorgefertigte Implementierungen, auf die bei der
                    Programmierung der eigenen Anwendung dann zurückgegriffen werden kann.
                </p>
            </chapter>

            <chapter id="wiederverwendung-komponenten-beispiel-java" title="Beispiel (Java)">
                <img alt="Wiederverwendung: Java Komponenten" src="swe-pk-paradigmen-oop-komponenten-java.png"/>

                <p>
                    Ein weiteres Beispiel ist die Umsetzung von grafischen Benutzeroberflächen für
                    Standardapplikationen. Diese bestehen aus typischen Elementen wie speziellen Buttons,
                    Menü-Elementen, Textfeldern usw. Programmiert man in Java, so steht dem Entwickler auch hier eine
                    umfassende Klassenbibliothek zur Verfügung. Selbstverständlich findet man online bei den Herstellern
                    der Bibliotheken die entsprechenden Dokumentationen. Für einen ersten Überblick bzw. bei der
                    späteren Verwendung ist es jedoch äußert hilfreich, sich die relevanten Zusammenhänge in einem
                    vereinfachten Klassendiagramm anzusehen.
                </p>
                <p>
                    Diese Grafik (rechts) zeigt einen solchen Ausschnitt für die Java-Klassenbibliothek zum Erstellen
                    von grafischen Benutzeroberflächen. Anhand eines solchen Klassendiagramms kann man erkennen, wie die
                    konkreten Klassen als Ober- und Unterklassen zusammenhängen.
                </p>
            </chapter>
        </chapter>
    </chapter>

    <chapter id="quellen" title="Quellen">
        <tip>
            <b>(BUCH)</b>
            978-3836244763, "Handbuch für Softwareentwickler", Veikko Krypczyk &amp; Elena Bochkor, 2018
        </tip>
        <tip>
            <b>(BUCH)</b>
            978-3836240826, "PHP 7 und MySQL - Das umfassende Handbuch", Christian Wenz &amp; Tobias Hauser, 2016
        </tip>
        <tip>
            <b>(BUCH)</b>
            978-3836256971, "JavaScript - Das umfassende Handbuch", Philip Ackermann, 2018
        </tip>
    </chapter>
</topic>