<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
        SYSTEM "https://resources.jetbrains.com/writerside/1.0/xhtml-entities.dtd">
<topic xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="https://resources.jetbrains.com/writerside/1.0/topic.v2.xsd"
       title="OOP (Objektorientierte Programmierung)" id="swe-pk-paradigmen-oop">
    <show-structure for="chapter,procedure" depth="2"/>

    <chapter title="Grundlegendes" id="grundlagen">
        <p>
            Die objektorientierte Programmierung basiert darauf, Elemente der Software, in Anlehnung an die
            Gegebenheiten der realen Welt, als Objekte aufzufassen. Solche Objekte verfügen über Eigenschaften, die sie
            genauer charakterisieren. Ebenso können Objekte bestimmte Tätigkeiten ausführen. Objekte können miteinander
            kommunizieren und in einer bestimmten Beziehung zueinander stehen. Beispielsweise weisen ähnliche Objekte
            einen gleichen Bauplan auf.
        </p>
        <p>
            Der konkrete Umgang mit der Objektorientierung ist von Programmiersprache zu Programmiersprache
            unterschiedlich. Spätestens wenn ein konkretes Programm erstellt wird, wird man sich damit auseinandersetzen
            müssen. Das Grundverständnis von Klassen und ihren Objekten bleibt jedoch stets identisch.
        </p>

        <img src="swe-pk-paradigmen-oop-meinauto.png" alt="OOP - Beispiel"/>

        <chapter title="Objekte" id="grundlagen-objekte">
            <p>
                Objekte sind also konkrete Ausprägungen, eine Instanz, einer Klasse. Instanz könnte man übersetzen mit
                »gehört zur Klasse«: Entsprechend muss ein Objekt instanziiert werden. Dabei können von einer Klasse in
                der Regel beliebig viele Objekte, auch als Instanzen bezeichnet, erstellt werden. Die einzelnen Objekte
                können sich also in den konkreten Werten der Attribute unterscheiden.
            </p>
            <p>
                Zum Beispiel können die Objekte Toyota Avensis und VW Golf erstellt werden, welche beide die Klasse Auto
                verwenden. Sie unterscheiden sich in den Eigenschaften.
            </p>

            <chapter title="Eigenschaften" id="grundlagen-objekte-eigenschaften">
                <p>
                    Die Eigenschaften repräsentieren die Daten des Objekts. Ein Automobil ist je nach Sichtweise ein
                    mehr oder weniger komplexes Objekt, das sich durch folgende <b>Attribute (Eigenschaften)</b>
                    beschreiben lässt:
                </p>

                <list>
                    <li>Hersteller</li>
                    <li>Typ</li>
                    <li>Farbe</li>
                    <li>Zulassungsjahr</li>
                </list>

                <p>
                    Es gibt weitere Attribute, die uns aber bei der Abbildung als Modell für eine Software nicht
                    interessieren. Soll beispielsweise eine Verwaltung für den Fuhrpark eines Unternehmens programmiert
                    werden, so müssen die dafür relevanten Eigenschaften der Fahrzeuge erfasst werden. Dies könnten die
                    eben genannten Attribute sein. Nicht von Interesse für die Software ist dagegen, ob das Auto eine
                    schöne Fußmatte hat und ob im Handschuhfach eine Beleuchtung eingebaut ist.
                </p>

                <chapter title="Attribute" id="grundlagen-objekte-eigenschaften-attribute">
                    <p>
                        Als <b>Attribute</b> werden Variablen bezeichnet, die grundsätzlich nur innerhalb der Klasse
                        verwendet werden können. Sie sind daher als <code>private</code> deklariert. Will man auf die
                        Werte dieser Attribute von außerhalb des Objekts zugreifen, muss man das über Methoden
                        erledigen.
                    </p>
                </chapter>

                <chapter title="Properties" id="grundlagen-objekte-eigenschaften-properties">
                    <p>
                        Moderne Programmiersprachen, wie C#, kennen auch das Konzept der <b>Properties</b>. Über eine
                        Property kann von außen auf das zugeordnete Attribut zugegriffen werden. Die Property ist damit
                        als <code>public</code> deklariert. Der Zugriff kann lesend oder schreibend sein bzw. beide
                        Varianten umfassen.
                    </p>
                </chapter>
            </chapter>

            <chapter title="Methoden" id="grundlagen-objekte-methoden">
                <p>
                    Eine Methode enthält ähnlich wie eine Funktion, Funktionalität. Durch sie werden die Fähigkeiten
                    eines Objektes beschrieben, also welche Funktionen bzw. Aufgaben ein Objekt ausführen kann.
                </p>
                <p>
                    Methoden werden auch dazu verwendet, die Werte bestimmter Attribute zu verändern. Eine Methode
                    Lackieren der Klasse Auto könnte also eine Veränderung der Farbe bewirken. Als Argument müsste die
                    Methode die neue Farbe übermitteln. Aus unserem grauen Toyota könnte also mithilfe der Methode
                    Lackieren ein farbenfrohes blaues Automobil werden. Ebenso dienen Methoden dazu, dass man die Werte
                    von Attributen abfragen kann.
                </p>
                <p>
                    Auch ein Auto verfügt stets über bestimmte Fähigkeiten. Mit Bezug auf die zu entwickelnde Software
                    könnten folgende Methoden von Interesse sein:
                </p>

                <list>
                    <li><code>BehoerdlichZulassen</code>, d. h. Anmeldung bei der zuständigen Behörde, und</li>
                    <li><code>FahrtenbuchAnalysieren</code>.</li>
                </list>

                <p>
                    Natürlich verfügt das reale Objekt über viel mehr Funktionalität. Ein Automobil kann beispielsweise
                    beschleunigen und bremsen. In der Software bilden wir jedoch nur die interessierenden Methoden ab,
                    denn die Software ist ein stark vereinfachtes Modell der Wirklichkeit.
                </p>

                <chapter title="Getter und Setter" id="grundlagen-objekte-methoden-gettersetter">
                    <p>
                        In welcher Form man die Werte von Attributen ändern kann, ist von Programmiersprache zu
                        Programmiersprache etwas unterschiedlich. Historisch und in Anlehnung an die Grundidee der
                        objektorientierten Programmierung kann man von außerhalb eines Objekts nicht auf die Attribute
                        des Objekts direkt zugreifen, sie sind geheim. Dazu verwendet man Methoden. Wie man diese
                        Methoden benennt, spielt grundsätzlich keine Rolle. Zur Vereinfachung dieser Notwendigkeit
                        verwenden viele Sprachen spezielle Methoden, d. h. für das Lesen eine <code>get</code>- und für
                        das Schreiben eine <code>set</code>-Methode. Beispielsweise könnte man mit der Methode
                        <code>setFarbe</code> die Farbe des betreffenden Autoobjekts seinen Wünschen anpassen. Wollte
                        man die aktuelle Farbe wissen, müsste man den Wert über die Methode <code>getFarbe</code>
                        auslesen. Ebenso könnte man – wie im obigen Beispiel angeführt – eine Methode
                        <code>Lackieren</code> erstellen, die auch die Farbe anpasst und vielleicht darüber hinaus noch
                        etwas anderes macht, zum Beispiel eine Schutzversiegelung auf den Lack aufbringt.
                    </p>
                    <p>
                        Da ständig auf die Attribute der Objekte lesend und schreiben zugegriffen werden muss, haben
                        einige Programmiersprachen, zum Beispiel C#, noch mehr Vereinfachungen vorgesehen. Hier
                        definiert man sogenannte Properties. Dabei kann man von außerhalb der Klasse so tun, als ob man
                        direkt das betreffende Attribut liest oder schreibt. Im Hintergrund werden dazu jedoch weiterhin
                        <code>get</code>- und <code>set</code>-Methoden aufgerufen. Um den Entwicklern das Leben jedoch
                        zu erleichtern, werden diese <code>set</code>- und <code>get</code>-Methoden vom Compiler
                        automatisch bei der Erstellung des Programms generiert.
                    </p>
                </chapter>

                <chapter title="Konstruktor" id="grundlagen-objekte-methoden-konstruktor">
                    <p>
                        Der Konstruktor ist eine Methode, die ausgeführt wird, wenn ein Objekt einer Klasse erstellt
                        wird. Sie kann beliebige Parameter übernehmen, mit denen das Objekt instanziiert wird.
                    </p>
                </chapter>

                <chapter title="Destruktor" id="grundlagen-objekte-methoden-destruktor">
                    <p>
                        Die Destruktor-Methode kommt immer dann zum Einsatz, wenn ein Objekt aufgelöst wird.
                    </p>
                </chapter>

                <chapter title="Methoden Überladen" id="grundlagen-objekte-methoden-ueberladen">
                    <p>
                        Überladen bedeutet, eine Methode erhält mehr Parameter als vorgegeben oder Parameter mit
                        unterschiedlichen Datentypen. Zusammengefasst, es werden also Werte übergeben, die die Methode
                        so nicht kennen kann. Überladen ist als Programmiertechnik ausgesprochen praktisch, da eine
                        Methode mit verschiedenen Situationen umgehen kann, für die normalerweise mehrere Methoden
                        notwendig wären.
                    </p>
                </chapter>
            </chapter>

            <chapter title="Garbage Collector" id="grundlagen-objekte-garbagecollector">
                <p>
                    Nachdem ein Objekt einer Klasse durch einen Konstruktor erstellt wurde, wird es im Speicher
                    vorgehalten. Es sollte mindestens so lange existieren, wie es noch benötigt wird. Das ist der Fall,
                    wenn noch auf das Objekt zugegriffen wird. Da einzelne Objekte einen beachtlichen Speicherbedarf
                    haben können, sollten nicht mehr benötigte Objekte wieder gelöscht werden.
                </p>
                <p>
                    Je nach Programmiersprache ist man entweder als Entwickler selbst für das Löschen nicht mehr
                    benötigter Objekte zuständig, oder das System erledigt dies automatisch. Ersteres ist aufwendig und
                    fehleranfällig. Die zweite Variante ist komfortabel und befreit den Entwickler vor lästiger
                    Routinearbeit. Das System der automatischen Speicherfreigabe für nicht mehr benötigte Objekte wird
                    als <b>Garbage-Collection</b> bezeichnet.
                </p>
            </chapter>
        </chapter>

        <chapter title="Klassen" id="grundlagen-klassen">
            <p>
                Ein konkretes Objekt gehört zu einer Klasse oder andersherum betrachtet, eine Klasse ist der Bauplan
                bzw. die Struktur für die zugehörigen Objekte. Mit Struktur sind die Eigenschaften und Methoden des
                Objekts gemeint.
            </p>
            <p>
                Konkretisiert man ein Auto anhand seiner spezifischen Attribute, so gelangt man zum Objektbegriff.
                Konkret: Das Fahrzeug mit dem Kennzeichen EF-LN 88 ist ein konkretes Objekt der Klasse Auto. Dabei weist
                es die folgenden Werte der oben genannten Attribute auf:
            </p>

            <code-block>
                Hersteller = "Toyota";
                Typ = "Avensis";
                Farbe = "grau";
                Zulassungsjahr = 2012;
            </code-block>

            <p>
                Ein anderes Objekt der Klasse Auto hat andere Werte bezüglich dieser Attribute, beispielsweise:
            </p>

            <code-block>
                Hersteller = "VW";
                Typ = "Golf";
                Farbe = "rot";
                Zulassungsjahr = 2014;
            </code-block>

            <p>
                Beide Objekte verfügen also über die gleichen Attribute, aber gegebenenfalls über andere Werte dieser
                Attribute. Sowohl der Toyota als auch der VW kennen die beiden oben genannten Methoden
                <code>BehoerdlichZulassen</code> und <code>FahrtenbuchAnalysieren</code>.
            </p>
        </chapter>

        <chapter title="Ereignisse" id="grundlagen-ereignisse">
            <p>
                Ereignisse gehören streng betrachtet nicht zu den Grundpfeilern der objektorientierten Programmierung,
                sondern zum Konzept der ereignisorientierten Entwicklung von Programmen. Es ist jedoch mit dem Konzept
                der Klassen und Methoden eng verbunden.
            </p>
            <p>
                Beispiele für Ereignisse:
            </p>

            <list>
                <li>
                    Ein Objekt der Klasse Auto ein Ereignis auslösen, wenn in den nächsten vier Wochen der TÜV abläuft.
                    Die Software könnte in diesem Fall mit einem Hinweis den Bearbeiter auf diesen Umstand aufmerksam
                    machen.
                </li>
                <li>
                    Wenn der Nutzer auf ein Element der Benutzeroberfläche, zum Beispiel auf einen Button, klickt. Das
                    zugehörige Ereignis heißt in diesem Fall zum Beispiel <code>ButtonClick</code>-Ereignis.
                </li>
                <li>
                    Wischgesten bei einer Anwendung für Smartphone oder Tablet bzw. Mausbewegungen bei einem
                    Zeichenprogramm.
                </li>
            </list>

            <p>
                Ein Ereignis wird von einem Objekt in einer bestimmten Situation ausgelöst. Grundsätzlich stellen
                Ereignisse die Grundlagen für die Interaktionsfähigkeit der Anwendung dar. Um gegenseitig auf Ereignisse
                zu reagieren, registrieren sich die Objekte untereinander. Beispielsweise kann ein Objekt A sich beim
                Objekt B für ein bestimmtes Ereignis registrieren. Löst Objekt A dieses Ereignis aus, so bekommt Objekt
                B das mit und kann seinerseits ein bestimmtes Verhalten auslösen.
            </p>

            <img src="swe-pk-paradigmen-oop-ereignisse.png" alt="Ereignisse"/>

            <p>
                Auf der linken Seite haben wir die Quelle (eng. <emphasis>Source</emphasis>), in Form eines konkreten
                Objekts einer Klasse. Diese Quelle feuert in einer bestimmten Situation ein Ereignis
                (eng. <emphasis>Event</emphasis>) ab. Beispielsweise könnte die Quelle ein Button sein, der auf das
                Klicken durch den Nutzer reagiert. Andere Objekte – auch als <b>Listener</b> bezeichnet – »lauschen«
                darauf, dass das betreffende Ereignis ausgelöst wird. Ist dies der Fall, dann reagieren sie in
                vorgesehener Art und Weise. Dabei können mehrere Listener parallel das Auslösen eines bestimmten
                Ereignisses überwachen. Ein Objekt der Klasse Berechnungen könnte eine neue Berechnung starten, sobald
                der Nutzer auf den Button geklickt hat. Gleichzeitig könnte ein Objekt der Benutzeroberfläche darauf
                reagieren und dem Nutzer mitteilen, dass nunmehr der Rechenvorgang gestartet wurde.
            </p>
        </chapter>

        <chapter title="Modellierung von Klassen und Objekten" id="grundlagen-modellierung">
            <p>
                Zur Modellierung einzelner Klassen bzw. zur Darstellung der Beziehung von Klassen untereinander
                verwendet man in der Software-Entwicklung häufig sogenannte »Klassendiagramme« der Modellierungssprache
                UML (Unified Modelling Language), die Beziehung von Objekten stellt man dagegen in sogenannten
                »Objektdiagrammen« dar.
            </p>
        </chapter>
    </chapter>

    <chapter title="Unterschied zwischen primitiven Datentypen und Referenztypen" id="datentypen-unterschiede">
        <p>
            Der Unterschied zwischen primitiven Datentypen und Referenztypen ist die Art und Weise, wie die jeweiligen
            Werte gespeichert werden.
        </p>

        <list>
            <li>
                Jedes Mal, wenn eine Variable deklariert wird, sieht der Computer dafür Speicherplatz vor und speichert
                die Variable inklusive Wert in einer dafür vorgesehenen Speicheradresse. Beim primitiven Datentyp wird
                jedes Mal, wenn einer Variable ein Wert zugewiesen wird, der gesamte Wert in diese Speicheradresse
                kopiert.
            </li>
            <li>
                Bei Referenztypen ist dies anders. Hier speichert der Computer in dem für die jeweilige Variable
                vorgesehenen Register nicht den Wert selbst, sondern nur eine Referenz darauf (man spricht in diesem
                Fall auch von Zeigern). Wenn zwei oder mehrere Variablen auf das gleiche Objekt zeigen, bedeutet das
                aber auch, dass man – egal, auf welche der Variablen man zugreift – immer mit dem gleichen Objekt
                arbeitet: Ändert man also, über eine der Variablen eine Eigenschaft des referenzierten Objekts, hat dies
                auch Auswirkungen auf die andere Variable.
            </li>
        </list>

        <p>
            Übergibt man einer Funktion ein Argument primitiven Datentyps, wird der gesamte Wert übergeben und in den
            Parameter der Funktion kopiert. Übergibt man einer Funktion dagegen ein Argument mit Referenztyp, wird nur
            die Referenz auf das entsprechende Objekt übergeben.
        </p>
    </chapter>

    <chapter title="Wesentliche Konzepte der objektorientierten Programmierung" id="konzepte">
        <img src="swe-pk-paradigmen-oop-konzepte.png" alt="Konzepte"/>

        <p>
            Nicht jedes Prinzip wird in gleicher Art und Weise von jeder Programmiersprache umgesetzt. Hier gibt es
            Abweichungen und unterschiedliche Herangehensweisen.
        </p>

        <chapter title="Kapselung" id="konzepte-kapselung">
            <p>
                Unter dem Begriff Datenkapselung (bzw. im Englischen <emphasis>Encapsulation</emphasis> oder auch
                <emphasis>Information Hiding</emphasis>) versteht man in der Objektorientierung das Zusammenfassen von
                Eigenschaften und Methoden zu Klassen bzw. Prototypen, wobei die Details der Implementierung verborgen
                bleiben: In der Regel stellt man die Eigenschaften nur über sogenannte Setter- und Getter-Methoden zur
                Verfügung. Solche Zugriffsmethoden (eng.: <emphasis>Accessor Methods</emphasis> oder einfach
                <emphasis>Accessors</emphasis>) können davor schützen, dass einer Eigenschaft ungültige Werte zugewiesen
                werden. Erlaubt man dagegen einen direkten Zugriff auf die Eigenschaften (und erfüllt damit nicht das
                Prinzip der Datenkapselung), ist dies nicht gewährleistet, da dann auch Werte zugewiesen werden können, die
                nicht gültig sind. Der Datenzugriff wird bei einigen Programmiersprachen auch über spezielle Felder
                geregelt, die jedoch wiederum intern auf <code>get</code>- und <code>set</code>-Methoden zurückgreifen. In
                Programmiersprachen wie Java kann man über spezielle Schlüsselwörter verhindern, dass die Werte von
                Eigenschaften von außen (d. h. von außerhalb einer Objektinstanz) geändert werden können (und zwar, indem
                sie über das Schlüsselwort private als privat markiert werden).
            </p>

            <img src="swe-pk-paradigmen-oop-kapselung.png" alt="Konzept: Kapselung"/>

            <chapter title="Dateneigenschaften und Zugriffseigenschaften" id="konzepte-kapselung-eigenschaften">
                <p>
                    Dateneigenschaften bezeichnen solche Eigenschaften, auf die direkt zugegriffen wird, d.h. ohne
                    Getter- und Setter-Methoden. Zugriffseigenschaften definieren Funktionen, die beim Lesen und
                    Schreiben der entsprechenden Eigenschaft aufgerufen werden (sprich Getter- und Setter-Methoden).
                </p>
            </chapter>
        </chapter>

        <chapter title="Geheimnisprinzip / Sichtbarkeit" id="konzepte-sichtbarkeit">
            <p>
                Das <b>Geheimnisprinzip</b> besagt, dass ein Objekt nach außen nur die Informationen und Methoden
                bereitstellt, die zur Anwendung notwendig sind. Klassen sowie deren Attribute und Methoden können
                unterschiedliche <b>Sichtbarkeiten</b> aufweisen. Die Sichtbarkeit wird durch den Modifizierer, dem
                jeweiligem Schlüsselwort, bestimmt.
            </p>

            <chapter title="Das Geheimnisprinzip" id="konzepte-sichtbarkeit-geheimnisprinzip">
                <p>
                    Ein Beispiel: Alle Objekte der Klasse Auto verfügen über die Methode
                    <code>FahrtenbuchAnalysieren</code>. Für einen Benutzer ist es nicht von Interesse, wie dies
                    innerhalb der Klasse umgesetzt wird. Es interessiert nur, dass der Aufruf der Methode zum
                    gewünschten Ergebnis führt. Die Funktionsweise der Klasse wirkt nach außen wie eine Black Box.
                </p>

                <img src="swe-pk-paradigmen-oop-geheimnisprinzip.png" alt="Konzepte: Geheimnisprinzip"/>

                <p>
                    Das Prinzip der Black Box hat hier mehrere Bedeutungen. Möchte man die Funktionalität einer Klasse
                    bzw. seiner Objekte nutzen, muss man in keiner Weise dabei wissen, wie die Verarbeitung intern
                    funktioniert. Dieses Prinzip ist essenziell für die Wiederverwendung von Programmcode.
                </p>
                <p>
                    Als Entwickler ist es üblich, für viele Standardaufgaben die Funktionalität einer allgemein zu
                    verwendenden Klasse zu nutzen, beispielsweise einen speziellen Such-Algorithmus, der als Methode
                    einer Klasse implementiert sein kann. Diese Algorithmen können sehr kompliziert sein, wie wir im
                    kommenden Kapitel sehen werden. Die wirkliche Funktionsweise müssen wir jedoch nicht kennen. Es
                    kommt lediglich darauf an, welche Inputdaten wir an den Algorithmus übergeben und welches Ergebnis
                    wir zurückbekommen. Auch wenn zu einem späteren Zeitpunkt die Klasse aktualisiert wird, weil
                    beispielsweise der verwendete Such-Algorithmus gegen ein leistungsfähigeres Exemplar ausgetauscht
                    wird, ist das Geheimnisprinzip wichtig. Die Klasse kann problemlos in der ursprünglichen Form
                    weiterverwendet werden. Dabei muss man sicherstellen, dass die Schnittstellen gegenüber der
                    vorherigen Version unverändert bleiben. Die technische Umsetzung innerhalb der Klasse kann dabei
                    angepasst werden.
                </p>
            </chapter>

            <chapter title="Die Sichtbarkeit" id="konzepte-sichtbarkeit-sichtbarkeit">
                <p>
                    Die Sichtbarkeit bestimmt, welche Elemente eines Objekts für andere Objekte sichtbar sind. Die
                    beiden Extreme lauten:
                </p>

                <list>
                    <li><code>private</code>: Das Element ist nur innerhalb der Klasse sichtbar.</li>
                    <li><code>public</code>: Das Element ist für alle anderen Objekte sichtbar.</li>
                </list>

                <p>
                    Beispielsweise werden Attribute, die nur für eine Berechnung innerhalb einer Methode benutzt werden,
                    als <code>private</code> definiert. Soll auf die Daten eines Objekts auch von außen zugegriffen
                    werden, so ist das Element als <code>public</code> zu kennzeichnen. Für die Klasse PKW könnte es
                    beispielsweise sinnvoll sein, die Property Leistung als <code>public</code> zu definieren, denn so
                    können andere Objekte diesen Wert erfragen. Je nach Programmiersprache kann man zwischen den beiden
                    Extremen <code>public</code> und <code>private</code> weitere Abstufungen in den Sichtbarkeiten
                    definieren. Beispielsweise könnte das Schlüsselwort <code>protected</code> darauf hinweisen, dass
                    ein Zugriff von außen auf das Klassenelement möglich, aber nur innerhalb des Moduls erlaubt ist.
                </p>
            </chapter>
        </chapter>

        <chapter title="Vererbung" id="konzepte-vererbung">
        </chapter>

        <chapter title="Abstraktion &amp; Generalisierung / Spezialisierung" id="konzepte-abstraktion">
            <chapter title="Generalisierung / Spezialisierung" id="konzepte-abstraktion-generalisierung">
            </chapter>

            <chapter title="Abstrakte Klassen" id="konzepte-abstraktion-abstrakteklassen">
            </chapter>
        </chapter>

        <chapter title="Polymorphismus" id="konzepte-polymorphismus">
        </chapter>
    </chapter>

    <chapter title="Wiederverwendung" id="wiederverwendung">
        <chapter title="Verwaltung der Bibliotheken" id="wiederverwendung-bibliotheken">
        </chapter>

        <chapter title="Softwarekomponenten" id="wiederverwendung-komponenten">
        </chapter>
    </chapter>

    <chapter title="Quellen" id="quellen">
        <tip>
            <b>(BUCH)</b>
            978-3836244763, "Handbuch für Softwareentwickler", Veikko Krypczyk &amp; Elena Bochkor, 2018
        </tip>
        <tip>
            <b>(BUCH)</b>
            978-3836240826, "PHP 7 und MySQL - Das umfassende Handbuch", Christian Wenz &amp; Tobias Hauser, 2016
        </tip>
        <tip>
            <b>(BUCH)</b>
            978-3836256971, "JavaScript - Das umfassende Handbuch", Philip Ackermann, 2018
        </tip>
    </chapter>
</topic>