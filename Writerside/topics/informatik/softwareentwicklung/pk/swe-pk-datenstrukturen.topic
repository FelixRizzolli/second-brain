<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
        SYSTEM "https://resources.jetbrains.com/writerside/1.0/xhtml-entities.dtd">
<topic xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="https://resources.jetbrains.com/writerside/1.0/topic.v2.xsd"
       title="Datenstrukturen" id="swe-pk-datenstrukturen">
    <show-structure for="chapter,procedure" depth="2"/>

    <chapter title="Allgemeines über Datenstrukturen" id="allgemeines">
        <p>
            Datenstruktur dient der Speicherung und Organisation von Daten. Dabei handelt sich um eine Struktur, denn
            die Daten werden in einer bestimmten Art und Weise angeordnet. Ziel ist es, die Daten in einem
            Computerprogramm so zu strukturieren, dass zum einen der Entwickler damit leicht arbeiten kann und die
            Verwendung der Daten im Programmcode möglichst intuitiv ist, und dass zum anderen der Computer effektiv auf
            die Daten zugreifen kann.
        </p>
        <p>
            Moderne Programmiersprachen stellen dem Entwickler eine Vielzahl von Datenstrukturen zur Verfügung. Es ist
            aber auch möglich, sich seine eigenen Datenstrukturen zu definieren, um die Zusammenhänge eines spezifischen
            Anwendungsfalls in der Praxis möglichst gut nachzubilden.
        </p>
    </chapter>

    <chapter title="Datenobjekte" id="datenobjekte">
        <chapter title="Einleitung" id="datenobjekte-einleitung">
            <p>
                Ein Datenobjekt dient der Speicherung einer Information in einer bestimmten Struktur. Es zeichnet sich
                durch folgende Eigenschaften aus:
            </p>
            
            <img src="swe-pk-datenstrukturen-datenobjekte-uebersicht.jpg" alt="Datenobjekte - Übersicht"/>
        </chapter>

        <chapter title="Datentyp" id="datenobjekte-datentyp">
            <p>
                Der Datentyp legt fest, welche Arten von Daten (z.B. Zahlen, Texte) darin gespeichert werden können und
                welche Operationen mit dem Datenobjekt erlaubt sind.
            </p>
        </chapter>

        <chapter title="Wert" id="datenobjekte-wert">
            <p>
                In vielen Programmiersprachen muss zunächst das Datenobjekt deklariert werden, damit dafür Speicherplatz
                reserviert wird. Die folglich erstmalige Zuweisung eines Wertes wird Definition genannt. Deklaration und
                Definition kann oftmals auch kombiniert werden.
            </p>
            <p>
                Eine Besonderheit in vielen Programmiersprachen ist der Wert Null. Dieser Wert ist vom Zahlenwert 0
                verschieden. Der Wert Null ist vielmehr mit den Worten »nichts« oder »leer« zu interpretieren. Ein
                solcher Wert für ein Datenobjekt spielt immer dann eine Rolle, wenn auf ein komplexes Objekt im Speicher
                verwiesen wird. Null zeigt dann an, dass der Wert nicht definiert bzw. das Objekt noch nicht erstellt
                wurde. Objekte sind in diesem Verständnis Datentypen einer bestimmten Klasse.
            </p>
        </chapter>

        <chapter title="Adresse" id="datenobjekte-adresse">
            <p>
                Jedes Datenobjekt hat eine Adresse. Diese Adresse gibt genau an, an welcher Stelle im Speicher
                (Hauptspeicher des Computers) sich das Datenobjekt befindet. Manipulationen auf Speicherebene sind
                komplex und fehlerbehaftet. Operationen auf Adressebene sind bei einem Datenobjekt also nur bei sehr
                systemnaher Programmierung von zum Beispiel Hardwaretreibern notwendig.
            </p>
        </chapter>

        <chapter title="Bezeichner" id="datenobjekte-bezeichner">
            <p>
                Der Bezeichner eines Datenobjekts gibt an, mit welchem Namen das Datenobjekt angesprochen wird. Dabei
                muss beachtet werden, dass der Name grundsätzlich eindeutig sein muss, damit Verwechslungen zwischen
                Datenobjekten ausgeschlossen sind. Diese Regel gilt immer in Bezug auf den sog. Gültigkeitsbereich. Der
                Gültigkeitsbereich ist ein abgegrenzter Bereich unterschiedlichen Ausmaßes innerhalb des Quellcodes.
                Dies kann zum Beispiel eine Methode, eine Klasse oder eine Bibliothek sein.
            </p>
        </chapter>

        <chapter title="Lebensdauer" id="datenobjekte-lebensdauer">
            <p>
                Die Lebensdauer eines Datenobjekts meint die Zeitspann von dessen Erzeugung bis zum Löschen. Bei vielen
                Programmiersprachen sorgt das System selbst für ein automatisiertes Löschen des Datenobjekts, wenn es
                nicht mehr benötigt wird.
            </p>
        </chapter>

        <chapter title="Bindungszeitpunkt" id="datenobjekte-bindungszeitpunkt">
            <p>
                Mit Bindungszeitpunkt ist jener Zeitpunkt gemeint, wann das Datenobjekt wirklich erzeugt wird, d.h.,
                wann der Speicherbereich dem Namen zugeordnet (gebunden) wird.
            </p>

            <list>
                <li>
                    Bei sog. <emphasis>stark typisierten Sprachen</emphasis> erfolgt die Bindung zur Entwurfszeit. Der
                    Programmierer muss üblicherweise den Datentyp für ein Datenobjekt angeben.
                </li>
                <li>
                    Bei nicht <emphasis>stark typisierten Sprachen</emphasis> passiert die Bindung erst zur Laufzeit.
                    Erst dann versucht das Programm, einen sinnvollen Datentyp auszuwählen und darin die Informationen
                    zu speichern.
                </li>
            </list>

            <p>
                Beide Varianten haben Vor- und Nachteile. Die frühe Datenbindung zur Entwurfszeit vermeidet Fehler; die
                Datenbindung zur Laufzeit gibt dem System mehr Flexibilität.
            </p>
        </chapter>

        <chapter title="Speicherklasse" id="datenobjekte-speicherklasse">
            <p>
                Diese Eigenschaft bestimmt, in welchem Teil des Hauptspeichers das Datenobjekt angelegt wird.
                Üblicherweise wird das durch das System festgelegt.
            </p>
        </chapter>

        <chapter title="Eigentümer" id="datenobjekte-eigentuemer">
            <p>
                Dabei ist gemeint welcher Systemteil des Programms welche »Rechte« über das Datenobjekt hat. Mit Rechten
                sind das Erzeugen, das Lesen, das Schreiben und das Löschen eines Datenobjekts gemeint.
            </p>
        </chapter>
    </chapter>

    <chapter title="Systematik" id="systematik">

    </chapter>

    <chapter title="Datentypen" id="datentypen">
        <p>
            Man unterscheidet zwischen Grunddatentypen und anwendungsorientierten Datentypen.
        </p>

        <img src="swe-pk-datenstrukturen-datentypen-uebersicht.jpg" alt="Datentypen - Übersicht"/>

        <list>
            <li>
                <b>Grunddatentypen</b> werden durch die Programmiersprache direkt bereitgestellt. Sie decken die
                wesentlichen Aspekte der Datenspeicherung in einem Computerprogramm ab, und sie stellen die Basis für
                Erweiterungen jeder Art dar.
            </li>
            <li>
                <b>Anwendungsorientierte Datentypen</b> lassen sich bei Zerlegung wieder auf Grunddatentypen
                zurückführen. Hier werden mehrere Datenobjekte zu einem Gesamtkonstrukt zusammengefasst.
            </li>
            <li>
                <b>Abgeleitete Datentypen</b> gehen in fast die gleiche Richtung. Hier geht es zum Beispiel darum, dass
                Datenobjekte der gleichen Art zu einem Mengentyp wie einer Liste oder ein Array zusammengefasst werden.
                Auf einzelnen Elemente einer solchen Liste kann dann üblicherweise mit einem Index zugegriffen werden.
            </li>
        </list>

        <chapter title="Grunddatentypen" id="datentypen-grund">
            <chapter title="Bit und Byte" id="datentypen-grund-bitbyte">
                <p>
                    Die Grundlage jeder Speicherung von Informationen in einem Rechner ist das Bit. Hier wird nur 
                    zwischen den beiden Zuständen 0 und 1 unterschieden. Die kleinste adressierbare Einheit ist das 
                    Byte. Es umfasst jeweils 8 Bit. Da jedes Bit die besagten zwei Werte annehmen kann, ergibt das 
                    insgesamt 256 Kombinationen, denn 28 = 256. Neben der Darstellung in Binärform spielen noch 
                    sedezimale (hexadezimale) und dezimale Darstellung eine wichtige Rolle.
                </p>

                <chapter title="Tabelle (Binär, Hexadezimal, Dezimal)" id="datentypen-grund-bitbyte-tabelle">
                    <table style="header-row">
                        <tr>
                            <td>Binärdarstellung (Basis 2)</td>
                            <td>Sedezimaldarstellung (Basis 16)</td>
                            <td>Dezimaldarstellung (Basis 10)</td>
                        </tr>
                        <tr><td><code>0000 0000</code></td><td><code>00</code></td><td><code>0</code></td></tr>
                        <tr><td><code>0000 0001</code></td><td><code>01</code></td><td><code>1</code></td></tr>
                        <tr><td><code>0000 0010</code></td><td><code>02</code></td><td><code>2</code></td></tr>
                        <tr><td><code>0000 0011</code></td><td><code>03</code></td><td><code>3</code></td></tr>
                        <tr><td><code>0000 0100</code></td><td><code>04</code></td><td><code>4</code></td></tr>
                        <tr><td><code>0000 0101</code></td><td><code>05</code></td><td><code>5</code></td></tr>
                        <tr><td><code>0000 0110</code></td><td><code>06</code></td><td><code>6</code></td></tr>
                        <tr><td><code>0000 0111</code></td><td><code>07</code></td><td><code>7</code></td></tr>
                        <tr><td><code>0000 1000</code></td><td><code>08</code></td><td><code>8</code></td></tr>
                        <tr><td><code>0000 1001</code></td><td><code>09</code></td><td><code>9</code></td></tr>
                        <tr><td><code>0000 1010</code></td><td><code>0A</code></td><td><code>10</code></td></tr>
                        <tr><td><code>0000 1011</code></td><td><code>0B</code></td><td><code>11</code></td></tr>
                        <tr><td><code>0000 1100</code></td><td><code>0C</code></td><td><code>12</code></td></tr>
                        <tr><td><code>0000 1101</code></td><td><code>0D</code></td><td><code>13</code></td></tr>
                        <tr><td><code>0000 1110</code></td><td><code>0E</code></td><td><code>14</code></td></tr>
                        <tr><td><code>0000 1111</code></td><td><code>0F</code></td><td><code>15</code></td></tr>
                        <tr><td><code>0001 0000</code></td><td><code>10</code></td><td><code>16</code></td></tr>
                        <tr><td><code>0001 0001</code></td><td><code>11</code></td><td><code>17</code></td></tr>
                        <tr><td><code>...</code></td><td><code>...</code></td><td><code>...</code></td></tr>
                        <tr><td><code>0001 1111</code></td><td><code>1F</code></td><td><code>31</code></td></tr>
                        <tr><td><code>0010 0000</code></td><td><code>20</code></td><td><code>32</code></td></tr>
                        <tr><td><code>0010 0001</code></td><td><code>21</code></td><td><code>33</code></td></tr>
                        <tr><td><code>...</code></td><td><code>...</code></td><td><code>...</code></td></tr>
                        <tr><td><code>0010 1111</code></td><td><code>2F</code></td><td><code>47</code></td></tr>
                        <tr><td><code>0011 0000</code></td><td><code>30</code></td><td><code>48</code></td></tr>
                        <tr><td><code>0011 0001</code></td><td><code>31</code></td><td><code>49</code></td></tr>
                        <tr><td><code>...</code></td><td><code>...</code></td><td><code>...</code></td></tr>
                        <tr><td><code>0011 1111</code></td><td><code>3F</code></td><td><code>63</code></td></tr>
                        <tr><td><code>...</code></td><td><code>...</code></td><td><code>...</code></td></tr>
                        <tr><td><code>1111 0000</code></td><td><code>F0</code></td><td><code>240</code></td></tr>
                        <tr><td><code>1111 0001</code></td><td><code>F1</code></td><td><code>241</code></td></tr>
                        <tr><td><code>...</code></td><td><code>...</code></td><td><code>...</code></td></tr>
                        <tr><td><code>1111 1110</code></td><td><code>FE</code></td><td><code>254</code></td></tr>
                        <tr><td><code>1111 1111</code></td><td><code>FF</code></td><td><code>255</code></td></tr>
                    </table>
                </chapter>
            </chapter>

            <chapter title="Datentyp Binärwert" id="datentypen-grund-binaerwert">
                <p>
                    Beim Binärwert handelt es sich üblicherweise um den einfachsten Datentyp, den eine
                    Programmiersprache zu bieten hat. Man unterscheidet lediglich die Zustände true und false. Die
                    typischen Bezeichnungen für diesen Datentyp sind bool oder boolean. Ergebnisse von Prüfungen aller
                    Art werden üblicherweise mit einer Variable vom Typ bool zurückgegeben.
                </p>
            </chapter>

            <chapter title="Datentyp Zahl" id="datentypen-grund-zahl">

            </chapter>

            <chapter title="Datentyp Zeichenkette" id="datentypen-grund-zeichenkette">

            </chapter>

            <chapter title="Datentyp Adresse" id="datentypen-grund-adresse">

            </chapter>
        </chapter>

        <chapter title="Spezifische Datentypen" id="datentypen-spezifisch">

            <chapter title="Arrays" id="datentypen-spezifisch-arrays">

            </chapter>
        </chapter>
    </chapter>

    <chapter title="Quellen" id="quellen">
        <tip>
            <b>(BUCH)</b>
            978-3836244763, "Handbuch für Softwareentwickler", Veikko Krypczyk &amp; Elena Bochkor, 2018
        </tip>
    </chapter>
</topic>