<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
        SYSTEM "https://resources.jetbrains.com/writerside/1.0/xhtml-entities.dtd">
<topic xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="https://resources.jetbrains.com/writerside/1.0/topic.v2.xsd"
       title="Allgemeines über die Programmierung" id="swe-pk-grundlagen-allgemeines">
    <show-structure for="chapter,procedure" depth="2"/>

    <chapter title="Geschichte zur Programmierung" id="geschichte">
        <p>
            Erste Ideen, die mit dem heutigen Ansatz der Programmierung im weitestgehenden Sinne vergleichbar sind,
            stammen bereits aus dem 17. Jh. Als erste mechanische Rechenmaschine (1635) wird die sog. Rechenuhr des
            deutschen Mathematikers Wilhelm Schickard (1592-1635) bezeichnet. Den Aufzeichnungen zufolge sollte sie alle
            vier Grundrechenarten mit Zahlen bis zu einer Größe von einer Million beherrschen. Ob diese Maschine
            tatsächlich gebaut wurde, ist nicht klar. Möglich wäre es jedoch gemäß der Aufzeichnungen gewesen. Den
            gleichen Ansatz verfolgt die 1643 gebaute Pascaline des französischen Mathematikers Blaise Pascal
            (1623–1662). Aufgrund von Ungenauigkeiten in der Konstruktion produzierte die Maschine jedoch fehlerhafte
            Ergebnisse. Zu erwähnen ist in diesem Zusammenhang auch die Einführung des programmierbaren Webstuhls von
            Joseph-Marie Jacquard. Der Webstuhl wurde durch Lochstreifen gesteuert, d. h., das zu webende Muster wurde
            damit festgelegt. Die ersten Ideen zur Programmierung von Rechnern gehen zurück auf Charles Babbage
            (1791–1871). Er entwarf zwei Rechenmaschinen, die Difference Engine (1823) und die Analytical Engine (1834),
            die jedoch niemals fertiggestellt wurden. Die Operation, die ausgeführt werden sollte, war die Addition von
            27-stelligen Dezimalzahlen. Die Logik steckte ohne Programmiersprache in einfachen Maschinenkonstruktionen.
            Als Pionier auf dem Gebiet der Programmierung gilt Konrad Zuse (1910–1995). Konrad Zuse wurde am 22. Juni
            1910 in Berlin geboren. Er hatte die Vision, stupide Rechenarbeiten auf eine Maschine zu übertragen. Konrad
            Zuse wollte binär arbeitende Rechner bauen. Diese sollten mit sogenannten bistabilen Bauelementen arbeiten.
            Nach diesem Prinzip, der Aussagenlogik, sollten nicht nur Zahlen verarbeitet werden, sondern die gesamte
            Maschine sollte darauf beruhen. Die erste Maschine, Z1, konstruierte er in den Jahren 1936 bis 1938. Es war
            die erste programmierbare Rechenmaschine der Welt. Einen Nachbau kann man heute im Museum für Verkehr und
            Technik in Berlin besichtigen. Weiterentwicklungen waren die Z2 (Konstruktion 1938 bis 1939) und die Z3
            (Konstruktion 1941). Die Z3 beinhaltete ca. 600 Relais im Rechenwerk und 1.400 Relais im Speicher. Die Z3
            gilt heute als der erste funktionsfähige, frei programmierbare, auf dem binären Zahlensystem und der binären
            Schaltungstechnik basierende Rechner der Welt. Die Z4, begonnen im Jahr 1942, wurde 1949 nach dem Krieg
            restauriert und war ab 1950 fünf Jahre lang an der Eidgenössischen Technischen Hochschule in Zürich im
            Einsatz. In den Jahren 1942 bis 1946 arbeitete Konrad Zuse an einer universellen algorithmischen Sprache,
            Plankalkül. Plankalkül enthielt unter anderem Zuweisungszeichen, Datenstrukturen, Datentypen wie Gleit- und
            Festkommazahlen, Unterprogrammtechnik, verschiedene Schleifentypen und darüber hinaus umfangreiche
            Abhandlungen zu Schachprogrammen. Es wurde erst 1971 veröffentlicht.
        </p>
        <p>
            Zur Macht der Computer soll Konrad Zuse gesagt haben:
        </p>

        <tip>
            »Wenn die Computer zu mächtig werden, dann zieht doch einfach den Stecker aus der Steckdose«.
        </tip>

        <note>
            <p><b>WICHTIG!</b></p>

            <p>
                Auch die historische Entwicklung von Programmiersprachen spielt bis heute eine große Rolle.
            </p>
        </note>

        <chapter title="Tabelle bekannter und zugleich historischer Programmiersprachen" id="geschichte-tabelle">
            <table style="both">
                <tr>
                    <td>Name der Sprache</td>
                    <td>Erscheinungsdatum</td>
                    <td>Sprachkategorie</td>
                    <td>Anwendungsgebiet/Bemerkung</td>
                </tr>
                <tr>
                    <td>Fortan</td>
                    <td>1954</td>
                    <td>prozedural</td>
                    <td>
                        mathematisch-technische Probleme
                    </td>
                </tr>
                <tr>
                    <td>Algol 60</td>
                    <td>1958</td>
                    <td>prozedural</td>
                    <td>
                        mathematisch-wissenschaftliche Probleme
                    </td>
                </tr>
                <tr>
                    <td><a href="cobol.topic">COBOL</a></td>
                    <td>1959</td>
                    <td>prozedural, objektorientiert</td>
                    <td>
                        kaufmännische Probleme; keine klare Definition, unsystematischer Aufbau, eine der am weitest
                        verbreiteten Sprachen; 1997 erweitert zu OO-Cobol mit objektorientierter Konzeption
                    </td>
                </tr>
                <tr>
                    <td>Lisp</td>
                    <td>1959</td>
                    <td>funktional</td>
                    <td>
                        gut geeignet für sog. symbolische Berechnungen
                    </td>
                </tr>
                <tr>
                    <td>Basic</td>
                    <td>1963</td>
                    <td>prozedural</td>
                    <td>
                        universell; Sprachumfang nicht einheitlich festgelegt
                    </td>
                </tr>
                <tr>
                    <td>PL/I</td>
                    <td>1964</td>
                    <td>prozedural</td>
                    <td>
                        mathematisch-technische und kaufmännische Probleme; sehr umfangreich
                    </td>
                </tr>
                <tr>
                    <td>Simula 67</td>
                    <td>1965</td>
                    <td>prozedural</td>
                    <td>
                        mathematisch-wissenschaftliche Probleme und Simulationen
                    </td>
                </tr>
                <tr>
                    <td>Pascal</td>
                    <td>1971</td>
                    <td>prozedural</td>
                    <td>
                        mathematisch-technische und kaufmännische Probleme; als Lehrsprache bekannt
                    </td>
                </tr>
                <tr>
                    <td>C</td>
                    <td>1974</td>
                    <td>prozedural</td>
                    <td>
                        systemnahe Programmierung; sehr verbreitet
                    </td>
                </tr>
                <tr>
                    <td>Modula-2</td>
                    <td>1976</td>
                    <td>prozedural, objektorientiert</td>
                    <td>
                        mathematisch-technische und kaufmännische Probleme; Weiterentwicklung zu Modula-3
                        (objektorientiert)
                    </td>
                </tr>
                <tr>
                    <td>Prolog</td>
                    <td>1977</td>
                    <td>prädikativ</td>
                    <td>
                        Anwendung mit symbolischen Formeln; Einsatz bei Expertensystemen
                    </td>
                </tr>
                <tr>
                    <td>Ada</td>
                    <td>1979</td>
                    <td>prozedural, objektorientiert</td>
                    <td>
                        Echtzeitanwendung; Weiterentwicklung von Pascal; Ada-95 um Objektorientierung erweitert
                    </td>
                </tr>
                <tr>
                    <td><a href="sql.topic">SQL</a></td>
                    <td>1970</td>
                    <td>deklarativ</td>
                    <td>
                        Datenbankanwendung; seit 1983 genormt
                    </td>
                </tr>
                <tr>
                    <td>Smalltalk-80</td>
                    <td>1970</td>
                    <td>objektorientiert</td>
                    <td>
                        universell; erste objektorientierte Sprache
                    </td>
                </tr>
                <tr>
                    <td>C++</td>
                    <td>1980</td>
                    <td>prozedural, objektorientiert</td>
                    <td>
                        universell; Obermenge von C
                    </td>
                </tr>
                <tr>
                    <td>Eiffel</td>
                    <td>1986</td>
                    <td>objektorientiert</td>
                    <td>
                        umfangreiche Softwaresysteme
                    </td>
                </tr>
                <tr>
                    <td>Pearl</td>
                    <td>1987</td>
                    <td>prozedural, modular, teilweise objektorientiert</td>
                    <td>
                        plattformunabhängige, interpretierte Scriptsprache
                    </td>
                </tr>
                <tr>
                    <td><a href="java.topic">Java</a></td>
                    <td>1990</td>
                    <td>objektorientiert</td>
                    <td>
                        universell
                    </td>
                </tr>
                <tr>
                    <td>Haskell</td>
                    <td>1990</td>
                    <td>funktional</td>
                    <td>
                        Anwendungen in der Wissenschaft
                    </td>
                </tr>
                <tr>
                    <td><a href="python.topic">Python</a></td>
                    <td>1991</td>
                    <td>multiparadigmatisch</td>
                    <td>
                        universelle, üblicherweise interpretierte höhere Programmiersprache
                    </td>
                </tr>
                <tr>
                    <td>R</td>
                    <td>1993</td>
                    <td>funktional, dynamisch, objektorientiert</td>
                    <td>
                        freie Programmiersprache für statistische Berechnungen und Grafiken
                    </td>
                </tr>
                <tr>
                    <td><a href="javascript.topic">JavaScript</a></td>
                    <td>1995</td>
                    <td>objektorientiert, prozedural, funktional</td>
                    <td>
                        Scriptsprache für interaktive Web-Anwendungen
                    </td>
                </tr>
                <tr>
                    <td><a href="csharp.topic">C#</a></td>
                    <td>2002</td>
                    <td>objektorientiert</td>
                    <td>
                        Anwendung auf Microsoft-Plattformen
                    </td>
                </tr>
                <tr>
                    <td>Go</td>
                    <td>2009</td>
                    <td>multiparadigmatisch</td>
                    <td>
                        entwickelt von Google; kompilierbare Programmiersprache, die Nebenläufigkeit unterstützt und
                        über eine automatische Speicherbereinigung verfügt
                    </td>
                </tr>
                <tr>
                    <td>Rust</td>
                    <td>2010</td>
                    <td>multiparadigmatisch</td>
                    <td>
                        als sichere, nebenläufige und praxisnahe Sprache von Mozilla Research entwickelt
                    </td>
                </tr>
                <tr>
                    <td><a href="swift.topic">Swift</a></td>
                    <td>2014</td>
                    <td>multiparadigmatisch</td>
                    <td>
                        Programmiersprache von Apple für iOS, macOS, tvOS, watchOS und Linux
                    </td>
                </tr>
            </table>
        </chapter>
    </chapter>

    <chapter title="Generationen der Programmiersprachen" id="generationen">
        <chapter title="Grundlegendes" id="generationen-grundlegendes">
            <p>
                Programmiersprachen lassen sich nicht nur nach ihrem Verwendungszweck (kaufmännisch, technisch,
                mathematisch) und ihrer Sprachkategorie (objektorientiert, funktional) einteilen, sondern auch nach
                ihrem Grad der Abstraktion. Nach diesem Kriterium unterteilt man sie in Sprachen der ersten bis vierten
                Generation. Heute kommen primär Programmiersprachen der dritten und vierten Generation zum Einsatz, das
                heißt aber nicht, dass man eine Sprache einer früheren Generation nicht mehr verwendet.
            </p>
            
            <img src="swe-pk-grundlagen-allgemeines-abstraktionsgrad.png"
                 alt="Abstraktionsgrad einer Programmiersprache" />
        </chapter>

        <chapter title="Sprachen der ersten Generation: Maschinensprachen" id="generationen-gen1">
            <p>
                Computer waren zu Beginn ausschließlich in Maschinensprache, d. h. als Folge von Nullen und Einsen zu
                programmieren. Befehle und zu bearbeitende Daten wurden dabei in Kombination an den Prozessor gesandt.
                Typische Operationen sind das Verschieben von Daten aus dem Speicher in bestimmte Register des
                Prozessors und einfachste arithmetische Operationen, zum Beispiel Addition und Subtraktion, mit den
                Inhalten der Register.
            </p>

            <code-block>
                1: 10110000 01100011
                2: (hex) B0 63
                3: Operand 0x63 wird in AL-Register geladen
            </code-block>

            <p>
                Man kann sagen, dass die Programmierung in Maschinensprache aus heutiger Sicht fast keine Bedeutung mehr
                hat. Der Code in Maschinensprache unterscheidet sich von Prozessortyp zu Prozessortyp. Für jeden
                Prozessortyp muss also ein eigenes Programm in Maschinensprache erstellt werden, damit es die gleichen
                Aufgaben ausführt.
            </p>
        </chapter>

        <chapter title="Sprachen der zweiten Generation: Assemblersprachen" id="generationen-gen2">
        </chapter>

        <chapter title="Sprachen der dritten Generation: Höhere Programmiersprachen" id="generationen-gen3">
        </chapter>

        <chapter title="Sprachen der vierten und höheren Generation" id="generationen-gen4">
        </chapter>
    </chapter>

    <chapter title="Compiler &amp; Interpreter" id="compiler">

        <chapter title="Kompilierte Programmiersprachen" id="compiler-kompiliert">
        </chapter>

        <chapter title="Interpretierte Programmiersprachen" id="compiler-interpretiert">
        </chapter>

        <chapter title="Vor- und Nachteile" id="compiler-procontra">
        </chapter>

        <chapter title="Zwischensprachen" id="compiler-zwischensprachen">
        </chapter>

        <chapter title="Übersicht über verschiedene Programmiersprachen" id="compiler-uebersicht">
        </chapter>
    </chapter>

    <chapter title="Programmierparadigmen" id="programmierparadigmen">
    </chapter>

    <chapter title="Quellen" id="quellen">
    </chapter>
</topic>